<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Code &gt; Explain &gt; Transalte 的人</title>
    <link>/</link>
    <description>Recent content on Code &gt; Explain &gt; Transalte 的人</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 02 Sep 2019 10:11:45 +0800</lastBuildDate>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>小的Rust结构类型,应使用复制还是借用传递?</title>
      <link>/2019/09/02/%E5%B0%8F%E7%9A%84rust%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B%E5%BA%94%E4%BD%BF%E7%94%A8%E5%A4%8D%E5%88%B6%E8%BF%98%E6%98%AF%E5%80%9F%E7%94%A8%E4%BC%A0%E9%80%92/</link>
      <pubDate>Mon, 02 Sep 2019 10:11:45 +0800</pubDate>
      
      <guid>/2019/09/02/%E5%B0%8F%E7%9A%84rust%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B%E5%BA%94%E4%BD%BF%E7%94%A8%E5%A4%8D%E5%88%B6%E8%BF%98%E6%98%AF%E5%80%9F%E7%94%A8%E4%BC%A0%E9%80%92/</guid>
      <description>对于小的 Rust 结构类型，应使用复制（copy）还是借用(borrow)传递？ 2019 年 8 月 26 日 ❤️ 原文
像许多好故事一样，这个故事从一个简单的问题开始。对于小的 Rust 结构类型，应使用复制还是借用传递？例如：
struct Vector3 { x: f32, y: f32, z: f32 } fn dot_product_by_copy(a: Vector3, b: Vector3) -&amp;gt; float { a.x*b.x + a.y*b.y + a.z*b.z } fn dot_product_by_borrow(a: &amp;amp;Vector3, b: &amp;amp;Vector3) -&amp;gt; float { a.x*b.x + a.y*b.y + a.z*b.z }  就是这个简单的问题将我带向了长征之路，带有些惊人的曲折和发现。
为什么这个问题是重要的呢 这个问题的答案有两个原因：性能和人体工程学。
性能 通过复制传递就是说，我们要每个Vector3复制 12 个字节(3 个 f32 类型)。 若是通过 borrow 传递，那么每个Vector3就是一个 8 字节的指针（在 64 位上）。其实两者很接近，也许对性能来说无关紧要。</description>
    </item>
    
    <item>
      <title>如何用VSCode调试Rust(译)</title>
      <link>/2019/08/30/%E5%A6%82%E4%BD%95%E7%94%A8vscode%E8%B0%83%E8%AF%95rust%E8%AF%91/</link>
      <pubDate>Fri, 30 Aug 2019 11:13:52 +0800</pubDate>
      
      <guid>/2019/08/30/%E5%A6%82%E4%BD%95%E7%94%A8vscode%E8%B0%83%E8%AF%95rust%E8%AF%91/</guid>
      <description>如何用 Visual Studio Code 调试 Rust 🌟 2019-03-24 ❤️ 原文
我是 Visual Studio Code 编辑器的铁杆。不幸的是，它的 Rust 调试不 太能 开箱即用。
配置调试器并不困难。但有几个步骤。我已经看了好几遍了。我写这本指南是为了省下未来回想的脑力。
希望本指南对其他一些人也有用。
安装 Rust 和 VS Code 这应该不用多说了。
安装 Rust
安装 Visual Studio Code
安装 VS Code 扩展 您需要安装一个扩展。哪一个取决于你的平台。
C/C++（Windows）
codelldb（OS X/Linux）
还要继续安装Rust 扩展。
配置 VS Code 现在已经安装了工具，您需要配置 VS Code 启动属性。
单击“调试(Debug)”-&amp;gt;“添加配置(Add Configuration)”
如果您在 Windows 上，请选择C++ (Windows)
如果您使用的是 Mac 或 Linux，请选择LLDB: Custom Launch
这应该会创建并打开launch.json。您必须手动更改“program”下的可执行文件名。
接下来，您应该验证是否启用了断点。有些读者说需要这样做。一些机器是默认启用它。🤷‍♂️
文件-&amp;gt;首选项-&amp;gt;设置（File -&amp;gt; Preferences -&amp;gt; Settings）</description>
    </item>
    
    <item>
      <title>Rust ? 语法糖 (译)</title>
      <link>/2019/02/27/rust-%E8%AF%AD%E6%B3%95%E7%B3%96-%E8%AF%91/</link>
      <pubDate>Wed, 27 Feb 2019 14:56:41 +0800</pubDate>
      
      <guid>/2019/02/27/rust-%E8%AF%AD%E6%B3%95%E7%B3%96-%E8%AF%91/</guid>
      <description>宏 std::try macro_rules! try { ( $ expr : expr ) =&amp;gt; { ... }; ( $ expr : expr , ) =&amp;gt; { ... }; }  用于减少样板代码，以匹配Result以及转换下游错误的帮助宏。
增加?运算符，以替换try!。简化。
try!与给定Result匹配。对 Ok 变量，表达式为包装的值。
如果是 Err 变量，则检索内部错误。try!！然后使用 From 执行转换。这提供了专用错误和更通用错误之间的自动转换。然后立即返回错误。
因为提前返回，try!只能在返回Result的函数中使用。
Examples use std::io; use std::fs::File; use std::io::prelude::*; enum MyError { FileWriteError } impl From&amp;lt;io::Error&amp;gt; for MyError { fn from(e: io::Error) -&amp;gt; MyError { MyError::FileWriteError } } // 快速返回错误的首选方法 fn write_to_file_question() -&amp;gt; Result&amp;lt;(), MyError&amp;gt; { let mut file = File::create(&amp;#34;my_best_friends.</description>
    </item>
    
    <item>
      <title>Rust E0008 - ref 的重要性（译）</title>
      <link>/2019/02/25/rust-e0008-ref-%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7%E8%AF%91/</link>
      <pubDate>Mon, 25 Feb 2019 14:17:47 +0800</pubDate>
      
      <guid>/2019/02/25/rust-e0008-ref-%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7%E8%AF%91/</guid>
      <description>官方原文  E0008，(无法逾越的 ref 关键字) 匹配条件语句中的绑定名称，在模式控制中保留了其类型。因此，若在一个模式中，这一名称是通过移动进行绑定的，那它也会被移动到在模式代码中的参考变量位置。这样做的话，会阻止原名称在匹配语句的主体中可用。
考虑以下:
match Some(&amp;#34;hi&amp;#34;.to_string()) { Some(s) if s.len() == 0 =&amp;gt; {}, // 使用 s.  _ =&amp;gt; {}, }  变量 s 具有 String 类型，并且它在 匹配语句 中的用法是 String 类型的变量。 使用s变量的代码，在匹配语句主体的分离作用域内，执行有效，因此该值被移动到此匿名作用域内，结果就是在匹配语句的主体中变得不可用。
上面的问题，可以通过使用 ref 关键字来解决。
match Some(&amp;#34;hi&amp;#34;.to_string()) { Some(ref s) if s.len() == 0 =&amp;gt; {}, _ =&amp;gt; {}, }  虽然，这个例子似乎不怎么厉害且易于解决，但当它遇到消耗该值的函数时,问题就变得清晰了:
struct A{} impl A { fn consume(self) -&amp;gt; usize { 0 } } fn main() { let a = Some(A{}); match a { Some(y) if y.</description>
    </item>
    
    <item>
      <title>Doc Templite 模版工具</title>
      <link>/2019/02/20/doc-templite-%E6%A8%A1%E7%89%88%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Wed, 20 Feb 2019 12:55:13 +0800</pubDate>
      
      <guid>/2019/02/20/doc-templite-%E6%A8%A1%E7%89%88%E5%B7%A5%E5%85%B7/</guid>
      <description>回顾初始化脚本 第八步：
 8. 对 项目目录 执行 [doc-templite] - js 模版工具  doc-templite 为了解决，能一次性替换，文件中相应部分的内容，doc-templite 诞生了。 吸取了doctoc,templite,toml&amp;hellip;相关工具/库的精华，综合而成。
readme doc-templite   为 多个 md 文件 准备的模版工具
 当我们使用 多个文件或者多项目的readme.md时,样式可以帮助我们说出或显示某些东西,比如 md 表格,但下次我想要一个 md 网络链接. 太麻烦了! 去修改更改这些文件,所以doc-templite也许有帮助.
 安装 npm i -g doc-templite 示例 1. 修改readme.md👇 必须有 doc-templite 标签 &amp;lt;!-- doc-templite START --&amp;gt; &amp;lt;!-- doc-templite-id = &amp;#39;readme&amp;#39; --&amp;gt; &amp;lt;!-- name = &amp;#39;yobrave&amp;#39; age = 18 --&amp;gt; &amp;lt;!-- doc-templite END --&amp;gt;  注意:在 START-END 块中,我们使用的是 toml 和 &amp;lt;!</description>
    </item>
    
    <item>
      <title>Mrm 定制你的默认文件 Js工具</title>
      <link>/2019/02/17/mrm-%E5%AE%9A%E5%88%B6%E4%BD%A0%E7%9A%84%E9%BB%98%E8%AE%A4%E6%96%87%E4%BB%B6-js%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Sun, 17 Feb 2019 14:11:05 +0800</pubDate>
      
      <guid>/2019/02/17/mrm-%E5%AE%9A%E5%88%B6%E4%BD%A0%E7%9A%84%E9%BB%98%E8%AE%A4%E6%96%87%E4%BB%B6-js%E5%B7%A5%E5%85%B7/</guid>
      <description>入门 之前简单介绍了下 mrm
，当然mrm 项目的 Github 页面也很适合入门
 或是看看其 readme 的中文翻译
 书接上回 init.sh 脚本中，有关 mrm 命令启动 的编写
 4. 启用 [mrm] ，一个 gitignore，readme&amp;hellip; 快速初始化的 js 工具。(运用之前获得的信息+参数)  echo &amp;#34;\n4. mrm ***&amp;#34; mrm readme --config:repos $2 --config:name $1 --config:commit $COMMIT --config:date $DATE mrm gitignore Readme 的 配置文件（mrm readme &amp;hellip;)  请查看入门，了解些知识，再继续
  ~/dotfiles/mrm/readme/index.js  大体思路，
 获得 命令参数&#39;name&#39;,&#39;repos&#39;,&#39;date&#39;,&#39;commit&#39; 分析repos是ex吗（这样此项目的模版就会是两个主分支：翻译/解释） 添加各自分支的内容，填充上doc-templite工具的标记与参数。（*doc-templite*工具下回分解) 最后当然是，感谢与免责，以及一大串 md 链接格式简写。  const {lines} = require(&amp;#39;mrm-core&amp;#39;); function task(config) { const values = config.</description>
    </item>
    
    <item>
      <title>终端命令行篇-起始</title>
      <link>/2019/02/05/%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87-%E8%B5%B7%E5%A7%8B/</link>
      <pubDate>Tue, 05 Feb 2019 15:27:19 +0800</pubDate>
      
      <guid>/2019/02/05/%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87-%E8%B5%B7%E5%A7%8B/</guid>
      <description>终端命令脚本 为了，不一次次重复。集合工作流程为命令，是必要的。 我所有的*-zh 项目:中文翻译 和 *-explain:解释都是从这里开始的。
开始中文翻译(zh) $ init https://github.com/worrydream/Tangle.git es  开始解释项目(explain) $ init https://github.com/worrydream/Tangle.git ex  总览脚本 此终端脚本思路  1. 获取 添加了 zh/explain 的 项目名称，并建立此名称目录 2. 初始化 git 存储库，放入目录 source 中(此处存在本地/远程的分支，由第三参数决定) 3. 得到 source 中，存储库的最新 git 信息(日期，commit 码) 4. 启用 mrm ，一个 gitignore，readme&amp;hellip; 快速初始化的 js 工具。(运用之前获得的信息+参数) 5. 找出 source 中的所有 md 文件，并添加到上一目录层.mds-list文件(使用 find) 6. 复制本地脚本sync-en.sh到项目目录 7. 对 source 目录 执行[translate-mds]- js 翻译工具 8. 对 项目目录 执行 doc-templite - js 模版工具 9.</description>
    </item>
    
    <item>
      <title>&gt;&gt;&gt; Rust 官方学习索引(译&#43;Copy)</title>
      <link>/2018/12/28/rust-%E5%AE%98%E6%96%B9%E5%AD%A6%E4%B9%A0%E7%B4%A2%E5%BC%95%E8%AF%91-copy/</link>
      <pubDate>Fri, 28 Dec 2018 20:13:43 +0800</pubDate>
      
      <guid>/2018/12/28/rust-%E5%AE%98%E6%96%B9%E5%AD%A6%E4%B9%A0%E7%B4%A2%E5%BC%95%E8%AF%91-copy/</guid>
      <description>.blog-post  h2:first-child {display:none}   ❤️ 学习 Rust    开启您的 Rust 之旅   《Rust 程序设计语言》被亲切地称为“圣经”。本书从基本原则出发，给出了 Rust 语言的概览。您将在阅读本书的过程中构建几个项目，读完本书后，您就能扎实地掌握 Rust 语言。
阅读本书！（中文）   此外，Rustlings 课程会指导您下载并设置 Rust 工具链，在命令行中教您阅读和编写 Rust 代码的语法基础。它可以运行在您自己的环境中，是《通过例子学 Rust》之外的另一种选择。
学习 Rustlings 课程！   如果您不喜欢阅读大量的文档来学习语言，那么《通过例子学 Rust》就能涵盖您要学的知识。虽然本书花了很多篇幅来解释代码，但它展示的代码很丰富，并且尽量减少了文字解释。它还包括很多练习！
阅读《通过例子学 Rust》！（中文）       与 Rust 共同成长    阅读核心文档 以下所有文档都可以用 rustup doc 命令在本地阅读，它会在您的浏览器中离线打开这些资源！
标准库 详尽的 Rust 标准库 API 手册。  版本指南 Rust 版本指南。  Cargo 之书（中文） Rust 的包管理器和构建系统。  rustdoc 之书(中文) 学习如何为您的 crate 编写完美的文档。  rustc 之书(中文) 熟悉 Rust 编译器中可用的选项。  编译错误索引表 深入解释了您可能会遇到的编译错误。     在应用领域中点亮您的技能树 命令行之书 (中文)  学习如何用 Rust 构建高效的命令行应用。  WebAssembly 之书(中文)  通过 WebAssembly 用 Rust 构建浏览器原生的库。  嵌入式之书  熟练掌握用 Rust 编写微控制器和其它嵌入式系统程序。</description>
    </item>
    
    <item>
      <title>Projects me</title>
      <link>/about/</link>
      <pubDate>Tue, 14 Apr 2015 22:17:00 +0000</pubDate>
      
      <guid>/about/</guid>
      <description>项目（翻译与工具） Oh my ,第一个例子(很久很久以前)  example w3 blog template  Vue  getnoabsbooks read book no-abs china liaoAliao jsonstore axios sample
 vue-scrollto docs translate scroll
  React  react-from-zero examples transalte React hacknews example  Js  translate-mds 所有 md 翻译项目的起点工具 translate tool doc-templite md 文件的模版工具 templite tool
 side-content sider
 lerna-website lerna translate
 codelabs 出品的:first pwa pwa example transalte
  Rust  gentle-intro book translate rust-ffi-omnibus book translate rustwasm-book book translate wasm-bindgen book translate Cargo Book book translate</description>
    </item>
    
  </channel>
</rss>