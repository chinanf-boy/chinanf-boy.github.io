<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rust on Code &gt; Explain &gt; Transalte 的人</title>
    <link>/categories/rust/</link>
    <description>Recent content in Rust on Code &gt; Explain &gt; Transalte 的人</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Thu, 12 Sep 2019 10:57:01 +0800</lastBuildDate>
    
	<atom:link href="/categories/rust/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Rust周报 303(译)</title>
      <link>/2019/09/12/rust%E5%91%A8%E6%8A%A5-303%E8%AF%91/</link>
      <pubDate>Thu, 12 Sep 2019 10:57:01 +0800</pubDate>
      
      <guid>/2019/09/12/rust%E5%91%A8%E6%8A%A5-303%E8%AF%91/</guid>
      <description>a { color: #804d0f;}  本周的螃蟹行情
日期：2019-09-10
原文：本周 Rust(螃蟹) 303
你好，欢迎再来一期*本周的螃蟹行情*！Rust是一种追求三位一体的系统语言：安全性、并发性和速度。这是它的进展和社区的每周总结。有什么要说的吗？推特@ThisWeekInRust或向我们发送请求。 想参与吗？我们热爱贡献.
*这本周的螃蟹行情*是在在 Github 上公开的。如果你在本周的问题中发现任何错误，请提交 PR。
Rust 社区的更新 新闻和博客文章  Rust 如何优化 async/await II：程序分析。 在 ESP32 上的 Rust。 Linux.Fe2O3：一个 Rust 病毒。 改善一个箱子的编译时间。 hyper 0.13 alpha 支持 async/await。 Rust 编写操作系统：2019 年 8 月更新。 大型组织中的 Rust - 会议记录。 Futures 并发。  本周的箱子 本周的箱子是viu，终端图像查看器。
谢谢威利卡普勒建议！
提交下周的建议和投票！
呼吁参与 总是想为开源项目做出贡献，但不知道从哪里开始？每周我们都会强调一些来自 Rust 社区的任务，供您挑选并开始！
其中一些任务也可能会有指导者，请访问任务页，了解更多信息。
 请求帮助，为 GCC 实现一个独立的 Rust 前端。 Rusoto：寻找维护者。  如果你是一个 Rust 项目的所有者，并且正在寻找贡献者，请在这里提交任务。</description>
    </item>
    
    <item>
      <title>关于Rust项目肥大的思考(译)</title>
      <link>/2019/09/05/%E5%85%B3%E4%BA%8Erust%E9%A1%B9%E7%9B%AE%E8%82%A5%E5%A4%A7%E7%9A%84%E6%80%9D%E8%80%83%E8%AF%91/</link>
      <pubDate>Thu, 05 Sep 2019 10:52:40 +0800</pubDate>
      
      <guid>/2019/09/05/%E5%85%B3%E4%BA%8Erust%E9%A1%B9%E7%9B%AE%E8%82%A5%E5%A4%A7%E7%9A%84%E6%80%9D%E8%80%83%E8%AF%91/</guid>
      <description>关于 Rust 项目大小膨胀的思考 2019 年 8 月 21 日 ❤️ 原文
我要接受了一个PR，这将加快了 druid 的编译时间，约 3 倍，而其可执行文件大小则变为近乎 2 倍。在这种情况下，我认为需要权衡一下（没有国际化，这个 GUI 工具包严格上来说，是一个玩具），但膨胀使我不高兴，我认为有改善 Rust 生态系统的空间。
我们应该关心吗？ 对我来说，rust 中的膨胀主要是关于编译时间和可执行文件大小。关于编译时间的十大挑战，其中含有 Rust 的开发经验，但在某种程度上，它是由开发人员控制的，特别是选择那些臃肿的箱子。
膨胀是软件中的一个常见问题，但有一些事情使它在 Rust ，会是一个更大挑战：
 Cargo 很容易就够到箱子。 泛型，特别是单态化。 不支持动态库。  对编译时间影响的一个更微妙的方法是，使用像 rls 这样的工具。
这会因人而异，但我个人很在乎。我希望 XI 编辑器的核心是轻量级，特别是当我们能够考虑 UI 之类的问题时。但是，现在发布的二进制文件是 5.9M（发布版本，Windows，不包括语法着色，而这是额外的 2.1M）。为了减少膨胀，我在 Rust 生态系统中做了很多其他的事情，在这篇文章中，我会吹嘘一下。
功能 vs 膨胀 当然，我之所以考虑在 druid 上，进行如此大的编译时间跳跃，是因为我想要国际化，这是一个重要而复杂的特性。正确地进行这项工作，需要相当多的逻辑，其中包括区域匹配、Unicode 和自然语言处理（如复数规则）的。我没有*期待过*会有一个小箱子，能帮我做到这些。
最近我们看到的一个类似的权衡是，pulldown-cmark 关于Unicase dep 增加了 50K二进制文件大小。在这种情况下，CommonMark 规范要求 Unicode 大小写折叠，如果没有这个，它将不再符合标准。我理解这种不去匹配的诱惑，但我认为，不符合规范的版本是一件坏事，尤其是对世界上大多数母语不是英语的人不友好。
因此，重要的是，不要将精益求精与缺乏重要特性混为一谈。真正要说的是，膨胀是不必要的资源消耗，超出了满足需求所必需的范围。Unicode 和国际化是一个特别有争议的问题，这不仅是因为它们实际上，需要代码和数据才能正确处理，而且还因为它们有很大的膨胀量。
作&amp;rsquo;廋子&amp;rsquo;的基础箱子 我将对“基础”箱子有更高的标准，这些箱子会给多数 Rust 应用所使用。*不*使用依赖关系会是一个膨胀关注点，或者根据需求和对膨胀的容忍度，将生态系统分割成不同的解决方案。</description>
    </item>
    
    <item>
      <title>Rust周报 302(译)</title>
      <link>/2019/09/04/rust%E5%91%A8%E6%8A%A5-302%E8%AF%91/</link>
      <pubDate>Wed, 04 Sep 2019 21:39:23 +0800</pubDate>
      
      <guid>/2019/09/04/rust%E5%91%A8%E6%8A%A5-302%E8%AF%91/</guid>
      <description>a { color: #804d0f;}  本周的螃蟹行情
日期：2019-09-03
原文：本周 Rust(螃蟹) 302
你好，欢迎再来一期*本周的螃蟹行情*！Rust是一种追求三位一体的系统语言：安全性、并发性和速度。这是它的进展和社区的每周总结。有什么要说的吗？推特@ThisWeekInRust或向我们发送请求。 想参与吗？我们热爱贡献.
*这本周的螃蟹行情*是在在 Github 上公开的。如果你在本周的问题中发现任何错误，请提交 PR。
Rust 社区的更新 新闻和博客文章  Rust Web 应用程序简介。 本月 Rust GameDev＃1 - 2019 年 8 月。 HHVM 正将其部分 OCaml 代码，重写为 Rust。 宣布 cargo-udeps。 宣布 structopt 0.3。 Rust 中的语义验证。 STM32 Blue Pill 上的低功率 NB-IoT，带有 Apache Mynewt 和嵌入式 Rust。  本周的箱子 本周的箱子是cargo-udeps，Cargo 子命令，用于查找未使用的依赖项。
谢谢克里斯托弗达勒姆建议！
提交下周的建议和投票！
呼吁参与 总是想为开源项目做出贡献，但不知道从哪里开始？每周我们都会强调一些来自 Rust 社区的任务，供您挑选并开始！
其中一些任务也可能会有指导者，请访问任务页，了解更多信息。
_没有针对 CFP 提出任何问题_。
如果你是一个 Rust 项目的所有者，并且正在寻找贡献者，请在这里提交任务。</description>
    </item>
    
    <item>
      <title>Rust周报 301(译)</title>
      <link>/2019/09/04/rust%E5%91%A8%E6%8A%A5-301%E8%AF%91/</link>
      <pubDate>Wed, 04 Sep 2019 14:07:11 +0800</pubDate>
      
      <guid>/2019/09/04/rust%E5%91%A8%E6%8A%A5-301%E8%AF%91/</guid>
      <description>a { color: #804d0f;}  本周的螃蟹行情
2019 年 8 月 27 日
原文：本周 Rust(螃蟹) 301
你好，欢迎再来一期*本周的螃蟹行情*！Rust是一种追求三位一体的系统语言：安全性、并发性和速度。这是它的进展和社区的每周总结。有什么要说的吗？推特@ThisWeekInRust或向我们发送请求。 想参与吗？我们热爱贡献.
*本周的螃蟹行情*是在在 Github 上公开的。如果你在本周的问题中发现任何错误，请提交 PR.
来自 Rust 社区的更新 新闻和博客文章  小 Rust 结构，应通过复制或借用传递？ 关于 Rust bloat 的思考. Rust GUI 生态系统概述. c2rust 简介. Rust 中的异步堆栈跟踪. 小规模科学计算的案例研究 - Polsim. Rust 中的内存管理：实体组件系统(ECS). 实际上使用 Crev，或者，信任软件依赖性的问题. 2019 年 COSCUP “一切尽在 Rust”回顾.  本周的箱子 本周的箱子是include_flate，include_bytes!/include_str的变体，会在编译时压缩，和运行时延迟解压。
多亏了威利·卡普勒提交了这个建议！
提交你下周的建议和投票！
呼吁参与 总是想为开源项目做出贡献，但不知道从哪里开始？每周我们都会强调一些来自 Rust 社区的任务，供您挑选并开始！
其中一些任务也可能会有指导者，请访问任务页，了解更多信息。
_没有针对 CFP 提出任何问题_。
如果你是一个 Rust 项目的所有者，并且正在寻找贡献者，请在这里提交任务。</description>
    </item>
    
    <item>
      <title>小的Rust结构类型,应使用复制还是借用传递?(译)</title>
      <link>/2019/09/02/%E5%B0%8F%E7%9A%84rust%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B%E5%BA%94%E4%BD%BF%E7%94%A8%E5%A4%8D%E5%88%B6%E8%BF%98%E6%98%AF%E5%80%9F%E7%94%A8%E4%BC%A0%E9%80%92%E8%AF%91/</link>
      <pubDate>Mon, 02 Sep 2019 10:11:45 +0800</pubDate>
      
      <guid>/2019/09/02/%E5%B0%8F%E7%9A%84rust%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B%E5%BA%94%E4%BD%BF%E7%94%A8%E5%A4%8D%E5%88%B6%E8%BF%98%E6%98%AF%E5%80%9F%E7%94%A8%E4%BC%A0%E9%80%92%E8%AF%91/</guid>
      <description>对于小的 Rust 结构类型，应使用复制（copy）还是借用(borrow)传递？ 2019 年 8 月 26 日 ❤️ 原文
像许多好故事一样，这个故事从一个简单的问题开始。对于小的 Rust 结构类型，应使用复制还是借用传递？例如：
struct Vector3 { x: f32, y: f32, z: f32 } fn dot_product_by_copy(a: Vector3, b: Vector3) -&amp;gt; float { a.x*b.x + a.y*b.y + a.z*b.z } fn dot_product_by_borrow(a: &amp;amp;Vector3, b: &amp;amp;Vector3) -&amp;gt; float { a.x*b.x + a.y*b.y + a.z*b.z }  就是这个简单的问题将我带向了长征之路，带有些惊人的曲折和发现。
为什么这个问题是重要的呢 这个问题的答案有两个原因：性能和人体工程学。
性能 通过复制传递就是说，我们要每个Vector3复制 12 个字节(3 个 f32 类型)。 若是通过 borrow 传递，那么每个Vector3就是一个 8 字节的指针（在 64 位上）。其实两者很接近，也许对性能来说无关紧要。</description>
    </item>
    
    <item>
      <title>如何用VSCode调试Rust(译)</title>
      <link>/2019/08/30/%E5%A6%82%E4%BD%95%E7%94%A8vscode%E8%B0%83%E8%AF%95rust%E8%AF%91/</link>
      <pubDate>Fri, 30 Aug 2019 11:13:52 +0800</pubDate>
      
      <guid>/2019/08/30/%E5%A6%82%E4%BD%95%E7%94%A8vscode%E8%B0%83%E8%AF%95rust%E8%AF%91/</guid>
      <description>如何用 Visual Studio Code 调试 Rust 🌟 2019-03-24 ❤️ 原文
我是 Visual Studio Code 编辑器的铁杆。不幸的是，它的 Rust 调试不 太能 开箱即用。
配置调试器并不困难。但有几个步骤。我已经看了好几遍了。我写这本指南是为了省下未来回想的脑力。
希望本指南对其他一些人也有用。
安装 Rust 和 VS Code 这应该不用多说了。
安装 Rust
安装 Visual Studio Code
安装 VS Code 扩展 您需要安装一个扩展。哪一个取决于你的平台。
C/C++（Windows）
codelldb（OS X/Linux）
还要继续安装Rust 扩展。
配置 VS Code 现在已经安装了工具，您需要配置 VS Code 启动属性。
单击“调试(Debug)”-&amp;gt;“添加配置(Add Configuration)”
如果您在 Windows 上，请选择C++ (Windows)
如果您使用的是 Mac 或 Linux，请选择LLDB: Custom Launch
这应该会创建并打开launch.json。您必须手动更改“program”下的可执行文件名。
接下来，您应该验证是否启用了断点。有些读者说需要这样做。一些机器是默认启用它。🤷‍♂️
文件-&amp;gt;首选项-&amp;gt;设置（File -&amp;gt; Preferences -&amp;gt; Settings）</description>
    </item>
    
    <item>
      <title>Rust ? 语法糖 (译)</title>
      <link>/2019/02/27/rust-%E8%AF%AD%E6%B3%95%E7%B3%96-%E8%AF%91/</link>
      <pubDate>Wed, 27 Feb 2019 14:56:41 +0800</pubDate>
      
      <guid>/2019/02/27/rust-%E8%AF%AD%E6%B3%95%E7%B3%96-%E8%AF%91/</guid>
      <description>宏 std::try macro_rules! try { ( $ expr : expr ) =&amp;gt; { ... }; ( $ expr : expr , ) =&amp;gt; { ... }; }  用于减少样板代码，以匹配Result以及转换下游错误的帮助宏。
增加?运算符，以替换try!。简化。
try!与给定Result匹配。对 Ok 变量，表达式为包装的值。
如果是 Err 变量，则检索内部错误。try!！然后使用 From 执行转换。这提供了专用错误和更通用错误之间的自动转换。然后立即返回错误。
因为提前返回，try!只能在返回Result的函数中使用。
Examples use std::io; use std::fs::File; use std::io::prelude::*; enum MyError { FileWriteError } impl From&amp;lt;io::Error&amp;gt; for MyError { fn from(e: io::Error) -&amp;gt; MyError { MyError::FileWriteError } } // 快速返回错误的首选方法 fn write_to_file_question() -&amp;gt; Result&amp;lt;(), MyError&amp;gt; { let mut file = File::create(&amp;#34;my_best_friends.</description>
    </item>
    
    <item>
      <title>Rust E0008 - ref 的重要性（译）</title>
      <link>/2019/02/25/rust-e0008-ref-%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7%E8%AF%91/</link>
      <pubDate>Mon, 25 Feb 2019 14:17:47 +0800</pubDate>
      
      <guid>/2019/02/25/rust-e0008-ref-%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7%E8%AF%91/</guid>
      <description>官方原文  E0008，(无法逾越的 ref 关键字) 匹配条件语句中的绑定名称，在模式控制中保留了其类型。因此，若在一个模式中，这一名称是通过移动进行绑定的，那它也会被移动到在模式代码中的参考变量位置。这样做的话，会阻止原名称在匹配语句的主体中可用。
考虑以下:
match Some(&amp;#34;hi&amp;#34;.to_string()) { Some(s) if s.len() == 0 =&amp;gt; {}, // 使用 s.  _ =&amp;gt; {}, }  变量 s 具有 String 类型，并且它在 匹配语句 中的用法是 String 类型的变量。 使用s变量的代码，在匹配语句主体的分离作用域内，执行有效，因此该值被移动到此匿名作用域内，结果就是在匹配语句的主体中变得不可用。
上面的问题，可以通过使用 ref 关键字来解决。
match Some(&amp;#34;hi&amp;#34;.to_string()) { Some(ref s) if s.len() == 0 =&amp;gt; {}, _ =&amp;gt; {}, }  虽然，这个例子似乎不怎么厉害且易于解决，但当它遇到消耗该值的函数时,问题就变得清晰了:
struct A{} impl A { fn consume(self) -&amp;gt; usize { 0 } } fn main() { let a = Some(A{}); match a { Some(y) if y.</description>
    </item>
    
    <item>
      <title>&gt;&gt;&gt; Rust 官方学习索引(译&#43;Copy)</title>
      <link>/2018/12/28/rust-%E5%AE%98%E6%96%B9%E5%AD%A6%E4%B9%A0%E7%B4%A2%E5%BC%95%E8%AF%91-copy/</link>
      <pubDate>Fri, 28 Dec 2018 20:13:43 +0800</pubDate>
      
      <guid>/2018/12/28/rust-%E5%AE%98%E6%96%B9%E5%AD%A6%E4%B9%A0%E7%B4%A2%E5%BC%95%E8%AF%91-copy/</guid>
      <description>.blog-post  h2:first-child {display:none}   ❤️ 学习 Rust    开启您的 Rust 之旅   《Rust 程序设计语言》被亲切地称为“圣经”。本书从基本原则出发，给出了 Rust 语言的概览。您将在阅读本书的过程中构建几个项目，读完本书后，您就能扎实地掌握 Rust 语言。
阅读本书！（中文）   此外，Rustlings 课程会指导您下载并设置 Rust 工具链，在命令行中教您阅读和编写 Rust 代码的语法基础。它可以运行在您自己的环境中，是《通过例子学 Rust》之外的另一种选择。
学习 Rustlings 课程！   如果您不喜欢阅读大量的文档来学习语言，那么《通过例子学 Rust》就能涵盖您要学的知识。虽然本书花了很多篇幅来解释代码，但它展示的代码很丰富，并且尽量减少了文字解释。它还包括很多练习！
阅读《通过例子学 Rust》！（中文）       与 Rust 共同成长    阅读核心文档 以下所有文档都可以用 rustup doc 命令在本地阅读，它会在您的浏览器中离线打开这些资源！
标准库 详尽的 Rust 标准库 API 手册。  版本指南 Rust 版本指南。  Cargo 之书（中文） Rust 的包管理器和构建系统。  rustdoc 之书(中文) 学习如何为您的 crate 编写完美的文档。  rustc 之书(中文) 熟悉 Rust 编译器中可用的选项。  编译错误索引表 深入解释了您可能会遇到的编译错误。     在应用领域中点亮您的技能树 命令行之书 (中文)  学习如何用 Rust 构建高效的命令行应用。  WebAssembly 之书(中文)  通过 WebAssembly 用 Rust 构建浏览器原生的库。  嵌入式之书  熟练掌握用 Rust 编写微控制器和其它嵌入式系统程序。</description>
    </item>
    
  </channel>
</rss>