<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rust on Code &gt; Explain &gt; Transalte 的人</title>
    <link>/categories/rust/</link>
    <description>Recent content in Rust on Code &gt; Explain &gt; Transalte 的人</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Wed, 27 Feb 2019 14:56:41 +0800</lastBuildDate>
    
	<atom:link href="/categories/rust/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Rust ? 语法糖 (译)</title>
      <link>/2019/02/27/rust-%E8%AF%AD%E6%B3%95%E7%B3%96-%E8%AF%91/</link>
      <pubDate>Wed, 27 Feb 2019 14:56:41 +0800</pubDate>
      
      <guid>/2019/02/27/rust-%E8%AF%AD%E6%B3%95%E7%B3%96-%E8%AF%91/</guid>
      <description>宏 std::try macro_rules! try { ( $ expr : expr ) =&amp;gt; { ... }; ( $ expr : expr , ) =&amp;gt; { ... }; }  用于减少样板代码，以匹配Result以及转换下游错误的帮助宏。
增加?运算符，以替换try!。简化。
try!与给定Result匹配。对 Ok 变量，表达式为包装的值。
如果是 Err 变量，则检索内部错误。try!！然后使用 From 执行转换。这提供了专用错误和更通用错误之间的自动转换。然后立即返回错误。
因为提前返回，try!只能在返回Result的函数中使用。
Examples use std::io; use std::fs::File; use std::io::prelude::*; enum MyError { FileWriteError } impl From&amp;lt;io::Error&amp;gt; for MyError { fn from(e: io::Error) -&amp;gt; MyError { MyError::FileWriteError } } // 快速返回错误的首选方法 fn write_to_file_question() -&amp;gt; Result&amp;lt;(), MyError&amp;gt; { let mut file = File::create(&amp;#34;my_best_friends.</description>
    </item>
    
    <item>
      <title>Rust E0008 - ref 的重要性（译）</title>
      <link>/2019/02/25/rust-e0008-ref-%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7%E8%AF%91/</link>
      <pubDate>Mon, 25 Feb 2019 14:17:47 +0800</pubDate>
      
      <guid>/2019/02/25/rust-e0008-ref-%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7%E8%AF%91/</guid>
      <description>官方原文  E0008，(无法逾越的 ref 关键字) 匹配条件语句中的绑定名称，在模式控制中保留了其类型。因此，若在一个模式中，这一名称是通过移动进行绑定的，那它也会被移动到在模式代码中的参考变量位置。这样做的话，会阻止原名称在匹配语句的主体中可用。
考虑以下:
match Some(&amp;#34;hi&amp;#34;.to_string()) { Some(s) if s.len() == 0 =&amp;gt; {}, // 使用 s.  _ =&amp;gt; {}, }  变量 s 具有 String 类型，并且它在 匹配语句 中的用法是 String 类型的变量。 使用s变量的代码，在匹配语句主体的分离作用域内，执行有效，因此该值被移动到此匿名作用域内，结果就是在匹配语句的主体中变得不可用。
上面的问题，可以通过使用 ref 关键字来解决。
match Some(&amp;#34;hi&amp;#34;.to_string()) { Some(ref s) if s.len() == 0 =&amp;gt; {}, _ =&amp;gt; {}, }  虽然，这个例子似乎不怎么厉害且易于解决，但当它遇到消耗该值的函数时,问题就变得清晰了:
struct A{} impl A { fn consume(self) -&amp;gt; usize { 0 } } fn main() { let a = Some(A{}); match a { Some(y) if y.</description>
    </item>
    
    <item>
      <title>&gt;&gt;&gt; Rust 官方学习索引(译&#43;Copy)</title>
      <link>/2018/12/28/rust-%E5%AE%98%E6%96%B9%E5%AD%A6%E4%B9%A0%E7%B4%A2%E5%BC%95%E8%AF%91-copy/</link>
      <pubDate>Fri, 28 Dec 2018 20:13:43 +0800</pubDate>
      
      <guid>/2018/12/28/rust-%E5%AE%98%E6%96%B9%E5%AD%A6%E4%B9%A0%E7%B4%A2%E5%BC%95%E8%AF%91-copy/</guid>
      <description>.blog-post  h2:first-child {display:none}   &amp;amp;gt 学习 Rust     Rust 从入门 到 **    让我们将 &amp;lt;&amp;lt;Rust 编程语言&amp;gt;&amp;gt;亲切地称为 “the book,” 它会从第一原理开始，给你描述该语言的一个整体。期间，它会教你构建一些项目, 到最后, 你会扎实地掌握了该语言
开始 the Book! （中文)  如果孜孜不倦地阅读几百页关于一种语言的文章，不太符合你的风格, 那 Rust By Example 可能会合适你。 这本书会用许多单词来讨论代码, 其中RBE(编程实例) 会展示出了一段代码, 和代码注释+描述，会保持尽量简洁。 它还包括练习!
来看看 Rust by example (中文)      Rust成长    领略核心文档 所有的这些文档都能通过 rustup doc 命令进行本地启用(相应的源码库), 这样就可以在浏览器上查看这些资源文档，而不需要网络!
标准库 Rust 标准库 APIs - 全面指南.  Cargo 书 （非官方中文） 一本关于 Rust’s 包管理器与构建系统的书.</description>
    </item>
    
  </channel>
</rss>