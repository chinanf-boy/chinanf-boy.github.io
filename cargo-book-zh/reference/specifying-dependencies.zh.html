<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>指定依赖项 - Rust Cargo 官书（非官方翻译)</title>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="Cargo ">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="shortcut icon" href="../favicon.png">
    <link rel="stylesheet" href="../css/variables.css">
    <link rel="stylesheet" href="../css/general.css">
    <link rel="stylesheet" href="../css/chrome.css">
    <link rel="stylesheet" href="../css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"
        rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="../highlight.css">
    <link rel="stylesheet" href="../tomorrow-night.css">
    <link rel="stylesheet" href="../ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    

    
</head>

<body class="light">
    <!-- Provide site root to javascript -->
    <script type="text/javascript">var path_to_root = "../";</script>

    <!-- Work around some values being stored in localStorage wrapped in quotes -->
    <script type="text/javascript">
        try {
            var theme = localStorage.getItem('mdbook-theme');
            var sidebar = localStorage.getItem('mdbook-sidebar');

            if (theme.startsWith('"') && theme.endsWith('"')) {
                localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
            }

            if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
            }
        } catch (e) { }
    </script>

    <!-- Set the theme before any content is loaded, prevents flash -->
    <script type="text/javascript">
        var theme;
        try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
        if (theme === null || theme === undefined) { theme = 'light'; }
        document.body.className = theme;
        document.querySelector('html').className = theme + ' js';
    </script>

    <!-- Hide / unhide sidebar before it is displayed -->
    <script type="text/javascript">
        var html = document.querySelector('html');
        var sidebar = 'hidden';
        if (document.body.clientWidth >= 1080) {
            try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
            sidebar = sidebar || 'visible';
        }
        html.classList.remove('sidebar-visible');
        html.classList.add("sidebar-" + sidebar);
    </script>

    <nav id="sidebar" class="sidebar" aria-label="Table of contents">
        <ol class="chapter"><li class="affix"><a href="../index.zh.html">介绍</a></li><li><a href="../getting-started/index.zh.html"><strong aria-hidden="true">1.</strong> 入门</a></li><li><ol class="section"><li><a href="../getting-started/installation.zh.html"><strong aria-hidden="true">1.1.</strong> 安装</a></li><li><a href="../getting-started/first-steps.zh.html"><strong aria-hidden="true">1.2.</strong> Cargo 的第一步</a></li></ol></li><li><a href="../guide/index.zh.html"><strong aria-hidden="true">2.</strong> Cargo 指南</a></li><li><ol class="section"><li><a href="../guide/why-cargo-exists.zh.html"><strong aria-hidden="true">2.1.</strong> 为什么 Cargo 存在</a></li><li><a href="../guide/creating-a-new-project.zh.html"><strong aria-hidden="true">2.2.</strong> 创建一个新包</a></li><li><a href="../guide/working-on-an-existing-project.zh.html"><strong aria-hidden="true">2.3.</strong> 处理现有包</a></li><li><a href="../guide/dependencies.zh.html"><strong aria-hidden="true">2.4.</strong> 依赖</a></li><li><a href="../guide/project-layout.zh.html"><strong aria-hidden="true">2.5.</strong> 包装布局</a></li><li><a href="../guide/cargo-toml-vs-cargo-lock.zh.html"><strong aria-hidden="true">2.6.</strong> Cargo.toml 与 Cargo.lock</a></li><li><a href="../guide/tests.zh.html"><strong aria-hidden="true">2.7.</strong> 测试</a></li><li><a href="../guide/continuous-integration.zh.html"><strong aria-hidden="true">2.8.</strong> 持续集成</a></li><li><a href="../guide/build-cache.zh.html"><strong aria-hidden="true">2.9.</strong> 构建缓存</a></li></ol></li><li><a href="../reference/index.zh.html"><strong aria-hidden="true">3.</strong> Cargo 参考</a></li><li><ol class="section"><li><a href="../reference/specifying-dependencies.zh.html" class="active"><strong aria-hidden="true">3.1.</strong> 指定依赖项</a></li><li><a href="../reference/manifest.zh.html"><strong aria-hidden="true">3.2.</strong> 清单格式</a></li><li><a href="../reference/config.zh.html"><strong aria-hidden="true">3.3.</strong> 组态</a></li><li><a href="../reference/environment-variables.zh.html"><strong aria-hidden="true">3.4.</strong> 环境变量</a></li><li><a href="../reference/build-scripts.zh.html"><strong aria-hidden="true">3.5.</strong> 构建脚本</a></li><li><a href="../reference/publishing.zh.html"><strong aria-hidden="true">3.6.</strong> 在 crates.io 上发布</a></li><li><a href="../reference/pkgid-spec.zh.html"><strong aria-hidden="true">3.7.</strong> 包 ID 规格</a></li><li><a href="../reference/source-replacement.zh.html"><strong aria-hidden="true">3.8.</strong> 来源更换</a></li><li><a href="../reference/external-tools.zh.html"><strong aria-hidden="true">3.9.</strong> 外部工具</a></li><li><a href="../reference/unstable.zh.html"><strong aria-hidden="true">3.10.</strong> 不稳定的功能</a></li></ol></li><li><a href="../faq.zh.html"><strong aria-hidden="true">4.</strong> 常问问题</a></li><li><a href="../appendix/glossary.zh.html"><strong aria-hidden="true">5.</strong> 附录:词汇表</a></li></ol>
    </nav>

    <div id="page-wrapper" class="page-wrapper">

        <div class="page">
            
            <div id="menu-bar" class="menu-bar">
                <div id="menu-bar-sticky-container">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                            aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <!-- START - Rust Cookbook customization -->
                        <button id="edit-button" class="icon-button" type="button" title="Fork and edit" aria-label="Fork and edit"
                            aria-haspopup="true" aria-expanded="false" aria-controls="edit">
                            <i class="fa fa-edit">Edit</i>
                        </button>
                        <!-- END - Rust Cookbook customization -->
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme"
                            aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                            aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Rust Cargo 官书（非官方翻译)</h1>
                    
                        <div class="right-buttons">
                            <a href="../print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

            
            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                        aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>
            

            <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
            <script type="text/javascript">
                document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                    link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                });
            </script>

            <!-- // START - Rust Cookbook customization -->
            <script>
                document.getElementById("edit-button").addEventListener("click", function () {
                    var editWindow = window.open("https://github.com/chinanf-boy/cargo-book-zh/edit/master/src/reference/specifying-dependencies.zh.md");
                });</script>
            <!-- // END - Rust Cookbook customization -->

            <div id="content" class="content">
                <main>
                    <a class="header" href="#specifying-dependencies" id="specifying-dependencies"><h2>Specifying Dependencies</h2></a>
<p>您的箱子可以依赖于其他库<a href="https://crates.io/">crates.io</a>,<code>git</code>本地文件系统上的存储库或子目录.您还可以临时覆盖依赖项的位置 - 例如,以便能够测试您在本地工作的依赖项中的错误修复.您可以为不同的平台和仅在开发期间使用的依赖项具有不同的依赖项.我们来看看如何做到这些.</p>
<a class="header" href="#specifying-dependencies-from-cratesio" id="specifying-dependencies-from-cratesio"><h3>Specifying dependencies from crates.io</h3></a>
<p>Cargo配置为查找依赖项<a href="https://crates.io/">crates.io</a>默认情况下.在这种情况下,只需要名称和版本字符串.在<a href="guide/index.html">Cargo指南</a>,我们指定了依赖<code>time</code>箱:</p>
<pre><code class="language-toml">[dependencies]
time = &quot;0.1.12&quot;
</code></pre>
<p>字符串<code>&quot;0.1.12&quot;</code>是一个<a href="https://github.com/steveklabnik/semver#requirements">semver</a>版本要求.由于此字符串中没有任何运算符,因此它的解释方式与我们指定的方式相同<code>&quot;^0.1.12&quot;</code>,这被称为插入符号要求.</p>
<a class="header" href="#caret-requirements" id="caret-requirements"><h3>Caret requirements</h3></a>
<p><strong>插入要求</strong>允许SemVer兼容更新指定版本.如果新版本号不修改major,minor,patch分组中最左边的非零数字,则允许更新.在这种情况下,如果我们跑了<code>cargo update -p time</code>,Cargo应该更新我们的版本<code>0.1.13</code>如果是最新的<code>0.1.z</code>发布,但不会更新我们<code>0.2.0</code>.相反,我们已将版本字符串指定为<code>^1.0</code>,Cargo应更新至<code>1.1</code>如果是最新的<code>1.y</code>释放,但不是<code>2.0</code>.版本<code>0.0.x</code>不被视为与任何其他版本兼容.</p>
<p>以下是一些插入符号要求的例子以及它们允许的版本:</p>
<pre><code class="language-notrust">^1.2.3 := &gt;=1.2.3 &lt;2.0.0
^1.2 := &gt;=1.2.0 &lt;2.0.0
^1 := &gt;=1.0.0 &lt;2.0.0
^0.2.3 := &gt;=0.2.3 &lt;0.3.0
^0.2 := &gt;= 0.2.0 &lt; 0.3.0
^0.0.3 := &gt;=0.0.3 &lt;0.0.4
^0.0 := &gt;=0.0.0 &lt;0.1.0
^0 := &gt;=0.0.0 &lt;1.0.0
</code></pre>
<p>此兼容性约定与SemVer在处理1.0.0之前的版本方面有所不同.虽然SemVer说在1.0.0之前没有兼容性,但Cargo认为<code>0.x.y</code>兼容<code>0.x.z</code>,哪里<code>y ≥ z</code>和<code>x &gt; 0</code>.</p>
<a class="header" href="#tilde-requirements" id="tilde-requirements"><h3>Tilde requirements</h3></a>
<p><strong>Tilde要求</strong>指定具有一定更新能力的最小版本.如果指定主要版本,次要版本和修补程序版本,或仅指定主要版本和次要版本,则仅允许修补程序级别更改.如果仅指定主要版本,则允许进行次要和补丁级别更改.</p>
<p><code>~1.2.3</code>是代字号要求的一个例子.</p>
<pre><code class="language-notrust">~1.2.3 := &gt;=1.2.3 &lt;1.3.0
~1.2 := &gt;=1.2.0 &lt;1.3.0
~1 := &gt;=1.0.0 &lt;2.0.0
</code></pre>
<a class="header" href="#wildcard-requirements" id="wildcard-requirements"><h3>Wildcard requirements</h3></a>
<p><strong>通配符要求</strong>允许任何通配符所在的版本.</p>
<p><code>*</code>,<code>1.*</code>和<code>1.2.*</code>是通配符要求的示例.</p>
<pre><code class="language-notrust">* := &gt;=0.0.0
1.* := &gt;=1.0.0 &lt;2.0.0
1.2.* := &gt;=1.2.0 &lt;1.3.0
</code></pre>
<a class="header" href="#inequality-requirements" id="inequality-requirements"><h3>Inequality requirements</h3></a>
<p><strong>不平等要求</strong>允许手动指定要依赖的版本范围或确切版本.</p>
<p>以下是不平等要求的一些示例:</p>
<pre><code class="language-notrust">&gt;= 1.2.0
&gt; 1
&lt; 2
= 1.2.3
</code></pre>
<a class="header" href="#multiple-requirements" id="multiple-requirements"><h3>Multiple requirements</h3></a>
<p>多个版本要求也可以用逗号分隔,例如<code>&gt;= 1.2, &lt; 1.5</code>.</p>
<a class="header" href="#specifying-dependencies-from-git-repositories" id="specifying-dependencies-from-git-repositories"><h3>Specifying dependencies from <code>git</code> repositories</h3></a>
<p>依赖于位于的图书馆<code>git</code>存储库,您需要指定的最小信息是存储库的位置<code>git</code>键:</p>
<pre><code class="language-toml">[dependencies]
rand = { git = &quot;https://github.com/rust-lang-nursery/rand&quot; }
</code></pre>
<p>Cargo将取得<code>git</code>然后在这个位置找到一个存储库<code>Cargo.toml</code>对于所请求的箱子里面的任何地方<code>git</code>存储库(不一定在根目录 - 例如,指定工作空间和设置的成员包名称<code>git</code>到包含工作区的存储库).</p>
<p>由于我们尚未指定任何其他信息,因此Cargo假定我们打算使用最新的提交<code>master</code>分支来构建我们的包.你可以结合使用<code>git</code>关键<code>rev</code>,<code>tag</code>, 要么<code>branch</code>用于指定其他内容的键.这是一个指定您希望在名为的分支上使用最新提交的示例<code>next</code>:</p>
<pre><code class="language-toml">[dependencies]
rand = { git = &quot;https://github.com/rust-lang-nursery/rand&quot;, branch = &quot;next&quot; }
</code></pre>
<a class="header" href="#specifying-path-dependencies" id="specifying-path-dependencies"><h3>Specifying path dependencies</h3></a>
<p>随着时间的推移,我们<code>hello_world</code>来自<a href="guide/index.html">导游</a>已大幅增长!它已经到了我们可能想分开一个单独的箱子供其他人使用的地步.为此,Cargo支持<strong>路径依赖</strong>通常是位于一个存储库中的子板条箱.让我们开始在我们的内部制作一个新的箱子<code>hello_world</code>包:</p>
<pre><code class="language-console"># inside of hello_world/
$ cargo new hello_utils
</code></pre>
<p>这将创建一个新文件夹<code>hello_utils</code>里面的一个<code>Cargo.toml</code>和<code>src</code>文件夹已准备好进行配置.为了告诉Cargo,请打开<code>hello_world/Cargo.toml</code>并添加<code>hello_utils</code>你的依赖:</p>
<pre><code class="language-toml">[dependencies]
hello_utils = { path = &quot;hello_utils&quot; }
</code></pre>
<p>这告诉Cargo我们依赖于一个叫做的箱子<code>hello_utils</code>这是发现于<code>hello_utils</code>文件夹(相对于<code>Cargo.toml</code>它是写的).</p>
<p>就是这样!下一个<code>cargo build</code>将自动构建<code>hello_utils</code>以及它自己的所有依赖项,其他人也可以开始使用它.但是,不允许使用仅使用路径指定的依赖项的包<a href="https://crates.io/">crates.io</a>.如果我们想发布我们的<code>hello_world</code>箱子,我们需要发布一个版本<code>hello_utils</code>至<a href="https://crates.io">crates.io</a>并在依赖项行中指定其版本:</p>
<pre><code class="language-toml">[dependencies]
hello_utils = { path = &quot;hello_utils&quot;, version = &quot;0.1.0&quot; }
</code></pre>
<a class="header" href="#overriding-dependencies" id="overriding-dependencies"><h3>Overriding dependencies</h3></a>
<p>Cargo中有许多方法可以支持覆盖依赖关系以及控制依赖关系图.但是,这些选项通常仅在工作区级别可用,并且不通过依赖项传播.换句话说,”应用程序”具有覆盖依赖关系的能力,但”库”却没有.</p>
<p>通过许多场景可以产生覆盖依赖性或以其他方式改变某些依赖性的愿望.然而,他们中的大多数人归结为在将箱子发布到crates.io之前使用箱子的能力.例如:</p>
<ul>
<li>您正在处理的crate也用于您正在处理的更大的应用程序中,并且您希望测试较大应用程序内的库的错误修复.</li>
<li>您不工作的上游包有一个新功能或其git存储库的主分支上的错误修复,您要测试它.</li>
<li>您即将发布新版本的主要版本,但您希望在整个软件包中进行集成测试,以确保新的主要版本能够正常运行.</li>
<li>您已经为上游的软件包提交了一个针对您找到的错误的修复程序,但是您希望立即让您的应用程序启动,具体取决于修复程序包的固定版本,以避免阻止错误修复程序合并.</li>
</ul>
<p>这些场景目前都是通过解决的<a href="reference/manifest.html#the-patch-section"><code>[patch]</code>显示部分</a>.从历史上看,其中一些方案已经解决了<a href="reference/manifest.html#the-replace-section">该<code>[replace]</code>部分</a>,但我们会记录下来<code>[patch]</code>这里的部分.</p>
<a class="header" href="#testing-a-bugfix" id="testing-a-bugfix"><h3>Testing a bugfix</h3></a>
<p>假设你正在使用[<code>uuid</code>箱]但是当你正在研究它时,你会发现一个错误.但是,你很有进取心,所以你决定尝试修复这个bug!最初你的清单看起来像:</p>
<pre><code class="language-toml">[package]
name = &quot;my-library&quot;
version = &quot;0.1.0&quot;
authors = [&quot;...&quot;]

[dependencies]
uuid = &quot;1.0&quot;
</code></pre>
<p>我们要做的第一件事是克隆<a href="https://github.com/rust-lang-nursery/uuid"><code>uuid</code>知识库</a>本地途经:</p>
<pre><code class="language-console">$ git clone https://github.com/rust-lang-nursery/uuid
</code></pre>
<p>接下来我们将编辑清单<code>my-library</code>包含装有:</p>
<pre><code class="language-toml">[patch.crates-io]
uuid = { path = &quot;../path/to/uuid&quot; }
</code></pre>
<p>在这里,我们宣布我们是<em>修补</em>来源<code>crates-io</code>有一个新的依赖.这将有效地添加本地签出版本<code>uuid</code>到本地包的crates.io注册表.</p>
<p>接下来我们需要确保我们的锁文件已更新为使用此新版本<code>uuid</code>所以我们的包使用本地签出的副本而不是crates.io中的副本.方式<code>[patch]</code>工作是它将加载依赖<code>../path/to/uuid</code>然后每当crates.io查询版本的时候<code>uuid</code>它会<em>也</em>返回本地版本.</p>
<p>这意味着本地结帐的版本号很重要,会影响是否使用该补丁.我们的清单宣布<code>uuid = &quot;1.0&quot;</code>这意味着我们只会解决<code>&gt;= 1.0.0, &lt; 2.0.0</code>和Cargo的贪婪分辨率算法也意味着我们将解析到该范围内的最大版本.通常情况下这并不重要,因为git存储库的版本已经更大或与crates.io上发布的最大版本相匹配,但重要的是要记住这一点!</p>
<p>无论如何,通常您现在需要做的就是:</p>
<pre><code class="language-console">$ cargo build
   Compiling uuid v1.0.0 (.../uuid)
   Compiling my-library v0.1.0 (.../my-library)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
</code></pre>
<p>就是这样!您现在正在使用本地版本构建<code>uuid</code>(注意构建输出中括号中的路径).如果您没有看到构建本地路径版本,那么您可能需要运行<code>cargo update -p uuid --precise $version</code>哪里<code>$version</code>是本地检出的副本的版本<code>uuid</code>.</p>
<p>一旦你修复了你最初发现的错误,你要做的下一件事就是将其作为拉取请求提交给<code>uuid</code>箱子本身.一旦你完成了这个,你也可以更新<code>[patch]</code>部分.里面的内容<code>[patch]</code>就像是<code>[dependencies]</code>部分,所以一旦你的拉动请求合并,你可以改变你的<code>path</code>依赖:</p>
<pre><code class="language-toml">[patch.crates-io]
uuid = { git = 'https://github.com/rust-lang-nursery/uuid' }
</code></pre>
<a class="header" href="#working-with-an-unpublished-minor-version" id="working-with-an-unpublished-minor-version"><h3>Working with an unpublished minor version</h3></a>
<p>现在让我们从错误修复到添加功能稍微改变一下.在努力的同时<code>my-library</code>你发现需要一个全新的功能<code>uuid</code>箱.您已实现此功能,并在上面本地测试<code>[patch]</code>,并提交了拉取请求.让我们来看看在实际发布之前你如何继续使用和测试它.</p>
<p>我们也说当前版本的<code>uuid</code>在crates.io上<code>1.0.0</code>,但从那时起,git存储库的主分支已更新为<code>1.0.1</code>.此分支包含您之前提交的新功能.要使用此存储库,我们将编辑我们的<code>Cargo.toml</code>看起来像</p>
<pre><code class="language-toml">[package]
name = &quot;my-library&quot;
version = &quot;0.1.0&quot;
authors = [&quot;...&quot;]

[dependencies]
uuid = &quot;1.0.1&quot;

[patch.crates-io]
uuid = { git = 'https://github.com/rust-lang-nursery/uuid' }
</code></pre>
<p>注意我们对本地的依赖<code>uuid</code>已更新为<code>1.0.1</code>因为这是我们在箱子出版后实际需要的东西.但是,这个版本在crates.io上不存在,所以我们提供了它<code>[patch]</code>清单的一部分.</p>
<p>现在,当我们的库被构建时,它将被取出<code>uuid</code>从git存储库并解析到存储库中的1.0.1而不是尝试从crates.io下载版本.一旦1.0.1发布在crates.io上<code>[patch]</code>部分可以删除.</p>
<p>值得注意的是<code>[patch]</code>适用<em>及物动词</em>.假设您使用<code>my-library</code>在更大的包中,例如:</p>
<pre><code class="language-toml">[package]
name = &quot;my-binary&quot;
version = &quot;0.1.0&quot;
authors = [&quot;...&quot;]

[dependencies]
my-library = { git = 'https://example.com/git/my-library' }
uuid = &quot;1.0&quot;

[patch.crates-io]
uuid = { git = 'https://github.com/rust-lang-nursery/uuid' }
</code></pre>
<p>记住这一点<code>[patch]</code>适用<em>及物动词</em>但只能在<em>顶层</em>所以我们的消费者<code>my-library</code>不得不重复<code>[patch]</code>部分如有必要.不过,在这里,新的<code>uuid</code>箱子适用于<em>都</em>我们对...的依赖<code>uuid</code>和<code>my-library -&gt; uuid</code>依赖.该<code>uuid</code>crate将被解析为整个crate图表1.0.1的一个版本,并且它将从git存储库中提取.</p>
<a class="header" href="#overriding-repository-url" id="overriding-repository-url"><h4>Overriding repository URL</h4></a>
<p>如果未加载要覆盖的依赖项<code>crates.io</code>,你将不得不改变一下你的使用方式<code>[patch]</code>:</p>
<pre><code class="language-toml">[patch.&quot;https://github.com/your/repository&quot;]
my-library = { path = &quot;../my-library/path&quot; }
</code></pre>
<p>就是这样!</p>
<a class="header" href="#prepublishing-a-breaking-change" id="prepublishing-a-breaking-change"><h3>Prepublishing a breaking change</h3></a>
<p>作为最后一个场景,让我们来看看使用一个新的主要版本的箱子,通常伴随着重大变化.坚持我们以前的板条箱,这意味着我们将创建2.0.0版本<code>uuid</code>箱.在我们提交了所有上游更改后,我们可以更新我们的清单<code>my-library</code>看起来像:</p>
<pre><code class="language-toml">[dependencies]
uuid = &quot;2.0&quot;

[patch.crates-io]
uuid = { git = &quot;https://github.com/rust-lang-nursery/uuid&quot;, branch = &quot;2.0.0&quot; }
</code></pre>
<p>就是这样!与前面的示例一样,2.0.0版本实际上并不存在于crates.io上,但我们仍然可以通过使用<code>[patch]</code>部分.作为一个思考练习让我们再看看<code>my-binary</code>从上面再次表现出来:</p>
<pre><code class="language-toml">[package]
name = &quot;my-binary&quot;
version = &quot;0.1.0&quot;
authors = [&quot;...&quot;]

[dependencies]
my-library = { git = 'https://example.com/git/my-library' }
uuid = &quot;1.0&quot;

[patch.crates-io]
uuid = { git = 'https://github.com/rust-lang-nursery/uuid', branch = '2.0.0' }
</code></pre>
<p>请注意,这实际上将解析为两个版本的<code>uuid</code>箱.该<code>my-binary</code>箱子将继续使用1.x.y系列<code>uuid</code>箱子但是<code>my-library</code>crate将使用2.0.0版本<code>uuid</code>.这将允许您通过依赖关系图逐步推出对包的更改,而无需一次性更新所有内容.</p>
<a class="header" href="#overriding-with-local-dependencies" id="overriding-with-local-dependencies"><h3>Overriding with local dependencies</h3></a>
<p>有时你只是暂时在箱子上工作而你不想修改<code>Cargo.toml</code>喜欢的<code>[patch]</code>以上部分.对于这个用例,Cargo提供了更为有限的覆盖版本<strong>路径覆盖</strong>.</p>
<p>路径覆盖是通过指定的<code>.cargo/config</code>代替<code>Cargo.toml</code>,你可以找到<a href="reference/config.html">有关此配置的更多文档</a>.代替<code>.cargo/config</code>你将指定一个名为的密钥<code>paths</code>:</p>
<pre><code class="language-toml">paths = [&quot;/path/to/uuid&quot;]
</code></pre>
<p>该数组应填充包含a的目录<code>Cargo.toml</code>.在这种情况下,我们只是添加<code>uuid</code>,所以它将是唯一一个被覆盖的人.此路径可以是包含该路径的绝对路径或相对路径<code>.cargo</code>夹.</p>
<p>路径覆盖比限制更严格<code>[patch]</code>但是,部分不能改变依赖图的结构.当使用路径替换时,前一组依赖项必须完全匹配新的<code>Cargo.toml</code>规格.例如,这意味着路径覆盖不能用于测试向条件箱添加依赖项<code>[patch]</code>必须在那种情况下使用.因此,路径覆盖的使用通常与快速错误修复隔离,而不是更大的更改.</p>
<p>注意:使用本地配置覆盖路径仅适用于已发布到的包<a href="https://crates.io/">crates.io</a>.您无法使用此功能告诉Cargo如何查找本地未发布的板条箱.</p>
<a class="header" href="#platform-specific-dependencies" id="platform-specific-dependencies"><h3>Platform specific dependencies</h3></a>
<p>特定于平台的依赖项采用相同的格式,但在a下列出<code>target</code>部分.通常像锈一样<code>#[cfg]</code>语法将用于定义这些部分:</p>
<pre><code class="language-toml">[target.'cfg(windows)'.dependencies]
winhttp = &quot;0.4.0&quot;

[target.'cfg(unix)'.dependencies]
openssl = &quot;1.0.1&quot;

[target.'cfg(target_arch = &quot;x86&quot;)'.dependencies]
native = { path = &quot;native/i686&quot; }

[target.'cfg(target_arch = &quot;x86_64&quot;)'.dependencies]
native = { path = &quot;native/x86_64&quot; }
</code></pre>
<p>与Rust一样,这里的语法支持<code>not</code>,<code>any</code>,和<code>all</code>运算符组合各种cfg名称/值对.请注意<code>cfg</code>语法仅在Cargo 0.9.0(Rust 1.8.0)之后可用.</p>
<p>此外<code>#[cfg]</code>语法,Cargo还支持列出依赖关系适用的完整目标:</p>
<pre><code class="language-toml">[target.x86_64-pc-windows-gnu.dependencies]
winhttp = &quot;0.4.0&quot;

[target.i686-unknown-linux-gnu.dependencies]
openssl = &quot;1.0.1&quot;
</code></pre>
<p>如果您使用的是自定义目标规范,请引用完整路径和文件名:</p>
<pre><code class="language-toml">[target.&quot;x86_64/windows.json&quot;.dependencies]
winhttp = &quot;0.4.0&quot;

[target.&quot;i686/linux.json&quot;.dependencies]
openssl = &quot;1.0.1&quot;
native = { path = &quot;native/i686&quot; }

[target.&quot;x86_64/linux.json&quot;.dependencies]
openssl = &quot;1.0.1&quot;
native = { path = &quot;native/x86_64&quot; }
</code></pre>
<a class="header" href="#development-dependencies" id="development-dependencies"><h3>Development dependencies</h3></a>
<p>你可以添加一个<code>[dev-dependencies]</code>你的部分<code>Cargo.toml</code>其格式相当于<code>[dependencies]</code>:</p>
<pre><code class="language-toml">[dev-dependencies]
tempdir = &quot;0.3&quot;
</code></pre>
<p>编译用于构建的包时不使用Dev依赖性,但用于编译测试,示例和基准.</p>
<p>这些依赖关系是<em>不</em>传播到依赖于此包的其他包.</p>
<p>您还可以使用具有特定于目标的开发依赖项<code>dev-dependencies</code>在目标节标题而不是<code>dependencies</code>.例如:</p>
<pre><code class="language-toml">[target.'cfg(unix)'.dev-dependencies]
mio = &quot;0.0.1&quot;
</code></pre>
<a class="header" href="#build-dependencies" id="build-dependencies"><h3>Build dependencies</h3></a>
<p>您可以依赖其他基于Cargo的板条箱在构建脚本中使用.依赖关系是通过<code>build-dependencies</code>清单的一部分:</p>
<pre><code class="language-toml">[build-dependencies]
cc = &quot;1.0.3&quot;
</code></pre>
<p>构建脚本<strong>才不是</strong>有权访问中列出的依赖项<code>dependencies</code>要么<code>dev-dependencies</code>部分.除非在下面列出,否则构建依赖项同样不可用于包本身<code>dependencies</code>部分也是如此.包本身及其构建脚本是单独构建的,因此它们的依赖关系不必重合.通过将独立依赖性用于独立目的,使Cargo更简单,更清洁.</p>
<a class="header" href="#choosing-features" id="choosing-features"><h3>Choosing features</h3></a>
<p>如果您依赖的包提供条件功能,您可以指定使用哪个:</p>
<pre><code class="language-toml">[dependencies.awesome]
version = &quot;1.3.5&quot;
default-features = false # do not include the default features, and optionally
                         # cherry-pick individual features
features = [&quot;secure-password&quot;, &quot;civet&quot;]
</code></pre>
<p>有关功能的更多信息,请参阅<a href="reference/manifest.html#the-features-section">清单文件</a>.</p>
<a class="header" href="#renaming-dependencies-in-cargotoml" id="renaming-dependencies-in-cargotoml"><h3>Renaming dependencies in <code>Cargo.toml</code></h3></a>
<p>写作的时候<code>[dependencies]</code>部分<code>Cargo.toml</code>您为依赖项编写的密钥通常与您在代码中导入的包的名称相匹配.但是,对于某些项目,您可能希望在代码中引用具有不同名称的包,而不管它是如何在crates.io上发布的.例如,您可能希望:</p>
<ul>
<li>避免需要<code>use foo as bar</code>在Rust来源.</li>
<li>取决于箱子的多个版本.</li>
<li>依赖来自不同注册管理机构的同名包装箱.</li>
</ul>
<p>为了支持这个Cargo支持a<code>package</code>关键在于<code>[dependencies]</code>应该依赖哪个包的部分:</p>
<pre><code class="language-toml">[package]
name = &quot;mypackage&quot;
version = &quot;0.0.1&quot;

[dependencies]
foo = &quot;0.1&quot;
bar = { git = &quot;https://github.com/example/project&quot;, package = &quot;foo&quot; }
baz = { version = &quot;0.1&quot;, registry = &quot;custom&quot;, package = &quot;foo&quot; }
</code></pre>
<p>在此示例中,Rust代码中现在提供了三个包:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate foo; // crates.io
extern crate bar; // git repository
extern crate baz; // registry `custom`
#}</code></pre></pre>
<p>所有这三个板条箱的包装名称都是<code>foo</code>在他们自己<code>Cargo.toml</code>所以我们明确地使用了<code>package</code>告知Cargo我们想要的关键<code>foo</code>包即使我们在本地调用其他东西.该<code>package</code>key,如果未指定,则默认为所请求的依赖项的名称.</p>
<p>请注意,如果您有可选的依赖项,例如:</p>
<pre><code class="language-toml">[dependencies]
foo = { version = &quot;0.1&quot;, package = 'bar', optional = true }
</code></pre>
<p>你依赖于箱子<code>bar</code>来自crates.io,但你的箱子有一个<code>foo</code>功能而不是<code>bar</code>特征.也就是说,在重命名时,功能的名称取决于依赖项的名称,而不是包名称.</p>
<p>启用传递依赖项的工作方式类似,例如我们可以将以下内容添加到上面的清单中:</p>
<pre><code class="language-toml">[features]
log-debug = ['foo/log-debug'] # using 'bar/log-debug' would be an error!
</code></pre>

                </main>

                <nav class="nav-wrapper" aria-label="Page navigation">
                    <!-- Mobile navigation buttons -->
                    
                    <a rel="prev" href="../reference/index.zh.html" class="mobile-nav-chapters previous" title="Previous chapter"
                        aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    

                    
                    <a rel="next" href="../reference/manifest.zh.html" class="mobile-nav-chapters next" title="Next chapter"
                        aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                    

                    <div style="clear: both"></div>
                </nav>
            </div>
        </div>

        <nav class="nav-wide-wrapper" aria-label="Page navigation">
            
            <a href="../reference/index.zh.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter"
                aria-keyshortcuts="Left">
                <i class="fa fa-angle-left"></i>
            </a>
            

            
            <a href="../reference/manifest.zh.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter"
                aria-keyshortcuts="Right">
                <i class="fa fa-angle-right"></i>
            </a>
            
        </nav>

    </div>

    

    
    <!-- Google Analytics Tag -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-128555056-1"></script>
    
    <script type="text/javascript">
        var localAddrs = ["localhost", "127.0.0.1", ""];
        if (localAddrs.indexOf(document.location.hostname) === -1) {
            window.dataLayer = window.dataLayer || [];
            function gtag() { dataLayer.push(arguments); }
            gtag('js', new Date());

            gtag('config', 'UA-128555056-1');
        }
    </script>
    

    

    
    <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
    

    <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
    <script src="../book.js" type="text/javascript" charset="utf-8"></script>

    <!-- Custom JS scripts -->
    

    

</body>

</html>