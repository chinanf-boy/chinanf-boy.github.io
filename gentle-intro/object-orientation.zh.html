<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>面向对象编程 - Rust 的绅士介绍</title>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="Rust语言，标准库和生态系统介绍">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="shortcut icon" href="favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
    <link rel="stylesheet" href="css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"
        rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    

    
</head>

<body class="light">
    <!-- Provide site root to javascript -->
    <script type="text/javascript">var path_to_root = "";</script>

    <!-- Work around some values being stored in localStorage wrapped in quotes -->
    <script type="text/javascript">
        try {
            var theme = localStorage.getItem('mdbook-theme');
            var sidebar = localStorage.getItem('mdbook-sidebar');

            if (theme.startsWith('"') && theme.endsWith('"')) {
                localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
            }

            if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
            }
        } catch (e) { }
    </script>

    <!-- Set the theme before any content is loaded, prevents flash -->
    <script type="text/javascript">
        var theme;
        try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
        if (theme === null || theme === undefined) { theme = 'light'; }
        document.body.className = theme;
        document.querySelector('html').className = theme + ' js';
    </script>

    <!-- Hide / unhide sidebar before it is displayed -->
    <script type="text/javascript">
        var html = document.querySelector('html');
        var sidebar = 'hidden';
        if (document.body.clientWidth >= 1080) {
            try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
            sidebar = sidebar || 'visible';
        }
        html.classList.remove('sidebar-visible');
        html.classList.add("sidebar-" + sidebar);
    </script>

    <nav id="sidebar" class="sidebar" aria-label="Table of contents">
        <ol class="chapter"><li class="affix"><a href="readme.zh.html">介绍</a></li><li><a href="1-basics.zh.html"><strong aria-hidden="true">1.</strong> 基本</a></li><li><a href="2-structs-enums-lifetimes.zh.html"><strong aria-hidden="true">2.</strong> 结构,枚举和匹配</a></li><li><a href="3-filesystem.zh.html"><strong aria-hidden="true">3.</strong> 文件系统和进程</a></li><li><a href="4-modules.zh.html"><strong aria-hidden="true">4.</strong> 模块和货物</a></li><li><a href="5-stdlib-containers.zh.html"><strong aria-hidden="true">5.</strong> 标准库容器</a></li><li><a href="6-error-handling.zh.html"><strong aria-hidden="true">6.</strong> 错误处理</a></li><li><a href="7-shared-and-networking.zh.html"><strong aria-hidden="true">7.</strong> 线程,网络和共享</a></li><li><a href="object-orientation.zh.html" class="active"><strong aria-hidden="true">8.</strong> 面向对象编程</a></li><li><a href="nom-intro.zh.html"><strong aria-hidden="true">9.</strong> 用nom解析</a></li><li><a href="pain-points.zh.html"><strong aria-hidden="true">10.</strong> 痛点</a></li></ol>
    </nav>

    <div id="page-wrapper" class="page-wrapper">

        <div class="page">
            
            <div id="menu-bar" class="menu-bar">
                <div id="menu-bar-sticky-container">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                            aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <!-- START - Rust Cookbook customization -->
                        <button id="edit-button" class="icon-button" type="button" title="Fork and edit" aria-label="Fork and edit"
                            aria-haspopup="true" aria-expanded="false" aria-controls="edit">
                            <i class="fa fa-edit">Edit</i>
                        </button>
                        <!-- END - Rust Cookbook customization -->
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme"
                            aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                            aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Rust 的绅士介绍</h1>
                    
                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

            
            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                        aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>
            

            <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
            <script type="text/javascript">
                document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                    link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                });
            </script>

            <!-- // START - Rust Cookbook customization -->
            <script>
                document.getElementById("edit-button").addEventListener("click", function () {
                    var editWindow = window.open("https://github.com/chinanf-boy/gentle-intro/edit/master/src/object-orientation.zh.md");
                });</script>
            <!-- // END - Rust Cookbook customization -->

            <div id="content" class="content">
                <main>
                    <a class="header" href="#a目录" id="a目录"><h2>目录</h2></a>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<ul>
<li><a href="#rust-%E4%B8%AD%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">Rust 中的面向对象</a>
<ul>
<li><a href="#trait-%E5%AF%B9%E8%B1%A1">trait 对象</a></li>
</ul>
</li>
<li><a href="#%E5%8A%A8%E7%89%A9">动物</a></li>
<li><a href="#%E9%B8%AD%E5%AD%90%E5%92%8C%E6%B3%9B%E5%9E%8B">鸭子和泛型</a></li>
<li><a href="#%E7%BB%A7%E6%89%BF">继承</a></li>
<li><a href="#%E7%A4%BA%E4%BE%8B-windows-api">示例: Windows API</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<a class="header" href="#rust-中的面向对象" id="rust-中的面向对象"><h2>Rust 中的面向对象</h2></a>
<p>世界各地的人们，以前的编程语言，是以某种方式实现面向对象编程 (OOP) 的可能性很大:</p>
<ul>
<li>‘类’作为生成 <em>对象</em> (通常被称为 <em>实例</em>) 并定义唯一的类型的工厂。</li>
<li>类可能 <em>继承</em> 其他类 (<em>父母</em>) 的数据 (<em>字段</em>) 和行为 (<em>方法</em>)。</li>
<li>如果 B 继承 A，那么将 B 的一个实例传递给希望接收 A (<em>子类</em>)的函数，是可能的。</li>
<li>一个对象应该隐藏它的数据 (<em>封装</em>) ，只用方法操作。</li>
</ul>
<p>面向对象的 <em>设计理念</em> 在于识别类 (’名词’) 和方法 (’动词’) ，然后建立它们之间的关系，关心它 <em>是一个</em> 什么 和它 <em>有一个</em> 什么。</p>
<p>在旧版”星际迷航”系列中，医生会对船长说: “这是人生，吉姆，但不是我们所知道的人生”。 这非常适用于 Rust 的面向对象风格: 它会带来震撼，因为 Rust 数据容器类型 (结构，枚举和元组) 都是很笨的，虽然你可以在其上定义方法，使数据本身是私有的，搭上所有常用的封装策略，但是它们之间都是 <em>不相干的类型</em>。 没有父类，没有继承 (除了<code>Deref</code>强制转换的个例。)</p>
<p>Rust 中各种数据类型之间的关系，由所拥有的 <em>trait</em> 来确立。 要学好 Rust 的很大一部分，是理解标准库 trait 是如何操作的，因为这是把所有数据类型粘在一起的意识网络。</p>
<p>trait 很有趣，因为它们与主流语言的概念之间没有一一对应的关系。 这取决于你是站在动态还是静态的角度思考。 在动态的情况下，它们更像 Java 或 Go 的接口。</p>
<a class="header" href="#trait-对象" id="trait-对象"><h3>trait 对象</h3></a>
<p>考虑一下，第一个介绍 trait 的例子:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Show {
    fn show(&amp;self) -&gt; String;
}

impl Show for i32 {
    fn show(&amp;self) -&gt; String {
        format!(&quot;four-byte signed {}&quot;, self)
    }
}

impl Show for f64 {
    fn show(&amp;self) -&gt; String {
        format!(&quot;eight-byte float {}&quot;, self)
    }
}
#}</code></pre></pre>
<p>受到很大影响的小程序，如下:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let answer = 42;
    let maybe_pi = 3.14;
    let v: Vec&lt;&amp;Show&gt; = vec![&amp;answer,&amp;maybe_pi];
    for d in v.iter() {
        println!(&quot;show {}&quot;,d.show());
    }
}
// show four-byte signed 42
// show eight-byte float 3.14
</code></pre></pre>
<p>这是 Rust 需要一些类型指导的一种情况 - 我指定了一个 Vec，其存有实现了 <code>Show</code> 的引用 。请注意 i32<code>和</code>f64<code>彼此之间是没有任何关系的，但他们都知道</code>show`方法，因为它们都实现了相同的 trait 。 这些名称方法是 <em>虚构的</em>，因为不同类型的实际方法有不同的代码，而正确的那个方法要根据 <em>运行时</em> 信息决定。或<a href="https://doc.rust-lang.org/stable/book/trait-objects.html">trait 对象</a>信息。</p>
<p><em>这</em> 就是你可以将不同类型的对象放在同一个 Vec 的原因(<code>Vec&lt;&amp;Show&gt;</code>)。 如果您有 Java 或 Go 背景，您可以把<code>Show</code>想成是接口。</p>
<p>细化下 - 我们把值放进<code>Box</code>。一个盒子包含对分配在堆上数据的引用，并在行为上非常像引用 - 它是一个 <em>智能指针</em>。 像引用，当盒子超出作用域和<code>Drop</code>会启动，然后释放内存。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let answer = Box::new(42);
let maybe_pi = Box::new(3.14);

let show_list: Vec&lt;Box&lt;Show&gt;&gt; = vec![question,answer];
for d in &amp;show_list {
    println!(&quot;show {}&quot;,d.show());
}
#}</code></pre></pre>
<p>不同之处在于，您现在可以使用该 Vec，当成一个引用去传递，或者不必跟踪任何借用的引用就可以将其传递出去。 当 Vec 被释放时，这些盒子值跟被释放，并且所有的内存都被回收。</p>
<a class="header" href="#a动物" id="a动物"><h2>动物</h2></a>
<p>出于某种原因，任何关于面向对象和继承的讨论，似乎最终都会讨论到动物。
它创造了一个不错的故事: “看，猫是食肉动物，而食肉动物是动物”。</p>
<p>但我会从 Ruby 宇宙的经典口号: “如果它嘎嘎叫，那就是鸭子” 开始。 你所有的对象必须做的，就是定义 <code>嘎嘎{quacks}</code>方法和，狭义来看，它就是鸭子。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Quack {
    fn quack(&amp;self);
}

struct Duck ();

impl Quack for Duck {
    fn quack(&amp;self) {
        println!(&quot;quack!&quot;);
    }
}

struct RandomBird {
    is_a_parrot: bool
}

impl Quack for RandomBird {
    fn quack(&amp;self) {
        if ! self.is_a_parrot {
            println!(&quot;quack!&quot;);
        } else {
            println!(&quot;squawk!&quot;);
        }
    }
}

let duck1 = Duck();
let duck2 = RandomBird{is_a_parrot: false};
let parrot = RandomBird{is_a_parrot: true};

let ducks: Vec&lt;&amp;Quack&gt; = vec![&amp;duck1,&amp;duck2,&amp;parrot];

for d in &amp;ducks {
    d.quack();
}
// quack!
// quack!
// squawk!
#}</code></pre></pre>
<p>在这里，我们有两种完全不同的类型 (其中一个非常笨，甚至没有数据) ，并且是的，它们都能<code>quacks()</code>。
其中一个的行为有点奇怪 (比如:一只鸭子(duck))，但他们共享相同的方法名称，Rust 可以从类型安全的方式，保存这类对象的集合。</p>
<p>类型安全是一件奇妙的事情。若没有静态类型，你甚至可以插入一个 <em>猫</em> 进入这个 Quackers 集合，最终导致运行时的混乱。</p>
<p>这是一个有趣的:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// 为什么不是!
impl Quack for i32 {
    fn quack(&amp;self) {
        for i in 0..*self {
            print!(&quot;quack {} &quot;,i);
        }
        println!(&quot;&quot;);
    }
}

let int = 4;

let ducks: Vec&lt;&amp;Quack&gt; = vec![&amp;duck1,&amp;duck2,&amp;parrot,&amp;int];
...
// quack!
// quack!
// squawk!
// quack 0 quack 1 quack 2 quack 3
#}</code></pre></pre>
<p>我能说什么? 它嘎嘎声叫，它一定是一只鸭子。
有趣的是，你可以把你的 trait 应用到任何 Rust 值，而不仅仅是”对象”。</p>
<p>(因<code>quack</code>以引用类型的方式传递，需要有明确的解引用符号<code>*</code>，来得到整数。)</p>
<p>然而，你只能用同一个库的 trait 和类型来做这件事，标准库是不允许打’补丁’的，这是另一个 Ruby 人的做法 (也还不是最受欢迎的做法) 。</p>
<p>到目前为止，这个 <code>Quack</code> trait 表现得非常像 Java 接口，并且同现代 Java 接口一样，实现 <em>必要</em> 方法， <em>提供</em> 这个方法的默认实现。 (该<code>Iterator</code>trait 就是一个很好的例子。 )</p>
<p>但是，请注意 trait 不属于 <em>定义类型</em> ，和为任何类型实现新的 trait ，但要受到同一个库的限制。</p>
<p>还能要求，只接收<code>Quack</code>实现者的引用:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn quack_ref (q: &amp;Quack) {
    q.quack();
}

quack_ref(&amp;d);
#}</code></pre></pre>
<p>而这，就是 Rust 风格的’类’。</p>
<p>由于我们在这里进行 101 编程语言比较，所以我提个， Go 对这个嘎嘎工程的一个有趣看法 - 如果有一个 Go 接口<code>Quack</code>，和具有<code>quack</code>方法的一个类型，那么类型就满足了<code>Quack</code>接口，不需要明确的定义。这也打破了定义好的 Java 模型，并且允许编译时填鸭式类型，代价是一些清晰和类型安全。</p>
<p>但是填鸭式类型有一个问题。OOP 的坏标志之一是，太多的方法有一些通用方法名称，如<code>run</code>。”如果它已经有了 run()，它必是能运行的”，听起来不像鸭鸭那么友善! 所以这让 Go 接口变成了 <em>偶然</em> 有效。在 Rust，虽然<code>Debug</code>和<code>Display</code>trait 两者都定义了<code>fmt</code>方法，但他们真的就是不同的事情。</p>
<p>所以 Rust 的 trait 允许传统 <em>多态</em> OOP。但继承怎么办呢? 人们常指 <em>实现继承</em> ，Rust 则是 <em>接口继承</em>。就好像一位 Java 程序员不去<code>extend</code>(扩展)，改为<code>implements</code>(实现)。实际上，这是<a href="http://www.javaworld.com/article/2073649/core-java/why-extends-is-evil.html">推荐的做法</a>来自 Alan Holub。他说:</p>
<blockquote>
<p>我曾经参加过一个 Java 用户组会议，James Gosling (Java 的发明人) 是这个会议的功能</p>
<p>演讲者. 在令人难忘的问答环节中,有人问他: “如果你能再一次做 Java,</p>
<p>你会改变什么?””我会放弃 class ,”他回答说,在笑声平息后,</p>
</blockquote>
<blockquote>
<p>他解释说,真正的问题不是类本身,而是实现继承{implementation inheritance}，老是在扩展关系{extends relationship}。</p>
</blockquote>
<blockquote>
<p>接口继承 (实现关系{the implements relationshup}) 是可取的。</p>
</blockquote>
<blockquote>
<p>尽可能避免实现继承{implementation inheritance}</p>
</blockquote>
<p>所以即使在 Java 中，你也可能过度使用类。</p>
<p>实现继承有一些严重的问题。但它的确很 <em>方便</em>。 如有个臃肿的基类，叫动物和它有很多有用的功能 (它甚至可能暴露它的内部!)，到了我们的派生类，<code>猫</code>就可以使用。也就是说，它是一种代码重用的形式。但是代码重用是一个单独的问题。</p>
<p>理解 Rust 时，区分 实现/接口继承 很重要。</p>
<p>请注意， trait 可能有 <em>已提供</em> 的方法。想想<code>Iterator</code>- 你只 <em>需要</em> 重写<code>next</code>方法，却免费获得大量的方法。 这与现代 Java 接口的”default”方法类似。下面，我们只定义<code>name</code>，和<code>upper_case</code>是定义好(默认)的。 我们 <em>可以</em> 覆盖<code>upper_case</code>，但没有 <em>必要</em>。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Named {
    fn name(&amp;self) -&gt; String;

    fn upper_case(&amp;self) -&gt; String {
        self.name().to_uppercase()
    }
}

struct Boo();

impl Named for Boo {
    fn name(&amp;self) -&gt; String {
        &quot;boo&quot;.to_string()
    }
}

let f = Boo();

assert_eq!(f.name(),&quot;boo&quot;.to_string());
assert_eq!(f.upper_case(),&quot;BOO&quot;.to_string());
#}</code></pre></pre>
<p>这是个 <em>如同</em> 代码重用的示例，是真的，但注意，它不适用于数据，只适用于接口!</p>
<a class="header" href="#a鸭子和泛型" id="a鸭子和泛型"><h2>鸭子和泛型</h2></a>
<p>Rust 中一个泛型友好的鸭子函数，就是这样一个简单的例子:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn quack&lt;Q&gt; (q: &amp;Q)
where Q: Quack {
    q.quack();
}

let d = Duck();
quack(&amp;d);
#}</code></pre></pre>
<p>类型参数是 <em>任何</em> 实现了<code>Quack</code>的类型。<code>quack</code>与上节提到的<code>quack_ref</code>之间有一个重要的区别。 这函数的主体会为 <em>每个</em> 调用类型进行编译，并且不需要虚构方法; 这些函数可以完全内联编译。不同的方式使用 <code>Quack</code> trait ，作为在泛型类型上的一个 <em>约束</em>。</p>
<p>这是相当于 C ++的泛型<code>quack</code> (注意这个<code>const</code>) :</p>
<pre><code class="language-cpp">template &lt;class Q&gt;
void quack(const Q&amp; q) {
    q.quack();
}
</code></pre>
<p>请注意，类型参数不受任何限制。</p>
<p>这是非常多的编译时鸭式输入 - 如果我们传递一个不存在<code>quack</code>方法的类型的引用，那么编译器会抱怨没有 <code>quack</code> 方法。 至少这个错误是在编译时发现的，但是当一个类型被意外有<code>quack</code>时会更糟，Go 就可能发生。 相关的更多模板函数和类会导致可怕的错误消息，因为 <em>没有</em> 对泛型的限制。</p>
<p>你可以定义一个函数，它可以处理在 Quacker 指针上的迭代:</p>
<pre><code class="language-cpp">template &lt;class It&gt;
void quack_everyone (It start, It finish) {
    for (It i = start; i != finish; i++) {
        (*i)-&gt;quack();
    }
}
</code></pre>
<p><em>每个</em> 迭代器类型<code>It</code>都实现。 Rust 的等价物多少更具挑战性:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn quack_everyone &lt;I&gt; (iter: I)
where I: Iterator&lt;Item=Box&lt;Quack&gt;&gt; {
    for d in iter {
        d.quack();
    }
}

let ducks: Vec&lt;Box&lt;Quack&gt;&gt; = vec![Box::new(duck1),Box::new(duck2),Box::new(parrot),Box::new(int)];

quack_everyone(ducks.into_iter());
#}</code></pre></pre>
<p>Rust 中的迭代器不是鸭类型的，必须是实现了<code>Iterator</code>的类型
，在这种情况下，迭代器提供了一些盒化<code>Quack</code>。 所涉及的类型没有歧义，值必须满足<code>Quack</code>。 通常，函数签名是一个 Rust 泛型函数的最具挑战性的事情，这就是为什么我建议阅读标准库的源代码 - 实现 通常比 声明简单得多!</p>
<p>这里唯一的类型参数是实际的迭代器类型，意味着，任何可以具有<code>Box&lt;Duck&gt;</code>序列的迭代器都能用，而不仅仅是一个 Vec 迭代器。</p>
<a class="header" href="#a继承" id="a继承"><h2>继承</h2></a>
<p>面向对象设计的一个常见问题是，试图将事情强加到一个 <em>是一个</em> 什么的关系中，而忽视 <em>有一个</em> 什么的关系。 <a href="https://en.wikipedia.org/wiki/Design_Patterns">四人帮</a>
二十二年前在他们的设计模式书中，说过”首选继承布局”。</p>
<p>这里有一个例子: 你想模拟一些公司的员工，并且<code>雇员{Employee}</code>似乎是一个类的好名字。然后，经理 <strong>是一个</strong> 员工 (这是真的) ，所以我们开始用一个构建我们的层次结构：</p>
<p><code>Employee</code>的子类<code>经理{Manager}</code>。这并不像看起来那么流畅。 也许是我们对识别重要名词感到厌倦，也许我们 (无意识地) 认为经理和员工是不同种类的动物? 更好的方式，是雇员 <strong>有一个</strong> 一个 <code>Roles（角色）</code>的集合，然后一个经理，仅仅是一个有更多的责任和能力的<code>Employee</code>。</p>
<p>或考虑车辆 - 从自行车到 300 吨矿车。 有多种方式可以考虑车辆，道路需求 (全地形，城市，铁路等) ，电源来源 (电力，柴油，柴油电力等) ，运货物还是人等等。当您根据一个方面，去创建任何固定层次的类，都会忽略所有其他方面。也就是说，可能有多种的车辆分类!</p>
<p>布局在 Rust 中更为重要，原因很明显，您无法从基类以惰性方式继承功能。</p>
<p>布局还是很重要，因为借用检查器足够聪明，可以知道借来的不同结构字段都是独立的借用。你可以有一个字段的可变借用，同时拥有另一个字段的不可变借用，等等。</p>
<p>Rust 不能说，一个方法只访问一个字段，所以为了实现方便，这些字段应该用自己的方法来构造。 (结构的 <em>外部</em> 接口，可以是任何你喜欢使用的合适 trait。 )</p>
<p>“拆分借来的{split borrowing}”的一个具体例子，会使这个更清晰。</p>
<p>有个拥有一些字符串的结构，和一个方法，是说能可变借用第一字符串。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Foo {
    one: String,
    two: String
}

impl Foo {
    fn borrow_one_mut(&amp;mut self) -&gt; &amp;mut String {
        &amp;mut self.one
    }
    ....
}
#}</code></pre></pre>
<p>(这是 Rust 命名约定的一个例子 - 这类方法应该以<code>_mut</code>结尾)</p>
<p>现在，一种借用两个字符串的方法，重用第一种方法:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    fn borrow_both(&amp;self) -&gt; (&amp;str,&amp;str) {
        (self.borrow_one_mut(), &amp;self.two)
    }
#}</code></pre></pre>
<p>这会失败! 因我们既有个<code>self</code>的可变借用，<em>又</em>有个 <em>也</em> <code>self</code>的不可变借用。 如果 Rust 允许这样的情况发生，那么无法保证 不可变引用(借用) 不会改变。</p>
<p>解决方案很简单:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    fn borrow_both(&amp;self) -&gt; (&amp;str,&amp;str) {
        (&amp;self.one, &amp;self.two)
    }
#}</code></pre></pre>
<p>好了，因为借用检查员，认为这些是独立的借用。所以想象这些字段是一些任意类型，你可以看到在这些字段上调用的方法，不会导致借用问题。</p>
<p>使用<a href="https://rust-lang.github.io/book/second-edition/ch15-02-deref.html">Deref</a>是一种限制但非常重要的”继承”，这是’解引用’符号<code>*</code>(语法糖)的 实际 trait 。<code>String</code>实现了<code>Deref&lt;Target=str&gt;</code>，所以<code>＆str</code>上定义的所有方法，自动都可用于<code>String</code>! 类似的，<code>Foo</code>的方法可以直接调用<code>Box&lt;Foo&gt;</code>，有些人觉得这有点... 神奇，但它是非常方便能力。
现代 Rust 中有一种更简单的语言，但使用起来并不令人愉快。
它确实应该用于，一个具有所有权-可变的类型和一个简单的借用类型的情况。</p>
<p>一般来说， 这就是 Rust 中的 <em>trait 继承</em>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Show {
    fn show(&amp;self) -&gt; String;
}

trait Location {
    fn location(&amp;self) -&gt; String;
}

trait ShowTell: Show + Location {}
#}</code></pre></pre>
<p>最后一个 trait 简单地将我们两个不同的 trait 合并为一个，尽管它可以指定其他方法。</p>
<p>现在的情况和以前一样:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug)]
struct Foo {
    name: String,
    location: String
}

impl Foo {
    fn new(name: &amp;str, location: &amp;str) -&gt; Foo {
        Foo{
            name: name.to_string(),
            location: location.to_string()
        }
    }
}

impl Show for Foo {
    fn show(&amp;self) -&gt; String {
        self.name.clone()
    }
}

impl Location for Foo {
    fn location(&amp;self) -&gt; String {
        self.location.clone()
    }
}

impl ShowTell for Foo {}
#}</code></pre></pre>
<p>现在，如果我有<code>Foo</code>类型的<code>foo</code>值，那么对该值的引用将会满足<code>&amp;Show</code>，<code>&amp;Location</code>或是<code>&amp;ShowTell</code> (这暗示着两者) 三个。</p>
<p>这是一个有用的小宏:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
macro_rules! dbg {
    ($x:expr) =&gt; {
        println!(&quot;{} = {:?}&quot;,stringify!($x),$x);
    }
}
#}</code></pre></pre>
<p>它需要一个参数 (用<code>$x</code>表示) 必须是一个’表达式(expression)’。 我们打印出它的值，和一个 <em>字符串化</em> 的版本。 C 程序员会在这一点上有些 <em>小</em> 得意，这意味着如果我传递了<code>1 + 2</code> (一个表达式) <code>stringify!(1 + 2)</code>是字面字符串”1 + 2”。 这会为我们在玩代码时节省一些打字的时间:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let foo = Foo::new(&quot;Pete&quot;,&quot;bathroom&quot;);
dbg!(foo.show());
dbg!(foo.location());

let st: &amp;ShowTell = &amp;foo;

dbg!(st.show());
dbg!(st.location());

fn show_it_all(r: &amp;ShowTell) {
    dbg!(r.show());
    dbg!(r.location());
}

let boo = Foo::new(&quot;Alice&quot;,&quot;cupboard&quot;);
show_it_all(&amp;boo);

fn show(s: &amp;Show) {
    dbg!(s.show());
}

show(&amp;boo); // `Show`引用传递给`show`

// foo.show() = &quot;Pete&quot;
// foo.location() = &quot;bathroom&quot;
// st.show() = &quot;Pete&quot;
// st.location() = &quot;bathroom&quot;
// r.show() = &quot;Alice&quot;
// r.location() = &quot;cupboard&quot;
// s.show() = &quot;Alice&quot;
#}</code></pre></pre>
<p>这些就 <em>是</em> 面向对象，但不是你习惯的那种。</p>
<p>请注意，<code>Show</code>引用传递给<code>show</code>，它不可能是 <em>动态</em> 升级为<code>ShowTell</code>! 占据更多动态类系统范畴的语言，允许您检查给定对象是否是类的实例，然后对该类型执行动态转换。 一般来说这不是一个好主意，特别是不能在 Rust 中工作，因为<code>Show</code>引用已经”忘记”它最初是一个<code>ShowTell</code>引用。</p>
<p>你总有选择: 多态，通过 trait 对象，或是单态，通过泛型约束的 trait 。 现代 C ++和 Rust 标准库倾向于采用泛型路由，但多态路由并未过时。 您必须了解’路’的不同 - 泛型生成最快的代码，且可以内联。 这可能会导致代码膨胀。 但并非所有事情都要 <em>尽可能快</em>- 有时某个程序运行的生命周期中，可能只发生”那么”几次。</p>
<p>最后，这里有一个总结:</p>
<ul>
<li><code>class</code>所扮演的角色在数据和 traits 之间共享。</li>
<li>结构和枚举是笨的，虽然你可以定义方法和做数据隐藏。</li>
<li>使用<code>Deref</code> trait ，可以对数据进行一个子类型化的 <em>限制</em> 形式。</li>
<li>trait 没有任何数据，但可以实现任何类型 (不仅仅是结构)。</li>
<li>trait 可以从其他 trait 继承。</li>
<li>trait 可以提供方法，允许接口代码重用。</li>
<li>trait 给你两个虚构方法 (多态) 和泛型约束 (单态)。</li>
</ul>
<a class="header" href="#a示例-windows-api" id="a示例-windows-api"><h2>示例: Windows API</h2></a>
<p>GUI 工具包是广泛使用传统 OOP 的领域之一。 一个<code>EditControl</code>或者一个<code>ListWindow</code><strong>是一个</strong><code>Window</code>等等。这使得编写 Rust 绑定到 GUI 工具包，比使用它更困难。</p>
<p>Win32 编程在 Rust 中可以<a href="https://www.codeproject.com/Tips/1053658/Win-GUI-Programming-In-Rust-Language">直接</a>完成，它比原来的 C 稍微笨拙一点。 当我从 C 到 C ++ 毕业时，我想要更干净的东西，并且做了我自己的 OOP 包装。</p>
<p>一个典型的 Win32 API 函数是<a href="https://docs.rs/user32-sys/0.0.9/i686-pc-windows-gnu/user32_sys/fn.ShowWindow.html">ShowWindow</a>，用于控制窗口的可见性。 现在，一个<code>EditControl</code>有一些专门的功能，但它都是用 Win32 <code>HWND</code> (’handle to window’) 不透明的值完成的。若你想要<code>EditControl</code>也有一个<code>show</code>方法，传统上这将通过实现继承来完成，但您 <em>不</em> 想要为每种类型输出所有这些继承的方法! 而 Rust trait 提供了一个解决方案，这会有一个<code>Window</code> trait :</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Window {
    // 你需要定义这个！
    fn get_hwnd(&amp;self) -&gt; HWND;

    // 所有这些都将提供
    fn show(&amp;self, visible: bool) {
        unsafe {
         user32_sys::ShowWindow(self.get_hwnd(), if visible {1} else {0})
        }
    }

    // .....在 Windows 上运行的大量方法

}
#}</code></pre></pre>
<p>所以，<code>EditControl</code>的实现结构只能包含一个<code>HWND</code>，并通过定义一种方法实现<code>Window</code>; <code>EditControl</code>是一种继承自<code>Window</code>的 trait ，并定义了扩展接口。比如像<code>ComboxBox</code>这样的 - 其行为像一个<code>EditControl</code> <em>和</em> 可以通过 trait 继承轻松实现 一个<code>ListWindow</code>。</p>
<p>Win32 API (’32’不再意味着’32 位’) 实际上是面向对象的，但是老一辈，受 Alan Kay 定义的影响: 对象包含隐藏的数据，并且由 <em>消息{messages}</em> 控制。因此，任何 Windows 应用程序的核心都有一个消息循环，各种窗口 (称为’窗口类’) 都用它们自己的 switch 语句实现这些方法。 其中有一个消息，可能有不同的实现，叫<code>WM_SETTEXT</code>: 标签的文本更改，顶级窗口的标题会变化。</p>
<p><a href="https://gabdube.github.io/native-windows-gui/book_20.html">这里</a>是一个相当有前途的最小 Windows GUI 框架。 但根据我的口味，有太多了<code>unwrap</code>实例 - 其中一些甚至没有错误。</p>
<p>这是因为 NWG 正在利用消息的松散动态性质。通过适当的类型安全接口，编译时会捕获更多的错误。</p>
<p>在<a href="https://rust-lang.github.io/book/second-edition/ch17-00-oop.html">下一版</a>的 Rust 编程语言手册中， Rust 对面向对象的含义进行了很好的讨论。</p>

                </main>

                <nav class="nav-wrapper" aria-label="Page navigation">
                    <!-- Mobile navigation buttons -->
                    
                    <a rel="prev" href="7-shared-and-networking.zh.html" class="mobile-nav-chapters previous" title="Previous chapter"
                        aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    

                    
                    <a rel="next" href="nom-intro.zh.html" class="mobile-nav-chapters next" title="Next chapter"
                        aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                    

                    <div style="clear: both"></div>
                </nav>
            </div>
        </div>

        <nav class="nav-wide-wrapper" aria-label="Page navigation">
            
            <a href="7-shared-and-networking.zh.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter"
                aria-keyshortcuts="Left">
                <i class="fa fa-angle-left"></i>
            </a>
            

            
            <a href="nom-intro.zh.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter"
                aria-keyshortcuts="Right">
                <i class="fa fa-angle-right"></i>
            </a>
            
        </nav>

    </div>

    

    
    <!-- Google Analytics Tag -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-128555056-1"></script>
    
    <script type="text/javascript">
        var localAddrs = ["localhost", "127.0.0.1", ""];
        if (localAddrs.indexOf(document.location.hostname) === -1) {
            window.dataLayer = window.dataLayer || [];
            function gtag() { dataLayer.push(arguments); }
            gtag('js', new Date());

            gtag('config', 'UA-128555056-1');
        }
    </script>
    

    

    
    <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
    

    <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
    <script src="book.js" type="text/javascript" charset="utf-8"></script>

    <!-- Custom JS scripts -->
    

    

</body>

</html>