<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>痛点 - Rust 的绅士介绍</title>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="Rust语言，标准库和生态系统介绍">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="shortcut icon" href="favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
    <link rel="stylesheet" href="css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"
        rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    

    
</head>

<body class="light">
    <!-- Provide site root to javascript -->
    <script type="text/javascript">var path_to_root = "";</script>

    <!-- Work around some values being stored in localStorage wrapped in quotes -->
    <script type="text/javascript">
        try {
            var theme = localStorage.getItem('mdbook-theme');
            var sidebar = localStorage.getItem('mdbook-sidebar');

            if (theme.startsWith('"') && theme.endsWith('"')) {
                localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
            }

            if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
            }
        } catch (e) { }
    </script>

    <!-- Set the theme before any content is loaded, prevents flash -->
    <script type="text/javascript">
        var theme;
        try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
        if (theme === null || theme === undefined) { theme = 'light'; }
        document.body.className = theme;
        document.querySelector('html').className = theme + ' js';
    </script>

    <!-- Hide / unhide sidebar before it is displayed -->
    <script type="text/javascript">
        var html = document.querySelector('html');
        var sidebar = 'hidden';
        if (document.body.clientWidth >= 1080) {
            try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
            sidebar = sidebar || 'visible';
        }
        html.classList.remove('sidebar-visible');
        html.classList.add("sidebar-" + sidebar);
    </script>

    <nav id="sidebar" class="sidebar" aria-label="Table of contents">
        <ol class="chapter"><li class="affix"><a href="readme.zh.html">介绍</a></li><li><a href="1-basics.zh.html"><strong aria-hidden="true">1.</strong> 基本</a></li><li><a href="2-structs-enums-lifetimes.zh.html"><strong aria-hidden="true">2.</strong> 结构,枚举和匹配</a></li><li><a href="3-filesystem.zh.html"><strong aria-hidden="true">3.</strong> 文件系统和进程</a></li><li><a href="4-modules.zh.html"><strong aria-hidden="true">4.</strong> 模块和货物</a></li><li><a href="5-stdlib-containers.zh.html"><strong aria-hidden="true">5.</strong> 标准库容器</a></li><li><a href="6-error-handling.zh.html"><strong aria-hidden="true">6.</strong> 错误处理</a></li><li><a href="7-shared-and-networking.zh.html"><strong aria-hidden="true">7.</strong> 线程,网络和共享</a></li><li><a href="object-orientation.zh.html"><strong aria-hidden="true">8.</strong> 面向对象编程</a></li><li><a href="nom-intro.zh.html"><strong aria-hidden="true">9.</strong> 用nom解析</a></li><li><a href="pain-points.zh.html" class="active"><strong aria-hidden="true">10.</strong> 痛点</a></li></ol>
    </nav>

    <div id="page-wrapper" class="page-wrapper">

        <div class="page">
            
            <div id="menu-bar" class="menu-bar">
                <div id="menu-bar-sticky-container">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                            aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <!-- START - Rust Cookbook customization -->
                        <button id="edit-button" class="icon-button" type="button" title="Fork and edit" aria-label="Fork and edit"
                            aria-haspopup="true" aria-expanded="false" aria-controls="edit">
                            <i class="fa fa-edit">Edit</i>
                        </button>
                        <!-- END - Rust Cookbook customization -->
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme"
                            aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                            aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Rust 的绅士介绍</h1>
                    
                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

            
            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                        aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>
            

            <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
            <script type="text/javascript">
                document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                    link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                });
            </script>

            <!-- // START - Rust Cookbook customization -->
            <script>
                document.getElementById("edit-button").addEventListener("click", function () {
                    var editWindow = window.open("https://github.com/chinanf-boy/gentle-intro/edit/master/src/pain-points.zh.md");
                });</script>
            <!-- // END - Rust Cookbook customization -->

            <div id="content" class="content">
                <main>
                    <a class="header" href="#a目录" id="a目录"><h2>目录</h2></a>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<ul>
<li><a href="#%E7%97%9B%E7%82%B9">痛点</a></li>
<li><a href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD">类型推断</a></li>
<li><a href="#%E5%8F%AF%E5%8F%98%E5%BC%95%E7%94%A8">可变引用</a></li>
<li><a href="#%E5%BC%95%E7%94%A8%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">引用和生命周期</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a></li>
<li><a href="#%E5%85%B3%E4%BA%8E%E5%88%86%E5%8F%B7%E7%9A%84%E8%AF%B4%E6%98%8E">关于分号的说明</a></li>
<li><a href="#%E4%B8%93%E6%80%BC-c-%E9%97%AE%E9%A2%98">专怼 C ++问题</a>
<ul>
<li><a href="#rust-%E5%80%BC%E8%AF%AD%E4%B9%89%E6%98%AF%E4%B8%8D%E5%90%8C%E7%9A%84">Rust 值语义是不同的</a></li>
<li><a href="#%E5%85%B1%E4%BA%AB%E5%BC%95%E7%94%A8">共享引用</a></li>
<li><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8">迭代器</a></li>
<li><a href="#%E4%B8%8D%E5%AE%89%E5%85%A8%E5%92%8C%E9%93%BE%E6%8E%A5%E5%88%97%E8%A1%A8">不安全和链接列表</a></li>
</ul>
</li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<a class="header" href="#a痛点" id="a痛点"><h2>痛点</h2></a>
<p>可以说 Rust 是一门比大多数”主流”语言更难学的语言。 有特别的人不觉得这么难，但要注意’特别’的真正含义 - 他们是 <em>例外的</em>。 许多人先要挣扎一番，后才成功。 最初的艰难是不能预测你的未来!</p>
<p>我们来自世界各地，处于各种编程语言的情况下，这意味着，存在以前主流语言的遗留思维，如 Python 之类的”动态”语言 或 C ++之类的”静态”语言，或其他的。 但无论你过去的思维方式是怎么样的， Rust 都有很大的不同，需要转变思路。有经验的聪明人加入 Rust 学习，觉得说，以他们的聪明才智，却不能立即获得回报，他们会感到失望; 自我认识较低的人则认为自己不够”聪明”。</p>
<p>对于那些具有动态语言经验的人 (包括 Java，我想)，所有的一切都是一个<code>引用&amp;</code>，并且所有引用默认都是可变的。还有垃圾收集功能 <em>确实</em> 让编写内存安全的程序更容易。 而以内存成本和可预测性为代价，JVM 进展非常迅速。 通常这种成本被认为是值得的 - 传统的新想法认为程序员的生产力 比 计算机的性能更重要。</p>
<p>但，世界上大多数电脑 - 如处理汽车阀门控制等之类的真正重要事情 - 并不具备大量资源，甚至连一个便宜笔记本电脑都比不上，和他们需要的是 <em>实时</em> 响应。同样，基础软件基础架构需要正确，稳健和快速 (旧工程的三体)。 而这大部分，都是本质上不安全的 C 和 C ++ 完成的，这个不安全的 <em>总成本</em> 应该是我们所要正视的。也许你组合项目起来，飞快，但 <em>在这之后</em> 真正的开发才刚刚开始。</p>
<p>系统语言无法承担垃圾回收，因为它们是其他所有东西依赖的基础。只要你认为合适，他们就让你自由地浪费资源。</p>
<p>但如果没有垃圾回收，内存就必须以其他方式进行管理。 <em>手动内存管理</em> - 我抓住内存，使用它，并明确地将其退回 - 很难做对。 您可以在几周内学会够用的 C 语言，以提高工作效率，而危险性也随之而来 - 要成为一名安全的 C 语言程序员需要花费数年时间，并检查每种可能的错误情况。</p>
<p>Rust 像现代 C ++ 一样管理内存 - 随着对象被破坏，其内存被回收。 你可以在堆上分配内存<code>Box</code>，但只要在函数结束，Box’超出范围’时，弃内存就会被回收。所以 Rust 有像<code>new</code>这样的事情，但没有<code>删除{delete}</code>。 你可以创建一个<code>File</code>和在最后，文件 (一个宝贵的资源)会自动被关闭。 在 Rust 中，这被称为 <em>扔掉{dropping}</em>。</p>
<p>你需要共享资源 - 复制一切都是非常低效的 - 这就是事情变得有趣的地方。 C ++也有引用，尽管 Rust 引用更像 C 指针 - 你需要使用<code>*r</code>才能用引用指向的值 {value}，你需要加上<code>&amp;</code>，一个值才作为引用类型传递。</p>
<p>Rust 的 <em>借用检查器</em> 确保在原始值被销毁后，引用不可能存在。</p>
<a class="header" href="#a类型推断" id="a类型推断"><h2>类型推断</h2></a>
<p>“静态”和”动态”之间的区别不是一切。 与大多数事情一样，还有很多可以发挥的区域。 C 是静态类型的 (每个变量在编译时，都有一个类型)，但弱类型 (例如，<code>void*</code>可以指向 <em>任何{anything}</em>); Python 是动态类型的 (类型与值相关，而不是变量)，但却是强类型的。 Java 是静态/非常强类型的 (有反射「reflection」功能，这就像方便，但危险的阀门)， Rust 是静态/强类型的，运行时没有反射。</p>
<p>Java 因需要在麻木细节中， <em>键入</em> 所有的类型而出名, Rust 更喜欢 <em>推断</em> 类型。 这通常是一个好主意，但这也确实意味着，有时你需要计算出实际类型。 当会看见<code>let n = 100</code>，并想知道 - 这是什么样的整数? 默认情况下，它会是<code>i32</code>- 一个四字节有符号整数。 现在大家都同意 C 的未指定整数类型 (比如<code>int</code>和<code>long</code>) 是一个坏主意; 最好明确类型。 你可以随时拼写出类型，如<code>let n: u32 = 100</code>，或者强制类型，如<code>let n = 100u32</code>。 但是类型推断比这要强! 如果你声明<code>let n = 100</code>，然后<code>rustc</code>全部知道，<code>n</code>一定是 <em>一些</em> 整数类型。 如果之后，你想把<code>n</code>传递到一个函数，其期望一个<code>u64</code>类型，那么这一定是这种类型的<code>n</code>!</p>
<p>之后，你尝试给<code>n</code>到期望<code>u32</code>函数，<code>rustc</code>不会让你这样做，因为<code>n</code>已被束缚到<code>u64</code>，和它 <em>将不会</em> 采取简单，且隐式的方法为您转换该整数。这是来自类型的强力攻势 - 没有任何一点转换，和‘促销活动’让你的生活更流畅，这样做的同时，整数不会溢出突然咬住你的屁股。你必须明确地表明<code>n</code>转换，如<code>n as u32</code>- 一个 Rust 类型。 幸好，<code>rustc</code>善于以”可行”的方式打败坏家伙 - 也就是说，您可以按照编译器的意见来解决问题.</p>
<p>所以， Rust 代码可以非常明确的类型:</p>
<pre><code class="language-Rust">let mut v = Vec::new();
// v 被推断为  Vec&lt;i32&gt;类型
v.push(10);
v.push(20);
v.push(&quot;hello&quot;) &lt;--- 不能这样做，盆友！
</code></pre>
<p>不能将字符串放入一个整数 Vec 是一个功能，而不是一个错误。 动态类型的灵活性也是一个诅咒。</p>
<p>(如果你将需要 <em>把</em> 整数和字符串放入同一个 Vec，那么 Rust <code>枚举</code>类型是安全地使用它的方法。 )</p>
<p>有时，你需要至少给一个类型 <em>暗示</em>. <code>collect</code>是一个梦幻般的迭代器方法，但它需要一个提示。比如说，我有一个迭代器，它返回<code>char</code>，然后<code>collect</code>可有两种方式:</p>
<pre><code class="language-Rust">// 一个  char vec ['h','e','l','l','o']
let v: Vec&lt;_&gt; = &quot;hello&quot;.chars().collect();
// 一个 &quot;doy&quot; 字符串
let m: String = &quot;dolly&quot;.chars().filter(|&amp;c| c != 'l').collect();
</code></pre>
<p>当对某个变量的类型感到不确定时，总会有能，强行让<code>rustc</code>在错误消息中显示实际类型名称的技巧:</p>
<pre><code class="language-Rust">let x: () = var;
</code></pre>
<p><code>rustc</code>可能会选择十分特定类型。这里我们想把不同的引用放入一个 Vec，但需要使用<code>&amp;Debug</code>明确声明类型。</p>
<pre><code class="language-Rust">use std::fmt::Debug;

let answer = 42;
let message = &quot;hello&quot;;
let float = 2.7212;

let display: Vec&lt;&amp;Debug&gt; = vec![&amp;message, &amp;answer, &amp;float];

for d in display {
    println!(&quot;got {:?}&quot;, d);
}
</code></pre>
<a class="header" href="#a可变引用" id="a可变引用"><h2>可变引用</h2></a>
<p>规则是: 一次只有一个可变引用。 原因在于，当 <em>到处都是</em> 都是可变性引用，那跟踪他们就很难。在笨蛋小程序中不明显，但在大型代码库中可能会变得糟糕。</p>
<p>进一步的限制是，当已有一个可变引用时，你不能再拥有不可变引用， 否则，任何有这些引用的人都不能保证他们不会改变。 C ++也有不可变的引用 (例如<code>const string&amp;</code>) ，但是 <em>不能</em> 给你这个保证，因为有人可能在你背后，保留一个<code>string&amp;</code>引用并修改它。</p>
<p>如果您习惯每个引用都是可变的语言，那这会是一个挑战! 不安全的”放松”语言，取决于人们了解他们自己的计划，并秉直地决定不做坏事。 但是大型项目是由不止一个人编写的，并且超出了个人，详细理解的能力。</p>
<p><em>更气人</em> 事情是，借用检查器并不像它所描述的那样聪明。</p>
<pre><code class="language-Rust">let mut m = HashMap::new();
m.insert(&quot;one&quot;, 1);
m.insert(&quot;two&quot;, 2);

if let Some(r) = m.get_mut(&quot;one&quot;) { // &lt;-- m 的可变引用
    *r = 10;
} else {
    m.insert(&quot;one&quot;, 1); // 不能再次可变借用!
}
</code></pre>
<p>显然这不是 <em>真的</em> 违反规则，除非如果我们得到了<code>None</code>，而实际上并没有从 map 上借用任何东西。</p>
<p>有各种丑陋的解决方法:</p>
<pre><code class="language-Rust">let mut found = false;
if let Some(r) = m.get_mut(&quot;one&quot;) {
    *r = 10;
    found = true;
}
if ! found {
    m.insert(&quot;one&quot;, 1);
}
</code></pre>
<p>这很糟糕，但它起作用，因为烦人的借用保留在第一个 if 语句中。</p>
<p>这里更好的方法是使用<code>HashMap</code>的<a href="https://doc.rust-lang.org/std/collections/hash_map/enum.Entry.html">entry API</a>.</p>
<pre><code class="language-Rust">use std::collections::hash_map::Entry;

match m.entry(&quot;one&quot;) {
    Entry::Occupied(e) =&gt; {
        *e.into_mut() = 10;
    },
    Entry::Vacant(e) =&gt; {
        e.insert(1);
    }
};
</code></pre>
<p>当 <em>非词汇生命周期</em> 在今年(2018)某个时候到达, 借用检查器获得更少的挫败感。</p>
<p>借用检查器 <em>还是</em> 了解一些重要的案例，然而。 如果你有一个结构，字段可以独立借用。所以组合构造是你的朋友; 一个大结构体应该包含更小的结构体，它们有自己的方法。 定义大结构体上的所有可变方法，会导致你不能修改内容的情况，即使这些方法可能只涉及一个字段。</p>
<p>对于可变数据，有一些独立处理部分数据的特别方法。例如，如果你有一个可变切片，那么<code>split_at_mut</code>将它分成两个可变切片。 这是完全安全的，因为 Rust 知道切片不重叠。</p>
<a class="header" href="#a引用和生命周期" id="a引用和生命周期"><h2>引用和生命周期</h2></a>
<p>Rust 不能允许一个引用长命过值的情况。 否则，我们会有一个”悬挂引用”，它指的是一个已死亡的值 - 一个错误是不可避免的。</p>
<p><code>rustc</code>往往可以对函数的生命周期做出合理的假设:</p>
<pre><code class="language-Rust">fn pair(s: &amp;str, ch: char) -&gt; (&amp;str, &amp;str) {
    if let Some(idx) = s.find(ch) {
        (&amp;s[0..idx], &amp;s[idx+1..])
    } else {
        (s, &quot;&quot;)
    }
}
fn main() {
    let p = pair(&quot;hello:dolly&quot;, ':');
    println!(&quot;{:?}&quot;, p);
}
// (&quot;hello&quot;, &quot;dolly&quot;)
</code></pre>
<p>这是非常安全的，因为我们处理好了未找到分隔符的情况。 <code>rustc</code>在这里假定元组中的两个字符串都是，从作为一个传递给函数参数的字符串中借用的。</p>
<p>明确地说，函数定义如下所示:</p>
<pre><code class="language-Rust">fn pair&lt;'a&gt;(s: &amp;'a str, ch: char) -&gt; (&amp;'a str, &amp;'a str) {...}
</code></pre>
<p><code>'a</code>符号表示输出字符串活得 <em>至少与输入字符串一样长</em> 。这并不是说一样的生命周期，我们可以在任何时候放弃它们(引用)，只是它们无法离开<code>s</code>。</p>
<p>所以，<code>rustc</code>用 <em>生命周期免写</em>，使常见案例更漂亮。</p>
<p>现在，如果该函数收到 <em>两个</em> 字符串，那么您需要明确地进行生命周期注释，来告诉 Rust 哪个输出字符串是从哪个输入字符串中借用的。</p>
<p>当一个结构借用一个引用时，你总是需要一个明确的生命周期:</p>
<pre><code class="language-Rust">struct Container&lt;'a&gt; {
    s: &amp;'a str
}
</code></pre>
<p>这再次坚称，结构不能长命过引用。 对于结构和函数，生命周期都需要在<code>&lt;&gt;</code>中声明，当作一个类型参数。</p>
<p>闭包是非常方便和强大的功能 - Rust 迭代器的很多强大之处都来自它们。但是如果你存储它们，你必须指定一个生命周期。 这是因为闭包基本上是一个可以调用，已生成的结构，并且默认情况下，是借用它的环境。这里的<code>linear</code>闭包有不可变的引用<code>m</code>和<code>c</code>。</p>
<pre><code class="language-Rust">let m = 2.0;
let c = 0.5;

let linear = |x| m*x + c; // 借用/引用
let sc = |x| m*x.cos()
...
</code></pre>
<p><code>linear</code>和<code>sc</code>都为<code>Fn(x: f64)-&gt;f64</code>类型，但他们是 <em>不是</em> 同类 - 他们有不同的类型和大小! 所以要存储它们，你必须做出一个<code>Box&lt;Fn(x: f64)-&gt;f64 + 'a&gt;</code>。</p>
<p>非常烦人，如果你习惯了 JavaScript 或 Lua 的流畅闭包，但 C ++与 Rust 类似，同样需要<code>std::function</code>存储不同的闭包，给虚拟调用一点点惩罚。</p>
<a class="header" href="#a字符串" id="a字符串"><h2>字符串</h2></a>
<p>在开始时，经常会对 Rust 字符串感到恼火。 有不同的方式来创建它们。但感觉它们都冗长:</p>
<pre><code class="language-Rust">let s1 = &quot;hello&quot;.to_string();
let s2 = String::from(&quot;dolly&quot;);
</code></pre>
<p>“hello” 不是 <em>已经是</em> 一个字符串? 好吧，在某种程度上。 <code>String</code>是一个具有 <em>所有权</em> 字符串，分配在堆上; 字符串字面量”hello”是<code>&amp;str</code>类型的 (”字符串切片”) ，并可能被烘焙到可执行文件 (”静态”) 或从一个<code>String</code>借用而来的。 系统语言需要这种区别 - 考虑一个微型微控制器，它有 一点 RAM 和更多的 ROM 。 字面字符串将被存储在 ROM (”只读”) 中 ，这既便宜又更少功耗。</p>
<p>但是 (你可能会说) 在 C ++中，它非常简单啊:</p>
<pre><code class="language-C">std::string s = &quot;hello&quot;;
</code></pre>
<p>是短，但字符串对象真正的创建，被隐藏起来了。 因此, Rust 喜欢<code>to_string</code>明确分配内存。 另一方面，借用(引用)一个 C ++字符串需要<code>c_str</code>，而 C 字符串很蠢。</p>
<p>幸运的是, Rust 的情况更好 - <em>一旦</em> 你接受<code>String</code>和<code>&amp;str</code>两者其实都是必要的。 <code>String</code>的方法主要是为了改变字符串，就像<code>push</code>添加一个字符 (在引擎盖下它非常像一个<code>Vec&lt;u8&gt;</code>)。 但是所有<code>&amp;str</code>的方法也可用。得益于<code>Deref</code>同一机制，一个<code>String</code>可以作为<code>&amp;str</code>类型传递给一个函数 - 这就是为什么你很少看到，在函数中定义<code>&amp;String</code>。</p>
<p>对应各种 trait，有很多方法可以把<code>&amp;str</code>转换为<code>String</code>。 Rust 需要这些 trait 来处理泛型类型。 作为一个经验法则，任何实现<code>Display</code>，也知道<code>to_string</code>，像<code>42.to_string()</code>。</p>
<p>一些操作，可能不会按照直觉行事:</p>
<pre><code class="language-Rust">    let s1 = &quot;hello&quot;.to_string();
    let s2 = s1.clone();
    assert!(s1 == s2);  // cool
    assert!(s1 == &quot;hello&quot;); // fine
    assert!(s1 == &amp;s2); // WTF?
</code></pre>
<p>记得，<code>String</code>和<code>&amp;String</code>是不同的类型，和没有为该组合定义<code>==</code>。这可能会让 C ++ 开发者，感到迷糊，因习惯于引用与数值几乎可以互换。 此外，<code>&amp;s2</code>不会 <em>神奇</em> 成为一个<code>&amp;str</code>， 一个 <em>deref 强制</em> 只在分配到 一个<code>&amp;str</code>变量或参数时，才会发生。 (明确的<code>s2.as_str()</code>能工作。)</p>
<p>但是，这有更值得注意的一个 WTF:</p>
<pre><code class="language-Rust">let s3 = s1 + s2;  // &lt;--- 不行
</code></pre>
<p>你不能连接两个<code>String</code>值，但可以使用<code>&amp;str</code>连接一个<code>String</code>。 此外，您不能使用<code>String</code>连接一个<code>&amp;str</code>。所以大多数人不会使用<code>+</code>，而是使用<code>format!</code>宏，这很方便，但效率不高。</p>
<p>有些字符串操作可用，但工作方式不同。 例如，编程语言通常有一个<code>split</code>方法，能将字符串分解为字符串数组的。Rust 字符串的这个方法，返回一个 <em>迭代器</em> ，你可以 <em>之后</em> 去 <code>collect</code> 成一个 Vec 。</p>
<pre><code class="language-Rust">let parts: Vec&lt;_&gt; = s.split(',').collect();
</code></pre>
<p>如果你急着获取 Vec，这有点笨拙。 但是你可以对这部分进行操作， <em>不用</em> 分配一个 Vec! 例如，split 过程中，最大的字符串的长度?</p>
<pre><code class="language-Rust">let max = s.split(',').map(|s| s.len()).max().unwrap();
</code></pre>
<p>(使用<code>unwrap</code>是因为空迭代器没有最大值，我们必须覆盖这种错误情况。 )</p>
<p>该<code>collect</code>方法返回一个<code>Vec&lt;&amp;str&gt;</code>，其中<code>&amp;str</code>部分是从原始字符串中借用的 - 我们只需要为引用分配内存空间。(这意味着小且固有大小。) 在 C ++中没有像这样的方法，但直到最近才需要单独分配每个子字符串。 (C ++ 17 有<code>std::string_view</code>，其行为像一个 Rust 字符串切片。 )</p>
<a class="header" href="#a关于分号的说明" id="a关于分号的说明"><h2>关于分号的说明</h2></a>
<p>分号是 <em>不是</em> 可选项，但通常，与 C 相同的地方都被省略，例如，在<code>{}</code>代码块之后，他们也不需要<code>enum</code>要么<code>struct</code> (这是一个 C 特性。 )但是，如果该代码块必须有一个 <em>值</em> ，那么分号将被丢弃:</p>
<pre><code class="language-Rust">    let msg = if ok {&quot;ok&quot;} else {&quot;error&quot;};
</code></pre>
<p>请注意，在<code>let</code>声明之后，必须有一个分号在!</p>
<p>如果在<code>x * *</code>字符串之后，加上分号，那么返回的值就是<code>()</code> (像<code>Nothing</code>要么<code>void</code>)。定义函数时常见错误:</p>
<pre><code class="language-Rust">fn sqr(x: f64) -&gt; f64 {
    x * x; //  多了个 分号
}
</code></pre>
<p><code>rustc</code>在这种情况下，会给你一个明确的错误。</p>
<a class="header" href="#a专怼-c-问题" id="a专怼-c-问题"><h2>专怼 C ++问题</h2></a>
<a class="header" href="#rust-值语义是不同的" id="rust-值语义是不同的"><h3>Rust 值语义是不同的</h3></a>
<p>在 C ++中，可以定义，类似原始的类型，并复制它们自己。 另外，可以定义移动构造函数，来指示如何将值移出临时上下文。</p>
<p>在 Rust 里，原始类型的行为和预期一样，但是<code>Copy</code>trait 只能在集合类型 (结构{struct}，元组{tuple}或枚举{enum}) 本身，只包含可复制类型的情况下定义。 任意类型可能有<code>Clone</code>，但你必须使用<code>clone</code>方法。 Rust 要求任何分配都是明确的，不要隐藏在复制构造函数或赋值运算符中。</p>
<p>所以，复制和移动总是被定义为只是 移动位比特，而不是被覆盖。</p>
<p>如果<code>s1</code>不是<code>Copy</code>值类型，像<code>s2 = s1;</code>导致移动发生，而这 <em>消耗</em> <code>s1</code>! 所以，当你真的想要一个副本，使用<code>clone</code>。</p>
<p>借用通常比复制要好，但是你必须遵循借用规则。 幸运的是，借用 <em>是</em> 一个可覆盖的行为。 例如，<code>String</code>可以借用成<code>&amp;str</code>，并共享<code>&amp;str</code>的所有的不可变方法。 <em>字符串切片</em> 比 类似的 C ++”借用{borrowing}”操作，更加强大，C ++ 要运用<code>c_str</code>提取一个<code>const char *</code>。 <code>&amp;str</code>由一个指针，指向一些具有所有权的字节 (或一个字符串字面量) 和 一个 <em>尺寸「size」</em> 组成。 这造就了一些非常有效的内存模式。 你可以有一个<code>Vec&lt;&amp;str&gt;</code>，其中所有的字符串都是从一些底层字符串中借用的 - 你只需要分配该 Vec 内存空间:</p>
<p>例如，按空格拆分:</p>
<pre><code class="language-Rust">fn split_whitespace(s: &amp;str) -&gt; Vec&lt;&amp;str&gt; {
    s.split_whitespace().collect()
}
</code></pre>
<p>同样，一个 C ++ 的 <code>s.substr(0,2)</code>调用将始终复制字符串，但切片只会借用: <code>&amp;s[0..2]</code>.</p>
<p><code>Vec&lt;T&gt;</code>和<code>&amp;[T]</code>之间是一个雷同关系，就像字符串与字符串切片。</p>
<a class="header" href="#a共享引用" id="a共享引用"><h3>共享引用</h3></a>
<p>Rust 有 <em>智能指针</em>，这像 C ++ - 举例，<code>std::unique_ptr</code>相当于是<code>Box</code>。但没必要<code>delete(删除)</code>，因为任何内存或其他资源，在盒子超出作用域时都会被回收 (Rust 非常赞同 RAII)。</p>
<pre><code class="language-Rust">let mut answer = Box::new(&quot;hello&quot;.to_string());
*answer = &quot;world&quot;.to_string();
answer.push('!');
println!(&quot;{} {}&quot;, answer, answer.len());
</code></pre>
<p>起初，人们发现<code>to_string</code>老烦啦，但，确实 <em>明朗</em> 许多。</p>
<!-- HERE -->
<p>注意显式的<code>*</code>取值符号，但智能指针有所不同，它的方法不需要任何特别符号 (我们不用这样写<code>(*answer).push('!')</code>)</p>
<p>显然，只有在原始内容的所有权(者)，被明确定义的情况下，借用才有效。在许多设计中是不可能的。</p>
<p>C ++中，<code>std::shared_ptr</code>用处是; 仅复制，那修改公用数据的引用计数。然而，这并不是没有成本的:</p>
<ul>
<li>即使数据是只读的，不断修改引用计数也会导致缓存失效。</li>
<li><code>std::shared_ptr</code>被设计成线程安全的，也带来了锁定开销。</li>
</ul>
<p>在 Rust 中的<code>std::rc::Rc</code>，也像共享智能指针一样，它使用了引用计数。 但是，它仅适用于不可变引用! 如果你想要一个线程安全的变体，请使用<code>std::sync::Arc</code> (’原子(Atomic) Rc’)。 所以， Rust 在提供两种变体方面略显笨拙，但你可以避免非线程操作的锁定开销。</p>
<p>正如上所说，应用的都必须是不可变的引用，因为这是 Rust 内存模型的基础。 但是，有一张权限卡: <code>std::cell::RefCell</code>。 如果您有个共享引用定义为<code>Rc&lt;RefCell&lt;T&gt;&gt;</code>，那么你能用它的<code>borrow_mut</code>方法，获得可变借用。 这使 Rust 借用规则变得 <em>动态</em> 起来 - 除此之外像，已有了借用，任何尝试使用<code>borrow_mut</code>的操作，都会引起恐慌。</p>
<p>权限卡仍然是 <em>安全</em>。 恐慌会在任何内存被不当地触动 <em>之前</em> 发生! 异常情况下，他们展开调用栈。所以对这样一个结构化的回溯过程来说，恐慌是个不好的词 - 因其实这是一种有序的回溯，而不是 恐慌，无序的撤退。</p>
<p>完整的<code>Rc&lt;RefCell&lt;T&gt;&gt;</code>类型，看着不舒服，但应用程序代码并不会不爽。 Rust (再次) 更喜欢明确表示。</p>
<p>如果你想线程安全地访问共享状态，那么<code>Arc&lt;T&gt;</code>是唯一的 <em>安全</em> 道路。如果你需要可变权限，那么<code>Arc&lt;Mutex&lt;T&gt;&gt;</code>会帮到你，相当于<code>Rc&lt;RefCell&lt;T&gt;&gt;</code>。而<code>Mutex</code>与通常定义的方式有点不同: 它是一个值的容器。 在 值 上你得到一个 <em>锁{lock}</em>，然后可以修改它。</p>
<pre><code class="language-Rust">let answer = Arc::new(Mutex::new(10));

// 在其他线程
..
{
  let mut answer_ref = answer.lock().unwrap();
  *answer_ref = 42;
}
</code></pre>
<p>为什么有个<code>unwrap</code>? 因为如果前一个线程恐慌了，那么这个<code>锁</code>就失败。(这是在文档中，<code>unwrap</code>被认为是合理的一个地方，因为显然，事情会走向严重错误，而这时，总要在线程中抓到(unwrap)恐慌。 )</p>
<p>重要的是 (像往常一样使用 Mutex 锁) 这个互斥锁尽可能少地持有。 所以，它们出没在一个有限，短的作用域内是很常见的 - 然后，当可变引用超出作用域时锁定结束。</p>
<p>与 C ++中，显然更简单的情况相比 (<code>use shared*ptr dude</code>)，这 Rust 很不好看，但是，现在任何共享状态的 <em>修改</em> 都变得明显，
还有，“互斥锁{Mutex}”锁定模式会强制线程变得安全。</p>
<p>像所有内容一样，会有使用共享引用的<a href="https://news.ycombinator.com/item?id=11698784">警告</a>。</p>
<a class="header" href="#a迭代器" id="a迭代器"><h3>迭代器</h3></a>
<p>C ++中的迭代器，定义的很不正式;他们涉及到智能指针，通用<code>c.begin()</code>，从头开始并以<code>c.end()</code>结束。迭代器上的操作，稍后实现为独立的模板函数，如<code>std::find_if</code>。</p>
<p>Rust 的迭代器由<code>Iterator</code> trait 定义; <code>next</code>返回一个<code>Option</code>，和当<code>Option</code>是<code>None</code>时，迭代结束了。</p>
<p>最常见的操作正如下所示的方法，这是<code>find_if</code>的等价方法。 它返回一个<code>Option</code> (若是没有发现，就是一个<code>None</code>) 和这里<code>if let</code>语句可以方便地提取非<code>None</code>状态:</p>
<pre><code class="language-Rust">let arr = [10, 2, 30, 5];
if let Some(res) = arr.find(|x| x == 2) {
    // res 是 2
}
</code></pre>
<a class="header" href="#a不安全和链接列表" id="a不安全和链接列表"><h3>不安全和链接列表</h3></a>
<p>Rust stdlib 的某些部分实现使用了<code>unsafe</code>，这不是什么秘密。 这并不妨碍 借用检查员 的传统做法。 要记住的是，”unsafe”具有特别含义 - 表明 Rust 在编译时，无法完全验证的操作。 从 Rust 的角度来看，C ++始终处于不安全的模式! 所以如果一个大的应用程序需要几十行不安全的代码，那很好，因为这些行代码可以仔细检查(明确是 unsafe)。人类可不善于检查 100Kloc +的代码。</p>
<p>我提到这一点的原因，是因为似乎有一种行为模式: 一个有经验的 C ++人 试图实现 链表或树结构，不过沮丧收场。 那么，一个双链表 <em>是</em> 可能符合安全 Rust 的，秘密在于<code>Rc</code>引用前进，和<code>Weak</code>引用回退。 但是标准库仍能获得了更多的性能，若是不用...指针（But the
standard library gets more performance out of using... pointers.）。</p>

                </main>

                <nav class="nav-wrapper" aria-label="Page navigation">
                    <!-- Mobile navigation buttons -->
                    
                    <a rel="prev" href="nom-intro.zh.html" class="mobile-nav-chapters previous" title="Previous chapter"
                        aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    

                    

                    <div style="clear: both"></div>
                </nav>
            </div>
        </div>

        <nav class="nav-wide-wrapper" aria-label="Page navigation">
            
            <a href="nom-intro.zh.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter"
                aria-keyshortcuts="Left">
                <i class="fa fa-angle-left"></i>
            </a>
            

            
        </nav>

    </div>

    

    
    <!-- Google Analytics Tag -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-128555056-1"></script>
    
    <script type="text/javascript">
        var localAddrs = ["localhost", "127.0.0.1", ""];
        if (localAddrs.indexOf(document.location.hostname) === -1) {
            window.dataLayer = window.dataLayer || [];
            function gtag() { dataLayer.push(arguments); }
            gtag('js', new Date());

            gtag('config', 'UA-128555056-1');
        }
    </script>
    

    

    
    <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
    

    <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
    <script src="book.js" type="text/javascript" charset="utf-8"></script>

    <!-- Custom JS scripts -->
    

    

</body>

</html>