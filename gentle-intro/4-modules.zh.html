<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>模块和货物 - Rust 的绅士介绍</title>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="Rust语言，标准库和生态系统介绍">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="shortcut icon" href="favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
    <link rel="stylesheet" href="css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"
        rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    

    
</head>

<body class="light">
    <!-- Provide site root to javascript -->
    <script type="text/javascript">var path_to_root = "";</script>

    <!-- Work around some values being stored in localStorage wrapped in quotes -->
    <script type="text/javascript">
        try {
            var theme = localStorage.getItem('mdbook-theme');
            var sidebar = localStorage.getItem('mdbook-sidebar');

            if (theme.startsWith('"') && theme.endsWith('"')) {
                localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
            }

            if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
            }
        } catch (e) { }
    </script>

    <!-- Set the theme before any content is loaded, prevents flash -->
    <script type="text/javascript">
        var theme;
        try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
        if (theme === null || theme === undefined) { theme = 'light'; }
        document.body.className = theme;
        document.querySelector('html').className = theme + ' js';
    </script>

    <!-- Hide / unhide sidebar before it is displayed -->
    <script type="text/javascript">
        var html = document.querySelector('html');
        var sidebar = 'hidden';
        if (document.body.clientWidth >= 1080) {
            try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
            sidebar = sidebar || 'visible';
        }
        html.classList.remove('sidebar-visible');
        html.classList.add("sidebar-" + sidebar);
    </script>

    <nav id="sidebar" class="sidebar" aria-label="Table of contents">
        <ol class="chapter"><li class="affix"><a href="readme.zh.html">介绍</a></li><li><a href="1-basics.zh.html"><strong aria-hidden="true">1.</strong> 基本</a></li><li><a href="2-structs-enums-lifetimes.zh.html"><strong aria-hidden="true">2.</strong> 结构,枚举和匹配</a></li><li><a href="3-filesystem.zh.html"><strong aria-hidden="true">3.</strong> 文件系统和进程</a></li><li><a href="4-modules.zh.html" class="active"><strong aria-hidden="true">4.</strong> 模块和货物</a></li><li><a href="5-stdlib-containers.zh.html"><strong aria-hidden="true">5.</strong> 标准库容器</a></li><li><a href="6-error-handling.zh.html"><strong aria-hidden="true">6.</strong> 错误处理</a></li><li><a href="7-shared-and-networking.zh.html"><strong aria-hidden="true">7.</strong> 线程,网络和共享</a></li><li><a href="object-orientation.zh.html"><strong aria-hidden="true">8.</strong> 面向对象编程</a></li><li><a href="nom-intro.zh.html"><strong aria-hidden="true">9.</strong> 用nom解析</a></li><li><a href="pain-points.zh.html"><strong aria-hidden="true">10.</strong> 痛点</a></li></ol>
    </nav>

    <div id="page-wrapper" class="page-wrapper">

        <div class="page">
            
            <div id="menu-bar" class="menu-bar">
                <div id="menu-bar-sticky-container">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                            aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <!-- START - Rust Cookbook customization -->
                        <button id="edit-button" class="icon-button" type="button" title="Fork and edit" aria-label="Fork and edit"
                            aria-haspopup="true" aria-expanded="false" aria-controls="edit">
                            <i class="fa fa-edit">Edit</i>
                        </button>
                        <!-- END - Rust Cookbook customization -->
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme"
                            aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                            aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Rust 的绅士介绍</h1>
                    
                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

            
            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                        aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>
            

            <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
            <script type="text/javascript">
                document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                    link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                });
            </script>

            <!-- // START - Rust Cookbook customization -->
            <script>
                document.getElementById("edit-button").addEventListener("click", function () {
                    var editWindow = window.open("https://github.com/chinanf-boy/gentle-intro/edit/master/src/4-modules.zh.md");
                });</script>
            <!-- // END - Rust Cookbook customization -->

            <div id="content" class="content">
                <main>
                    <a class="header" href="#a模块和-cargo" id="a模块和-cargo"><h1>模块和 Cargo</h1></a>
<a class="header" href="#a目录" id="a目录"><h2>目录</h2></a>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<ul>
<li><a href="#%E6%A8%A1%E5%9D%97">模块</a></li>
<li><a href="#crates">Crates</a></li>
<li><a href="#cargo">Cargo</a></li>
<li><a href="#%E6%9B%B4%E5%A4%9A%E7%9A%84%E5%AE%9D%E8%97%8F">更多的宝藏</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<a class="header" href="#a模块" id="a模块"><h2>模块</h2></a>
<p>随着程序变得越来越大，有必要将它们分散到多个文件中，和将函数和类型放在不同的 <em>命名空间</em>。 这些问题的 Rust 解决方案就是 <em>模块</em>。</p>
<p>C 语言 吃了第一个螃蟹，而不是第二个，所以你最终会遇到类似<code>primitive_display_set_width</code>的可怕名字等等。实际上，文件名可以任意命名。</p>
<p>Rust 使用的全名看起来像<code>primitive::display::set_width</code>，之后可使用<code>use primitive::display</code>，这样就能用<code>display::set_width</code>代替。 你甚至可以说<code>use primitive::display::set_width</code>，然后只能用<code>set_width</code>，但这并不是一个好方式。 <code>rustc</code>虽然不会混淆，但是 <em>您</em> 稍后可能会感到困惑。为了这个工作，文件名必须遵循一些简单的规则。</p>
<p>一个新的关键字<code>mod</code>，用于将模块定义为，可以写入 Rust 类型或函数的块:</p>
<pre><pre class="playpen"><code class="language-rust">mod foo {
    #[derive(Debug)]
    struct Foo {
        s: &amp;'static str
    }
}

fn main(){
    let f = foo::Foo{s: &quot;hello&quot;};
    println!(&quot;{:?}&quot;, f);
}
</code></pre></pre>
<p>但它仍不正确 - 我们得到’struct Foo is 私人{private}’。 为了解决这个问题，我们需要允许<code>Foo</code>导出的<code>pub</code>关键字。然后错误又变为’结构的 foo::Foo 字段是私人的’，再放了<code>pub</code>后, 能导出<code>Foo::s</code>。事情办好了。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    pub struct Foo {
        pub s: &amp;'static str
    }
#}</code></pre></pre>
<p>一个明确的<code>pub</code>，意味着你必须 <em>选择</em> 哪些内容要通过模块公开。从模块导出的一组函数和类型称为它的 <em>接口{interface}</em>。</p>
<p>隐藏结构内部，通常会更好，并且只允许通过方法访问:</p>
<pre><pre class="playpen"><code class="language-rust">mod foo {
    #[derive(Debug)]
    pub struct Foo {
        s: &amp;'static str
    }

    impl Foo {
        pub fn new(s: &amp;'static str)-&gt; Foo {
            Foo{s: s}
        }
    }
}

fn main(){
    let f = foo::Foo::new(&quot;hello&quot;);
    println!(&quot;{:?}&quot;, f);
}
</code></pre></pre>
<p>为什么隐藏 实现(impl) 是一件好事? 因为这意味着您可以在不中断接口，没有模块使用者太注意其细节的情况下稍后进行更改。 大规模编程的大敌是细节代码纠结的倾向，因此去理解一段一段代码，实际做了什么是不可能的。</p>
<p>在一个完美的世界里，一个模块做一件事，做好，并保持自己的秘密。</p>
<p>何时不要隐藏? 正如 Stroustrup 所说，当接口 <em>为</em> 实现，就像<code>struct Point {x: f32,y: f32}</code>结构要导出。</p>
<p>一个模块 <em>中</em> ，所有的项对所有的其他项都可见。 这是一个舒适的地方，每个人都可以成为朋友，知道彼此的私密细节。</p>
<p>每个人都可以根据自己的喜好，将程序分成不同的文件。我开始对 500 感到不舒服，那就 超过 2000 好了，随你喜欢(或有规定)。</p>
<p>那么如何将这个程序分解成单独的文件呢?</p>
<p>我们把这个<code>foo</code>代码到<code>foo.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// foo.rs
#[derive(Debug)]
pub struct Foo {
    s: &amp;'static str
}

impl Foo {
    pub fn new(s: &amp;'static str)-&gt; Foo {
        Foo{s: s}
    }
}
#}</code></pre></pre>
<p>并在主<code>main</code>程序中，<em>不</em> 在一个<code>区块{}</code>内，使用一个<code>mod foo</code>声明,:</p>
<pre><pre class="playpen"><code class="language-rust">// mod3.rs
mod foo;

fn main(){
    let f = foo::Foo::new(&quot;hello&quot;);
    println!(&quot;{:?}&quot;, f);
}
</code></pre></pre>
<p>现在<code>rustc mod3.rs</code>也会引发<code>foo.rs</code>编译。 没有必要用 makefiles 来搞笑!</p>
<p>编译器也会看<code>MODNAME/mod.rs</code>，所以，如果我创建一个目录<code>boo</code>，其包含一个文件<code>mod.rs</code>，这也会工作:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// boo/mod.rs
pub fn answer()-&gt;u32 {
    42
}
#}</code></pre></pre>
<p>现在主程序可以将两个模块作为单独的文件使用:</p>
<pre><pre class="playpen"><code class="language-rust">// mod3.rs
mod foo;
mod boo;

fn main() {
    let f = foo::Foo::new(&quot;hello&quot;);
    let res = boo::answer();
    println!(&quot;{:?} {}&quot;, f,res);
}
</code></pre></pre>
<p>到目前为止，<code>mod3.rs</code>含有<code>main</code>，一个模块<code>foo.rs</code>和一个含<code>mod.rs</code>的目录<code>boo</code>。 通常的惯例是包含<code>main</code>的文件，就叫<code>main.rs</code>。</p>
<p>为什么有两种可做同样事情的方法? 因为<code>boo/mod.rs</code>，可让<code>boo</code>引用定义的其他模块，更新<code>boo/mod.rs</code>，并添加一个新模块 - 注意导出明确性。(若没有<code>pub</code>，<code>bar</code>只能看看在<code>boo</code>模块里面).</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// boo/mod.rs
pub fn answer()-&gt;u32 {
    42
}

pub mod bar {
    pub fn question()-&gt; &amp;'static str {
        &quot;the meaning of everything&quot;
    }
}
#}</code></pre></pre>
<p>然后，我们有了问题相对应的答案(<code>bar</code>模块在<code>boo</code>里面):</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let q = boo::bar::question();
#}</code></pre></pre>
<p>该模块部分可以被拉到<code>boo/bar.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// boo/bar.rs
pub fn question()-&gt; &amp;'static str {
    &quot;the meaning of everything&quot;
}
#}</code></pre></pre>
<p>和<code>boo/mod.rs</code>变为:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// boo/mod.rs
pub fn answer()-&gt;u32 {
    42
}

pub mod bar;
#}</code></pre></pre>
<p>总之，模块是关于组织和可见性的，这可能涉及或不涉及单独的文件。</p>
<p>请注意<code>use</code>与导入无关，只是指定模块名称的可见性。 例如:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    use boo::bar;
    let q = bar::question();
    ...
}
{
    use boo::bar::question();
    let q = question();
    ...
}
#}</code></pre></pre>
<p>重要的一点是，这里没有 <em>单独编译</em> 说法。 主程序及其模块文件每次都要重新编译。也就是这样，较大的程序需要花费相当长(非常)的时间, 当然<code>rustc</code>的渐进式编译会越来越好。</p>
<a class="header" href="#crates" id="crates"><h2>Crates</h2></a>
<p>Rust 的”编译单位”是 <em>箱子{crate}</em> ，它是一个可执行文件或一个库。</p>
<p>要分别编译上一节中的文件，请先构建<code>foo.rs</code>作为 rust <em>静态库</em> 箱:</p>
<pre><code class="language-bash">src$ rustc foo.rs --crate-type=lib
src$ ls -l libfoo.rlib
-rw-rw-r-- 1 steve steve 7888 Jan  5 13:35 libfoo.rlib
</code></pre>
<p>我们现在可以 <em>链接</em> 这到我们的主要程序中:</p>
<pre><code>src$ rustc mod4.rs --extern foo=libfoo.rlib
</code></pre>
<p>但，主要程序现在必须像这样，这个<code>extern</code>名称与链接时使用的名称相同。有一个隐式的顶级模块<code>foo</code>与 库 crate 相关联:</p>
<pre><pre class="playpen"><code class="language-rust">// mod4.rs
extern crate foo;

fn main(){
    let f = foo::Foo::new(&quot;hello&quot;);
    println!(&quot;{:?}&quot;, f);
}
</code></pre></pre>
<p>在人们开始欢呼’Cargo!Cargo!’之前，让我过一遍这个 Rust 构建的底层环境。我是’Know Thy Toolchain’的忠实信徒, 若我们从一开始就使用 Cargo 管理项目，会减少你需要学习的新魔法数量。模块是基本的语言功能，可用于 Cargo 项目之外。</p>
<p>现在该理解下，为什么 Rust 的二进制文件如此之大:</p>
<pre><code>src$ ls -lh mod4
-rwxrwxr-x 1 steve steve 3,4M Jan  5 13:39 mod4
</code></pre>
<p>这很胖! 因 在该可执行文件中有 <em>许多</em> 调试信息.</p>
<p>这不是一件坏事，如果你想调试，并当你的程序发生混乱时，实际上需要有意义的回溯。那么让我们去除这些调试信息，并查看:</p>
<pre><code>src$ strip mod4
src$ ls -lh mod4
-rwxrwxr-x 1 steve steve 300K Jan  5 13:49 mod4
</code></pre>
<p>对如此简单的事情，尺寸仍感觉有点大，但是这个程序 <em>静态</em> 链接 Rust 标准库。这是一件好事，因为您可以将此可执行文件交给任何具有正确操作系统的人 - 他们不需要”Rust 运行时”，就可以启用该文件。(还有，<code>rustup</code>甚至可以让你根据其他操作系统和平台 进行跨平台编译。 )</p>
<p>我们可以 动态 链接到 Rust 运行时，并获得真正的小:</p>
<pre><code class="language-bash">src$ rustc -C prefer-dynamic mod4.rs --extern foo=libfoo.rlib
src$ ls -lh mod4
-rwxrwxr-x 1 steve steve 14K Jan  5 13:53 mod4
src$ ldd mod4
    linux-vdso.so.1 =&gt; (0x00007fffa8746000)
    libstd-b4054fae3db32020.so =&gt; not found
    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6(0x00007f3cd47aa000)
    /lib64/ld-linux-x86-64.so.2(0x00007f3cd4d72000)
</code></pre>
<p>这’找不到 no found’是因为<code>rustup</code>不会全局安装动态库。 至少在 Unix 上 我们可以用我们的快乐方式破解(是的，我知道最好的解决方案是符号链接)。</p>
<pre><code class="language-bash">src$ export LD_LIBRARY_PATH=~/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib
src$ ./mod4
Foo { s: &quot;hello&quot; }
</code></pre>
<p>Rust 没有动态链接的 <em>玄学</em> 问题，与 Go 一样。 只是当每 6 周发布一个稳定版本时，不得不重新编译所有内容。 如果你有一个适合你的稳定版本，那么很酷。 随着 Rust 的稳定版本更新换代，越来越多地移交给 OS 包管理器控制, 动态链接将变得更加流行。</p>
<a class="header" href="#cargo" id="cargo"><h2>Cargo</h2></a>
<p>与 Java 或 Python 相比，Rust 标准库不是很大。虽然功能 比 C 或 C ++ 更强大，但主要依赖于操作系统提供的库。</p>
<p>但用 <strong>Cargo</strong> 访问<a href="https://crates.io">crates.io</a>社区提供的库很简单。 Cargo 查找正确的版本，并为您下载源代码，并确保下载其他所需的 crate。</p>
<p>我们来创建一个需要 读取 JSON 的简单程序。 这种数据格式的使用非常广泛，但是对于包含在标准库中的数据格式太偏科了。下面我们展示下，我们初始化一个 Cargo 项目，可以不使用’--bin’，因为默认就是创建一个二进制项目。</p>
<pre><code class="language-bash">test$ cargo init --bin test-json
        Created binary(application)project
test$ cd test-json
test$ cat Cargo.toml
[package]
name = &quot;test-json&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.org&gt;&quot;]

[dependencies]
</code></pre>
<p>让项目依赖<a href="http://json.rs/doc/json/">JSON crate</a>，编辑’Cargo.toml’文件,如下所示:</p>
<pre><code class="language-toml">[dependencies]
json=&quot;0.11.4&quot;
</code></pre>
<p>然后用 Cargo 进行第一次构建:</p>
<pre><code class="language-bash">test-json$ cargo build
Updating registry `https://github.com/rust-lang/crates.io-index`
Downloading json v0.11.4
Compiling json v0.11.4
Compiling test-json v0.1.0(file:///home/steve/c/rust/test/test-json)
Finished debug [unoptimized + debuginfo] target(s)in 1.75 secs
</code></pre>
<p>在用 Cargo 初始化这个项目的时候，主文件已经被 <em>创建</em> , 它是’src’目录中的’main.rs’。 开始时，只是一个’你好世界’的应用程序，现在让它变成一个适当的测试程序。</p>
<p>请注意，非常方便的’原始{raw}’字符串字面量的使用 - 否则我们需要转义那些双引号，一段丑陋的格式：</p>
<pre><pre class="playpen"><code class="language-rust">// test-json/src/main.rs
extern crate json;

fn main(){
    let doc = json::parse(r#&quot;
    {
        &quot;code&quot;: 200,
        &quot;success&quot;: true,
        &quot;payload&quot;: {
            &quot;features&quot;: [
                &quot;awesome&quot;,
                &quot;easyAPI&quot;,
                &quot;lowLearningCurve&quot;
            ]
        }
    }
    &quot;#).expect(&quot;parse failed&quot;);

    println!(&quot;debug {:?}&quot;, doc);
    println!(&quot;display {}&quot;, doc);
}
</code></pre></pre>
<p><code>main.rs</code>改好后，您现在编译和运行此项目.</p>
<pre><code class="language-bash">test-json$ cargo run
    Compiling test-json v0.1.0(file:///home/steve/c/rust/test/test-json)
    Finished debug [unoptimized + debuginfo] target(s)in 0.21 secs
        Running `target/debug/test-json`
debug Object(Object { store: [(&quot;code&quot;, Number(Number { category: 1, exponent: 0, mantissa: 200 }),
    0, 1),(&quot;success&quot;, Boolean(true), 0, 2),(&quot;payload&quot;, Object(Object { store: [(&quot;features&quot;,
    Array([Short(&quot;awesome&quot;), Short(&quot;easyAPI&quot;), Short(&quot;lowLearningCurve&quot;)]), 0, 0)] }), 0, 0)] })
display {&quot;code&quot;:200,&quot;success&quot;:true,&quot;payload&quot;:{&quot;features&quot;:[&quot;awesome&quot;,&quot;easyAPI&quot;,&quot;lowLearningCurve&quot;]}}
</code></pre>
<p>调试(debug)输出了 JSON 文档的一些内部细节，而用，一个普通的”{}”，使用了<code>Display</code> trait，从解析的文档重生成 JSON。</p>
<p>我们来探索一下 JSON API。 如果我们无法提取数值，这将毫无用处。 该<code>as_TYPE</code>方法会返回<code>Option&lt;TYPE&gt;</code>, 因为我们无法确定该字段是否存在或是否属于正确类型。 (见<a href="http://json.rs/doc/json/enum.JsonValue.html"> JsonValue 的文档</a>)</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let code = doc[&quot;code&quot;].as_u32().unwrap_or(0);
    let success = doc[&quot;success&quot;].as_bool().unwrap_or(false);

    assert_eq!(code, 200);
    assert_eq!(success, true);

    let features = &amp;doc[&quot;payload&quot;][&quot;features&quot;];
    for v in features.members(){
        println!(&quot;{}&quot;, v.as_str().unwrap()); // MIGHT explode
    }
    // awesome
    // easyAPI
    // lowLearningCurve
#}</code></pre></pre>
<p><code>features</code>这里是一个<code>JsonValue</code>引用 - 它必须是一个引用，否则我们会试图移动一个 <em>值</em> ，这会脱离 JSON。这里我们知道它是一个数组，所以<code>members()</code>将返回一个非空的<code>&amp;JsonValue</code>迭代器。</p>
<p>如果”payload”对象没有”features”键，该怎么办? 那么<code>features</code>将被设置为<code>Null</code>。 不会有爆炸。 这种便利表达了 JSON 的自由表达任何东西的本质。 如果结构不匹配，您应该检查收到的任何文档结构，并创建自己的错误。</p>
<p>如果我们有<code>let mut doc</code>，您可以修改这些结构。记得加上 expect:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let features = &amp;mut doc[&quot;payload&quot;][&quot;features&quot;];
    features.push(&quot;cargo!&quot;).expect(&quot;couldn't push&quot;);
#}</code></pre></pre>
<p>如果<code>feature</code>不是一个数组，该<code>push</code>将失败，因此它 panic。</p>
<p>使用一个宏，来生成 <em>JSON 字面量</em>，漂亮:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let data = object!{
        &quot;name&quot;    =&gt; &quot;John Doe&quot;,
        &quot;age&quot;     =&gt; 30,
        &quot;numbers&quot; =&gt; array![10,53,553]
    };
    assert_eq!(
        data.dump(),
        r#&quot;{&quot;name&quot;:&quot;John Doe&quot;,&quot;age&quot;:30,&quot;numbers&quot;:[10,53,553]}&quot;#
    );
#}</code></pre></pre>
<p>为了这个宏工作，你需要显式地从 JSON 箱导入宏 :</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[macro_use]
extern crate json;
#}</code></pre></pre>
<p>由于 JSON 的无定形，动态性质 和 Rust 的结构化，静态性质之间的不匹配，使用这个 crate 有一个缺点。 (readme 明确提到’有摩擦{friction}’)，所以如果你 <em>确</em> 要将 JSON 映射到 Rust 数据结构，您最终会做很多检查，因为您不能认为接收到的结构与您的结构相匹配! 为此，更好的解决方案是<a href="https://github.com/serde-rs/json">serde_json</a>， 它可以将 Rust 数据结构 <em>序列化</em> 为 JSON ，和 JSON <em>反序列化</em> 到 Rust。</p>
<p>为此，请创建另一个 Cargo 二进制项目<code>Cargo new --bin test-serde-json</code>，进入<code>test-serde-json</code>目录和编辑<code>Cargo.toml</code>。 像这样编辑它:</p>
<pre><code class="language-toml">[dependencies]
serde=&quot;0.9&quot;
serde_derive=&quot;0.9&quot;
serde_json=&quot;0.9&quot;
</code></pre>
<p>并编辑<code>src/main.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate serde_derive;
extern crate serde_json;

#[derive(Serialize, Deserialize, Debug)]
struct Person {
    name: String,
    age: u8,
    address: Address,
    phones: Vec&lt;String&gt;,
}

#[derive(Serialize, Deserialize, Debug)]
struct Address {
    street: String,
    city: String,
}

fn main(){
    let data = r#&quot; {
     &quot;name&quot;: &quot;John Doe&quot;, &quot;age&quot;: 43,
     &quot;address&quot;: {&quot;street&quot;: &quot;main&quot;, &quot;city&quot;:&quot;Downtown&quot;},
     &quot;phones&quot;:[&quot;27726550023&quot;]
    } &quot;#;
    let p: Person = serde_json::from_str(data).expect(&quot;deserialize error&quot;);
    println!(&quot;Please call {} at the number {}&quot;, p.name, p.phones[0]);

    println!(&quot;{:#?}&quot;,p);
}
</code></pre></pre>
<p>你之前已经看到了<code>derive</code>属性，但是<code>serde_derive</code> crate 为特有的<code>Serialize</code>和<code>Deserialize</code> trait ，定义了 <em>自定义派生{custom derives}</em>。生成的 Rust 结构体结果:</p>
<pre><code class="language-json">Please call John Doe at the number 27726550023
Person {
    name: &quot;John Doe&quot;,
    age: 43,
    address: Address {
        street: &quot;main&quot;,
        city: &quot;Downtown&quot;
    },
    phones: [
        &quot;27726550023&quot;
    ]
}
</code></pre>
<p>现在，如果你使用了<code>json</code>，那么你需要几百行的自定义转换代码，主要是错误处理。 单调乏味，容易搞砸，这些都不是你想要付出努力的地方。</p>
<p>如果，你想从外部来源处理结构良好的 JSON (如果需要，可以重新映射字段名称)，<code>serde</code>显然是最好的解决方案，并为 Rust 程序通过网络与其他程序共享数据提供了一个强大的方法(因为如今一切都能理解 JSON)。 关于<code>serde</code>很酷的事情(名字来源于，SERialization:序列化 DEserialization: 反序列化 的 大写字母)是支持其他文件格式，例如<code>toml</code>，这是 cargo 中常用的配置友好格式。 因此，您的程序可以将 <code>.toml</code> 文件读入结构中，并将这些结构编写为<code>.json</code>。</p>
<p>序列化是一项重要的技术，Java 和 Go 存在类似的解决方案 ，但有很大的不同。 在这些语言中，数据的结构可以在 <em>运行时</em> 运用 <em>反射</em> 找到，但现这情况，序列化代码是在 <em>编译时</em>- 更高效!</p>
<p>Cargo 被认为是 Rust 生态系统的一大优势，因为它为我们做了很多工作。 否则，我们不得不从 Github 下载这些库，构建为 静态库-crate ，并将它们与程序链接。 这对于 C ++ 项目来说是很痛苦的，如果 Cargo 不存在的话，Rust 项目相当于痛苦 C++ 本身。 C ++ 的痛苦中带点独特，所以我们应该将它与其他语言的包管理器进行比较。 npm(用于 JavaScript) 和 pip(用于 Python) 为您管理依赖关系和下载， 但分发流程更难，因为程序的用户需要安装 NodeJS 或 Python。 但 Rust 程序与它们的 依赖关系 是静态链接的，所以它们可以在没有外部依赖的情况下，再次发给你的好友。</p>
<a class="header" href="#a更多的宝藏" id="a更多的宝藏"><h2>更多的宝藏</h2></a>
<p>处理除简单文本以外的任何内容时，正则表达式使您的生活变得更加轻松。 这通常适用于大多数语言，在这里假定你对正则表示法有基本的了解。 使用<a href="https://github.com/rust-lang/regex">正则表达式</a>, 把”regex =”0.2.1”’放在”[dependencies]”在您的 Cargo.toml。</p>
<p>我们将再次使用”raw 字符串”，以便反斜杠不必转义。 在中文，这个正则表达式意思是 “完全匹配两个数字，后接字符’:’，再是任意数字。共捕获两组数字”:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate regex;
use regex::Regex;

let re = Regex::new(r&quot;(\d{2}):(\d+)&quot;).unwrap();
println!(&quot;{:?}&quot;, re.captures(&quot;  10:230&quot;));
println!(&quot;{:?}&quot;, re.captures(&quot;[22:2]&quot;));
println!(&quot;{:?}&quot;, re.captures(&quot;10:x23&quot;));
// Some(Captures({0: Some(&quot;10:230&quot;), 1: Some(&quot;10&quot;), 2: Some(&quot;230&quot;)}))
// Some(Captures({0: Some(&quot;22:2&quot;), 1: Some(&quot;22&quot;), 2: Some(&quot;2&quot;)}))
// None
#}</code></pre></pre>
<p>成功的产出实际上有三个 <em>捕获</em> 项 - 全匹配，和两组数字。 默认情况下这些正则表达式不是 <em>确定的</em> ， 所以 <em>正则表达式</em> 将捕第一个出现的匹配，跳过任何不匹配的东西。 (如果你遗漏了’()’，它只会给我们全匹配。 )</p>
<p>可以 <em>命名</em> 那些捕捉项，并且将正则表达式分散在多行，甚至包括注释! 编译正则表达式可能会失败(第一个 <em>expect</em>)或者匹配可能失败(第二个 <em>expect</em>)。 在这里，我们可以使用结果作为关联数组，并按名称查找。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let re = Regex::new(r&quot;(?x)
(?P&lt;year&gt;\d{4}) # the year
-
(?P&lt;month&gt;\d{2})# the month
-
(?P&lt;day&gt;\d{2})  # the day
&quot;).expect(&quot;bad regex&quot;);
let caps = re.captures(&quot;2010-03-14&quot;).expect(&quot;match failed&quot;);

assert_eq!(&quot;2010&quot;, &amp;caps[&quot;year&quot;]);
assert_eq!(&quot;03&quot;, &amp;caps[&quot;month&quot;]);
assert_eq!(&quot;14&quot;, &amp;caps[&quot;day&quot;]);
#}</code></pre></pre>
<p>正则表达式可以分解符合模式的字符串，但不会检查它们是否有意义。 也就是说，你可以指定和匹配的 ISO <em>语法</em> 风格的日期，但 <em>语义</em> 可能是无稽之谈，比如”2014-24-52”。</p>
<p>为此，您需要专门的日期时间处理，由<a href="https://github.com/lifthrasiir/rust-chrono">计时 chrono</a>提供。 你或需要做日期时，决定一个时区:</p>
<pre><pre class="playpen"><code class="language-rust">extern crate chrono;
use chrono::*;

fn main(){
    let date = Local.ymd(2010,3,14);
    println!(&quot;date was {}&quot;, date);
}
// date was 2010-03-14+02:00
</code></pre></pre>
<p>但是，这不推荐，因为喂它不好的日期会导致恐慌!(尝试一个假日期)你需要的方法是 <code>ymd_opt</code>，其返回<code>LocalResult&lt;Date&gt;</code>。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let date = Local.ymd_opt(2010,3,14);
    println!(&quot;date was {:?}&quot;, date);
    // date was Single(2010-03-14+02:00)

    let date = Local.ymd_opt(2014,24,52);
    println!(&quot;date was {:?}&quot;, date);
    // date was None
#}</code></pre></pre>
<p>您还可以直接解析日期时间，无论是以 标准 UTC 格式 还是 使用自定义<a href="https://lifthrasiir.github.io/rust-chrono/chrono/format/strftime/index.html#specifiers">格式{formats}</a> 这些完全相同的的格式允许您， 按照想要的格式打印日期。 我特别强调了这两个有用的 crate ，因为它们将成为大多数其他语言的标准库的一部分。</p>
<p>事实上，这些 crate 的胚胎形态曾经是 Rust stdlib 的一部分，但被切开了。这是个有意的决定: Rust 团队非常重视 stdlib 的稳定性，所以只有在不稳定的夜间版本诞生，而后活过 beta 和 stable 的功能才能保持稳定。 对于需要实验和改进的 库 来说，他们保持独立，并且 Cargo 能够跟踪会更好。 出于所有实际原因，这两个 crate 会是 <em>标准</em> ，它们不会消失，并且可能会在某个时候折回到 stdlib 中。</p>

                </main>

                <nav class="nav-wrapper" aria-label="Page navigation">
                    <!-- Mobile navigation buttons -->
                    
                    <a rel="prev" href="3-filesystem.zh.html" class="mobile-nav-chapters previous" title="Previous chapter"
                        aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    

                    
                    <a rel="next" href="5-stdlib-containers.zh.html" class="mobile-nav-chapters next" title="Next chapter"
                        aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                    

                    <div style="clear: both"></div>
                </nav>
            </div>
        </div>

        <nav class="nav-wide-wrapper" aria-label="Page navigation">
            
            <a href="3-filesystem.zh.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter"
                aria-keyshortcuts="Left">
                <i class="fa fa-angle-left"></i>
            </a>
            

            
            <a href="5-stdlib-containers.zh.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter"
                aria-keyshortcuts="Right">
                <i class="fa fa-angle-right"></i>
            </a>
            
        </nav>

    </div>

    

    
    <!-- Google Analytics Tag -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-128555056-1"></script>
    
    <script type="text/javascript">
        var localAddrs = ["localhost", "127.0.0.1", ""];
        if (localAddrs.indexOf(document.location.hostname) === -1) {
            window.dataLayer = window.dataLayer || [];
            function gtag() { dataLayer.push(arguments); }
            gtag('js', new Date());

            gtag('config', 'UA-128555056-1');
        }
    </script>
    

    

    
    <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
    

    <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
    <script src="book.js" type="text/javascript" charset="utf-8"></script>

    <!-- Custom JS scripts -->
    

    

</body>

</html>