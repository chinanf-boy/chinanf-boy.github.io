<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust 的绅士介绍</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Rust语言，标准库和生态系统介绍">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="_FontAwesome/css/font-awesome.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="readme.zh.html">介绍</a></li><li><a href="1-basics.zh.html"><strong aria-hidden="true">1.</strong> 基本</a></li><li><a href="2-structs-enums-lifetimes.zh.html"><strong aria-hidden="true">2.</strong> 结构,枚举和匹配</a></li><li><a href="3-filesystem.zh.html"><strong aria-hidden="true">3.</strong> 文件系统和进程</a></li><li><a href="4-modules.zh.html"><strong aria-hidden="true">4.</strong> 模块和货物</a></li><li><a href="5-stdlib-containers.zh.html"><strong aria-hidden="true">5.</strong> 标准库容器</a></li><li><a href="6-error-handling.zh.html"><strong aria-hidden="true">6.</strong> 错误处理</a></li><li><a href="7-shared-and-networking.zh.html"><strong aria-hidden="true">7.</strong> 线程,网络和共享</a></li><li><a href="object-orientation.zh.html"><strong aria-hidden="true">8.</strong> 面向对象编程</a></li><li><a href="nom-intro.zh.html"><strong aria-hidden="true">9.</strong> 用nom解析</a></li><li><a href="pain-points.zh.html"><strong aria-hidden="true">10.</strong> 痛点</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Rust 的绅士介绍</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="print.html#a绅士地介绍-rust" id="a绅士地介绍-rust"><h1>绅士地介绍 Rust</h1></a>
<p><img src="PPrustS.png" alt="Rust" /></p>
<p><a href="http://leftoversalad.com/c/015_programmingpeople/">感谢大卫马里诺-David Marino </a></p>
<a class="header" href="print.html#a为什么学习一种新的编程语言" id="a为什么学习一种新的编程语言"><h2>为什么学习一种新的编程语言?</h2></a>
<p>本教程的目标是带您到一个可以读取和写入 Rust 的地方,充分了解在线提供的优质学习资源,特别是<a href="https://doc.rust-lang.org/stable/book/">这本书</a>这是一个机会 <em>先试后买</em>,并且要充分感受到语言的力量想要更深入.</p>
<p>正如爱因斯坦可能会说的那样,&quot;尽可能简单,但没有慢. &quot;这里有很多新东西要学习,而且不同的是需要重新安排你的心理家具. 通过'gentle'我的意思是这些特征实际上是用实例来表示的;</p>
<p>当我们遇到困难时,我希望了解 Rust 如何解决这些问题. 在解决方案有意义之前理解问题非常重要. 用绚丽的语言说,我们要去一个加拿大的山地国家,我会在路上指出一些有趣的岩层,只有几个地质讲座. 会有一些上坡,但这种看法会令人鼓舞;社区是异常愉快和高兴的帮助<a href="https://users.rust-lang.org/">rust 用户论坛</a>和一个活跃的<a href="https://www.reddit.com/r/rust/">Sub reddit</a>这是非常适度的 gentle <a href="https://www.rust-lang.org/en-US/faq.html">常问问题</a>如果你有特定的问题,这是一个很好的资源.</p>
<p>首先,为什么要学习一门新的编程语言? 这是时间和精力的投资,需要一些理由. 即使你没有立即用这种语言找到一份很酷的工作,它也会延伸你的心理肌肉,并使你成为程序员. 这似乎是一种糟糕的投资回报,但是如果你不一直学习一些 <em>真正的</em> 东西,那么你会停滞不前,并且要有十年的经验,一遍又一遍地做同样的事情.</p>
<a class="header" href="print.html#rust的样子" id="rust的样子"><h2>Rust的样子</h2></a>
<p>Rust 是一种静态和强类型的系统编程语言. <em>静态</em> 意味着所有类型在编译时都是已知的,<em>强类型</em> 意味着这些类型的设计使得编写不正确的程序变得更加困难. 成功的汇编意味着你比牛仔语言更好地保证正确性. <em>系统</em> 意味着通过完全控制内存使用来生成最佳机器码. 所以这些用途非常硬: 操作系统,设备驱动程序和甚至可能没有操作系统的嵌入式系统. 然而,编写普通的应用程序代码实际上也是一种非常愉快的语言.</p>
<p>与 C 和 C ++的最大区别在于 Rust <em>安全默认</em>;所有内存访问都会被检查. 不可能因意外而损坏存储器.</p>
<p>Rust 背后的统一原则是:</p>
<ul>
<li>严格执行 <em>安全借用</em> 数据的</li>
<li>函数,方法和闭包来操作数据</li>
<li>元组,结构和枚举来聚合数据</li>
<li>模式匹配来选择和解构数据</li>
<li>trait 来定义 <em>行为</em> 数据</li>
</ul>
<p>通过 Cargo 可以有一个快速增长的可用库生态系统,我们将通过学习使用标准库来关注语言的核心原则. 我的建议是写 <em>很多小例子</em>,所以学习使用<code>rustc</code>直接是核心技能. 当我在这段旅程中做示例时,我定义了一个叫做的小脚本<code>rrun</code>它编译并运行结果:</p>
<pre><code>rustc $1.rs &amp;&amp; ./$1
</code></pre>
<a class="header" href="print.html#a配置" id="a配置"><h2>配置</h2></a>
<p>本教程假设您已在本地安装 Rust . 幸运的是,这是<a href="https://www.rust-lang.org/en-US/downloads.html">非常简单</a>.</p>
<pre><code>$ curl https://sh.rustup.rs -sSf | sh
$ rustup component add rust-docs
</code></pre>
<p>我会建议获取默认的稳定版本; 稍后可以轻松下载不稳定版本并在两者之间切换.</p>
<p>这得到了编译器,库包管理器,API文档和 Rust 书. 千里之行始于一步,而这第一步是无痛的.</p>
<p><code>rustup</code>是您用来管理 Rust 安装的命令. 当一个新的稳定版本出现时,你只需说<code>Rust 更新</code>升级. <code>Rust 文件</code>将在您的浏览器中打开离线文档.</p>
<p>你可能已经拥有了你喜欢的编辑器<a href="https://areweideyet.com/">基本的 Rust 支持</a>很好. 我建议你先从基本的语法高亮开始,随着程序变大,开始工作.</p>
<p>我个人很喜欢<a href="https://www.geany.org/Download/Releases">Geany</a>这是为数不多的具有 Rust 支持的编辑器之一; 它特别易于使用,因为它可以通过软件包管理器获得,但在其他平台上可以正常工作.</p>
<p>最主要的是知道如何编辑,编译和运行防火程序. 你学会用 <em>手指一字一句</em> 你的程序进行编程; 自己键入代码,并学习使用编辑器有效地重新排列事情.</p>
<p>Zed Shaw的<a href="https://learnpythonthehardway.org/book/intro.html">忠告</a>关于在 Python 中学习编程仍然很好,不管语言如何. 他说学会编程就像学习乐器 - 秘诀是练习和坚持. 瑜伽和柔道武术也有很好的建议,比如太极拳,感受紧张,但不要过度紧张. 你不是在这里建立傻瓜肌肉.</p>
<p>我想感谢那些关于我坏英语或坏锈建议的许多贡献者,并且感谢 大卫马力诺-David Marino 对他的 Rust 表现的冷静表达,他是一位友善但硬派的无瑕骑士,闪耀着盔甲.</p>
<p>Steve Donovan © 2017-2018 MIT license version 0.4.0</p>
<a class="header" href="print.html#a基本" id="a基本"><h1>基本</h1></a>
<a class="header" href="print.html#a你好世界" id="a你好世界"><h2>你好,世界!</h2></a>
<p>自从编写第一个C版本以来,&quot;hello world&quot;的最初目的是测试编译器并运行一个实际的程序.</p>
<pre><pre class="playpen"><code class="language-rust">// hello.rs
fn main() {
    println!(&quot;Hello, World!&quot;);
}
</code></pre></pre>
<pre><code>$ rustc hello.rs
$ ./hello
Hello, World!
</code></pre>
<p>Rust是一种带分号的花括号语言, C ++ 风格和一个<code>main</code>函数 - 迄今为止,非常熟悉. <code>感叹号{!}</code>表明这是一个 <em>宏</em> 呼叫. 对于 C ++ 程序员来说,这可能是一个退步,因为它们使用了非常愚蠢的C宏 - 但我可以确保这些宏能够更强大和更理智.</p>
<p>对于其他任何人来说,它可能是&quot;很棒,现在我必须记得何时该说砰!&quot;. 但是,编译器非常有用;如果你忽略了那个惊叹号,你会得到:</p>
<pre><code>error[E0425]: unresolved name `println`
 --&gt; hello2.rs:2:5
  |
2 |     println(&quot;Hello, World!&quot;);
  |     ^^^^^^^ did you mean the macro `println!`?
</code></pre>
<p>学习一门语言意味着要熟悉它的错误. 试着看看编译器是一个严格但友好的帮手而不是电脑 <em>叫喊{shouting}</em> 在你身上,因为你在开始时会看到很多红墨水. 对于编程人员来说,你的程序先炸毁比在实际的人类面前炸毁要好得多.</p>
<p>下一步是介绍一个 <em>变量{variable}</em>:</p>
<pre><pre class="playpen"><code class="language-rust">// let1.rs
fn main() {
    let answer = 42;
    println!(&quot;Hello {}&quot;, answer);
}
</code></pre></pre>
<p>拼写错误是 <em>编译{compile}</em> 错误,而不是类似 Python 或 JavaScript 等动态语言的运行时错误. 这将为您节省很多压力!如果我写了'answr'而不是'answer',编译器实际上是关于它的 <em>不错提示</em> :</p>
<pre><code>4 |     println!(&quot;Hello {}&quot;, answr);
  |                         ^^^^^ did you mean `answer`?
</code></pre>
<p><code>println!</code>宏需要一个<a href="https://doc.rust-lang.org/std/fmt/index.html">格式字符串{format string}</a>和一些 值 ;它与 Python 3使用的格式非常相似.</p>
<p>另一个非常有用的宏是<code>assert_eq!</code>. 这是在Rust中进行测试的主力;您 <em>断言{assert}</em> 两件事必须相等,如果不是,<em>panic{恐慌}</em>.</p>
<pre><pre class="playpen"><code class="language-rust">// let2.rs
fn main() {
    let answer = 42;
    assert_eq!(answer,42);
}
</code></pre></pre>
<p>这不会产生任何输出. 但一旦改变 42 到 40:</p>
<pre><code>thread 'main' panicked at
'assertion failed: `(left == right)` (left: `42`, right: `40`)',
let2.rs:4
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>在 rust 中的  <em>运行时错误</em> .</p>
<a class="header" href="print.html#a循环和条件" id="a循环和条件"><h2>循环和条件</h2></a>
<p>有什么有趣的可以不止一次做:</p>
<pre><pre class="playpen"><code class="language-rust">// for1.rs
fn main() {
    for i in 0..5 {
        println!(&quot;Hello {}&quot;, i);
    }
}
</code></pre></pre>
<p>这 <em>范围{range}</em> 并不是全包括,而是<code>i</code>从0到4. 这是一种语言方便 <em>索引{indexes}</em> 就像从0开始的数组</p>
<p>和有趣的事情要做 <em>有条件地{conditionally}</em>:</p>
<pre><pre class="playpen"><code class="language-rust">// for2.rs
fn main() {
    for i in 0..5 {
        if i % 2 == 0 {
            println!(&quot;even {}&quot;, i);
        } else {
            println!(&quot;odd {}&quot;, i);
        }
    }
}
</code></pre></pre>
<pre><code>even 0
odd 1
even 2
odd 3
even 4
</code></pre>
<p><code>i % 2</code> 被 2 整除; 与 C 很像, 注意条件区域括号的配对</p>
<p>这个做了同样的事情,更有趣的方式写法:</p>
<pre><pre class="playpen"><code class="language-rust">// for3.rs
fn main() {
    for i in 0..5 {
        let even_odd = if i % 2 == 0 {&quot;even&quot;} else {&quot;odd&quot;};
        println!(&quot;{} {}&quot;, even_odd, i);
    }
}
</code></pre></pre>
<p>传统上,编程语言 <em>声明{statements}</em> (喜欢<code>if</code>) 和 <em>表达式{expressions}</em> (喜欢<code>1 + i</code>) . 在 rust 里,几乎所有的东西都有价值并且可以表达. 不需要严重丑陋的 C '三元操作符'<code>i % 2 == 0?&quot;even&quot;: &quot;odd&quot;</code>.</p>
<p>⚠️请注意,这些区域中没有任何分号. <code>{&quot;even&quot;} else {&quot;odd&quot;}</code></p>
<a class="header" href="print.html#a添加事物" id="a添加事物"><h2>添加事物</h2></a>
<p>计算机非常擅长算术. 这是第一次尝试添加从 0到4 的所有数字:</p>
<pre><pre class="playpen"><code class="language-rust">// add1.rs
fn main() {
    let sum = 0;
    for i in 0..5 {
        sum += i;
    }
    println!(&quot;sum is {}&quot;, sum);
}
</code></pre></pre>
<p>但它没有编译:</p>
<pre><code>error[E0384]: re-assignment of immutable variable `sum`
 --&gt; add1.rs:5:9
3 |     let sum = 0;
  |         --- first assignment to `sum`
4 |     for i in 0..5 {
5 |         sum += i;
  |         ^^^^^^^^ re-assignment of immutable variable
</code></pre>
<p>&quot;不可变&quot;? 一个变量不能 <em>变化vary{}</em>? <code>let</code>默认变量只能在声明时赋值. 添加魔术字<code>mut</code> (<em>请</em> 让变量可变) 的诀窍:</p>
<pre><pre class="playpen"><code class="language-rust">// add2.rs
fn main() {
    let mut sum = 0;
    for i in 0..5 {
        sum += i;
    }
    println!(&quot;sum is {}&quot;, sum);
}
</code></pre></pre>
<p>当来自其他语言时,这可能令人费解,其中默认情况下变量可以被重写. 它在运行时被分配了一个计算值到某个&quot;可变&quot;的东西 - 这不是一个 <em>不变{constant}</em>. 这也是这个词在数学中的用法,就像我们说'让 n 是 S 中最大的数字「'let n be the largest number in set S'」'.</p>
<p>声明变量是默认 <em>只读</em> 有原因的. 在更大的程序中,很难跟踪写入的地方. 所以 Rust 能够明确地表现出类似于可变性 ('写入能力') 的东西. 语言中有很多聪明,但它试图不隐藏任何东西.</p>
<p>Rust既是静态类型又是强类型的,它们通常是混淆的,但是考虑 C (静态但弱类型) 和 Python  (动态但强类型) . 在静态类型中,类型在编译时是已知的,而动态类型仅在运行时知道.</p>
<p>然而,此刻,它感觉像是 rust 了. <em>躲藏{hiding}</em> 那些你的类型. 究竟是什么类型? <code>i</code>? 编译器可以从0开始, <em>类型推断</em> 并提出<code>i32</code> (四字节有符号整数) .</p>
<p>让我们做一个改变<code>0</code>到<code>0.0</code>. 然后我们得到错误:</p>
<pre><code>error[E0277]: the trait bound `{float}: std::ops::AddAssign&lt;{integer}&gt;` is not satisfied
 --&gt; add3.rs:5:9
  |
5 |         sum += i;
  |         ^^^^^^^^ the trait `std::ops::AddAssign&lt;{integer}&gt;` is not implemented for `{float}`
  |
</code></pre>
<p>好了,蜜月结束了: 这意味着什么? 每个操作符 (像 <code>+=</code> ) 对应 <em>特质{trait}</em> 而这是一个抽象的接口,必须为每种具体的类型来实现. 稍后我们将详细地处理 trait ,但是这里您需要知道的是<code>附加赋值{AddAssign}</code>实现了该名称<code>+=</code>运算符的 trait ,错误是说浮点数没有实现整数的<code>+=</code>运算符.  (运算符 trait 的完整列表) <a href="https://doc.rust-lang.org/std/ops/index.html">在这里</a>)</p>
<p>同样,Rust喜欢显式, 它不会默默地把那个整数转换成一个浮点数.</p>
<p>我们必须显式地将该值 <em>转换{cast}</em> 为浮点数.</p>
<pre><pre class="playpen"><code class="language-rust">// add3.rs
fn main() {
    let mut sum = 0.0;
    for i in 0..5 {
        sum += i as f64;
    }
    println!(&quot;sum is {}&quot;, sum);
}
</code></pre></pre>
<a class="header" href="print.html#a函数类型是明确的" id="a函数类型是明确的"><h2>函数类型是明确的</h2></a>
<p><em>函数{Functions}</em> 编译器是一个不会离开类型为你工作的地方.</p>
<p>这实际上是一个深思熟虑的决定,因为语言,像 Haskell 拥有强大的类型推断,几乎没有显式的类型名称.</p>
<p>这确实是好 Haskell 风格放在函数的显式类型签名.</p>
<p>这个也是 rust 需要的.</p>
<p>这是一个简单的用户定义函数:</p>
<pre><pre class="playpen"><code class="language-rust">// fun1.rs

fn sqr(x: f64) -&gt; f64 {
    return x * x;
}

fn main() {
    let res = sqr(2.0);
    println!(&quot;square is {}&quot;, res);
}
</code></pre></pre>
<p>Rust返回到了一个
本来的参数声明，其中类型跟在名称后面。 这就像
如何完成的在 Pascal等Algol 派生语言中。</p>
<p>再次，没有整数到浮点数的转换 - 如果你用'2'代替<code>2.0</code>，那么我们
得到一个明确的错误：</p>
<pre><code>8 |     let res = sqr(2);
  |                   ^ expected f64, found integral variable
  |
</code></pre>
<p>你很少会看到函数使用<code>return</code>声明. 更多时候,它会像这样:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn sqr(x: f64) -&gt; f64 {
    x * x
}
#}</code></pre></pre>
<p>这是因为函数的主体（<code>{}</code>内部）具有 <em>最后值</em> ,就像 if-as-an-expression.</p>
<p>由于分号是由人的手指半自动插入的，因此您可以添加它
在 <em>最后值</em> ，并得到以下错误：</p>
<pre><code>  |
3 | fn sqr(x: f64) -&gt; f64 {
  |                       ^ expected f64, found ()
  |
  = note: expected type `f64`
  = note:    found type `()`
help: consider removing this semicolon:
 --&gt; fun2.rs:4:8
  |
4 |     x * x;
  |       ^
</code></pre>
<p>这<code>()</code>类型是空的类型,没有什么结果,<code>无效{void}</code>,0,什么都没有. 一切Rus t都有个值,但有时它就是没有. 编译器知道这是常见的错误,实际上这就是 <em>该死的不寻常的</em> ).</p>
<blockquote>
<p>也就是说, 如果你要返回, 就不能加 <code>分号{;}</code></p>
</blockquote>
<p>这种不能返回表达风格的几个例子:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// absolute value of a floating-point number
fn abs(x: f64) -&gt; f64 {
    if x &gt; 0.0 {
        x
    } else {
        -x
    }
}

// ensure the number always falls in the given range
fn clamp(x: f64, x1: f64, x2: f64) -&gt; f64 {
    if x &lt; x1 {
        x1
    } else if x &gt; x2 {
        x2
    } else {
        x
    }
}
#}</code></pre></pre>
<p>它不是错误的使用<code>return</code>,但没有它,代码就会更干净. 但是对于从一个函数 <em>提前回来</em> , 你仍然会使用<code>return</code>.</p>
<p>一些操作可以被优雅地表达 <em>递归</em>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn factorial(n: u64) -&gt; u64 {
    if n == 0 {
        1
    } else {
        n * factorial(n-1)
    }
}
#}</code></pre></pre>
<p>起初这可能有些奇怪,然后最好用铅笔和纸质材料制作一些例子. 通常不是最多的 <em>高效</em> 的方式. 然而,这样做</p>
<p>值也可以通过 <em>引用</em>. 一个引用是由创建<code>&amp;</code>和 <em>取消引用</em> 通过<code>*</code>.</p>
<pre><pre class="playpen"><code class="language-rust">fn by_ref(x: &amp;i32) -&gt; i32{
    *x + 1
}

fn main() {
    let i = 10;
    let res1 = by_ref(&amp;i);
    let res2 = by_ref(&amp;41);
    println!(&quot;{} {}&quot;, res1,res2);
}
// 11 42
</code></pre></pre>
<p>如果你想要一个函数来修改它的一个参数呢?输入 <em>可变引用</em>:</p>
<pre><pre class="playpen"><code class="language-rust">// fun4.rs

fn modifies(x: &amp;mut f64) {
    *x = 1.0;
}

fn main() {
    let mut res = 0.0;
    modifies(&amp;mut res);
    println!(&quot;res is {}&quot;, res);
}
</code></pre></pre>
<p>这比 C ++ 更像 C ++ . 你必须明确地传递参数 (与<code>&amp;</code>) 和明确 <em>非引用</em> 同<code>*</code>. 然后键入<code>mut</code>, 因为它不是默认的.  (我一直觉得与 C 相比, C++ 引用太容易错过. )</p>
<p>基本上, Rust 是引入一些 <em>摩擦{friction}</em> 这里,并不是那么巧妙地推动函数直接返回值. 幸运的是,  rust 的方式表达了&quot;操作成功,结果就是这样&quot;. <code>mut</code>不需要那么频繁. 当我们有一个大对象并且不想复制它时,传递引用是很重要的.</p>
<p>变量样式后的类型同样适用于<code>let</code>,当你真的想改变变量的类型:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let bigint: i64 = 0;
#}</code></pre></pre>
<a class="header" href="print.html#a学习在哪里找到绳索" id="a学习在哪里找到绳索"><h2>学习在哪里找到绳索</h2></a>
<p>现在是开始使用文档的时候了. 这将安装在您的机器上,您可以使用<code>rustup doc --std</code>在浏览器中打开它.</p>
<p>注意 <em>搜索</em> 在顶部,因为这将是你的朋友;它完全离线运行.</p>
<p>假设我们想知道数学函数在哪里,所以搜索&quot;cos&quot;. 前两个命中显示它为单精度和双精度浮点数字定义. 它定义在 <em>价值本身{value itself}</em> 作为一种方法,像这样:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let pi: f64 = 3.1416;
let x = pi/2.0;
let cosine = x.cos();
#}</code></pre></pre>
<p>结果将是零;我们显然需要一个更权威的 pi-ness!</p>
<p>(为什么我们需要一个明确的<code>f64</code>类型?因为没有它,常数也可以. <code>f32</code>或<code>f64</code>,这些都是非常不同的. )</p>
<p>让我引用的例子<code>cos</code>,但写为一个完整的程序(<code>assert!</code>的表弟<code>assert_eq!</code>;</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 2.0 * std::f64::consts::PI;

    let abs_difference = (x.cos() - 1.0).abs();

    assert!(abs_difference &lt; 1e-10);
}
</code></pre></pre>
<p><code>std::f64::consts::PI</code>是一口子! <code>::</code>意味着同样的在c++中,(通常使用&quot;.&quot;在其他语言) - 这是一个完全合格的名字。 我们得到
这个全名来自第二次搜索“PI”的命中。</p>
<p>到目前为止,我们的小 Rust 项目一直免费<code>import</code>和<code>exclude</code>东西会慢下来的讨论&quot;Hello World&quot;程序. 我们让这个程序可读性更强的<code>use</code>声明:</p>
<pre><pre class="playpen"><code class="language-rust">use std::f64::consts;

fn main() {
    let x = 2.0 * consts::PI;

    let abs_difference = (x.cos() - 1.0).abs();

    assert!(abs_difference &lt; 1e-10);
}
</code></pre></pre>
<p>为什么我们现在不需要这样做？
这是因为 Rust 有助于使许多基本功能无需显示
通过 Rust <em>prelude</em> 显式 <code>use</code> 的使用陈述。</p>
<a class="header" href="print.html#a数组和切片" id="a数组和切片"><h2>数组和切片</h2></a>
<p>所有静态类型的语言都有 <em>数组</em> ,这些 值 包装着鼻子到尾巴的记忆. 数组是 <em>索引</em> 从零开始:</p>
<pre><pre class="playpen"><code class="language-rust">// array1.rs
fn main() {
    let arr = [10, 20, 30, 40];
    let first = arr[0];
    println!(&quot;first {}&quot;, first);

    for i in 0..4 {
        println!(&quot;[{}] = {}&quot;, i,arr[i]);
    }
    println!(&quot;length {}&quot;, arr.len());
}
</code></pre></pre>
<p>输出是:</p>
<pre><code>first 10
[0] = 10
[1] = 20
[2] = 30
[3] = 40
length 4
</code></pre>
<p>在这种情况下,Rust 知道 <em>究竟</em> 阵列有多大,如果你尝试访问<code>arr[4]</code>这将是一个 <em>编译错误</em> .</p>
<p>学习一门新语言往往涉及到 <em>忘却</em> 来自旧语言的已知心理习惯;如果你是一个 Pythonista,那么这些括号表示<code>list</code>. 我们会得到 Rust 的等同物<code>list</code>很快,但数组不是你正在寻找的机器人; 他们是 <em>大小固定</em>. 他们可以 <em>易变的</em> (如果我们问得好) ,但你不能添加新的元素.</p>
<p>在 Rust 中不常使用数组,因为数组的类型包含他们大小. 示例中的数组的类型是<code>[i32;4]</code>;类型<code>[10,20]</code>将会<code>[i32;2]</code>等等: 他们有 <em>不同类型</em>.  所以他们是私生子,作为函数论证.</p>
<p>什么 <em>是</em> 常用的是 <em>切片</em>. 你可以把它们看作是 <em>快照</em> 一个基本的值数组. 它们的行为很像一个数组, <em>知道他们的尺寸</em> 不像那些危险的动物C指针.</p>
<p>注意两个重要的事情 - 如何写一个切片的类型,和你必须使用<code>&amp;</code>将其传递给函数.</p>
<pre><pre class="playpen"><code class="language-rust">// array2.rs
// read as: slice of i32
fn sum(values: &amp;[i32]) -&gt; i32 {
    let mut res = 0;
    for i in 0..values.len() {
        res += values[i]
    }
    res
}

fn main() {
    let arr = [10,20,30,40];
    // look at that &amp;
    let res = sum(&amp;arr);
    println!(&quot;sum {}&quot;, res);
}
</code></pre></pre>
<p>忽略代码<code>sum</code>一阵子,看看<code>[i32]</code>. rust 数组和切片之间的关系类似于 C数组和指针 之间的关系,除了两个重要的区别: rust的切片跟踪它们的大小 (如果你 尝试访问这个大小之外 会 <em>panic</em>) ,并且你必须明确地说你想把数组作为一个切片传递. 使用<code>&amp;</code>操作员.</p>
<p>C程序员发音<code>&amp;</code>作为&quot;地址&quot;,rust程序员会 <em>借用{borrow}</em> 它. 这将是学习 rust 的关键词. 借用是编程中常见的模式的名称;每当你通过引用传递 (几乎总是发生在动态语言中) 或 在C中传递指针时,原始所有者所拥有的任何东西被 <em>借用</em>.</p>
<a class="header" href="print.html#a切片切割" id="a切片切割"><h2>切片切割</h2></a>
<p>不能以通常的方式打印出一个数组. <code>{}</code>但你可以做一个 <em>debug</em> 打印与<code>{:?}</code>.</p>
<pre><pre class="playpen"><code class="language-rust">// array3.rs
fn main() {
    let ints = [1, 2, 3];
    let floats = [1.1, 2.1, 3.1];
    let strings = [&quot;hello&quot;, &quot;world&quot;];
    let ints_ints = [[1, 2], [10, 20]];
    println!(&quot;ints {:?}&quot;, ints);
    println!(&quot;floats {:?}&quot;, floats);
    println!(&quot;strings {:?}&quot;, strings);
    println!(&quot;ints_ints {:?}&quot;, ints_ints);
}
</code></pre></pre>
<p>这使:</p>
<pre><code>ints [1, 2, 3]
floats [1.1, 2.1, 3.1]
strings [&quot;hello&quot;, &quot;world&quot;]
ints_ints [[1, 2], [10, 20]]
</code></pre>
<p>数组的数组是没问题,但重要的是,数组包括内容 <em>只有一个类型</em>. 数组中的值排列在一起
在内存中，以便他们非常高效地访问。</p>
<p>刚和一个显式声明一个变量类型,你知道将是错误的:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let var: () = [1.1, 1.2];
#}</code></pre></pre>
<p>这是信息错误:</p>
<pre><code>3 |     let var: () = [1.1, 1.2];
  |                   ^^^^^^^^^^ expected (), found array of 2 elements
  |
  = note: expected type `()`
  = note:    found type `[{float}; 2]`
</code></pre>
<p>(<code>{float}</code>意思是&quot;一些浮点类型不完全指定的)</p>
<p>切片给你不同 <em>快照</em> 的 <em>相同</em> 数组:</p>
<pre><pre class="playpen"><code class="language-rust">// slice1.rs
fn main() {
    let ints = [1, 2, 3, 4, 5];
    let slice1 = &amp;ints[0..2];
    let slice2 = &amp;ints[1..];  // open range!

    println!(&quot;ints {:?}&quot;, ints);
    println!(&quot;slice1 {:?}&quot;, slice1);
    println!(&quot;slice2 {:?}&quot;, slice2);
}
</code></pre></pre>
<pre><code>ints [1, 2, 3, 4, 5]
slice1 [1, 2]
slice2 [2, 3, 4, 5]
</code></pre>
<p>这是一个简洁的符号,类似于 Python 片但是有很大区别: 从未有过任何数据的一个副本. 这些 <em>切片</em> 他们的数据来自 <code>借用{borrow}</code> 他们的数组. 他们有一个非常亲密的关系数组,和 rust 花很多精力来确保不分解的关系.</p>
<a class="header" href="print.html#a可选值" id="a可选值"><h2>可选值</h2></a>
<p>切片,就像数组一样,可以 <em>索引</em>. Rust在编译时知道数组的大小,但只有在运行时才知道分切片的大小. 所以<code>s[i]</code>在运行时会引起超出界限的错误 <em>恐慌{panic}</em>. 这实际上并不是你想要发生的事情 - 它可能是 安全发射中止 与 遍布佛罗里达州的非常昂贵卫星的散射切片 之间的区别. 还有 <em>没有例外</em>.</p>
<p>让它沉入水中,因为它是一种冲击. 你不能在某些 try-block 中包装可怕的可能问题代码,并且&quot;捕获错误&quot; - 至少不是你每天都想使用的方式. 那么 Rust 如何安全?</p>
<p>有一种切片方法<code>get</code>这并不恐慌{panic}. 但是它返回了什么?</p>
<pre><pre class="playpen"><code class="language-rust">// slice2.rs
fn main() {
    let ints = [1, 2, 3, 4, 5];
    let slice = &amp;ints;
    let first = slice.get(0);
    let last = slice.get(5);

    println!(&quot;first {:?}&quot;, first);
    println!(&quot;last {:?}&quot;, last);
}
// first Some(1)
// last None
</code></pre></pre>
<p><code>last</code>失败 (我们忘记了基于零的索引) ,但返回了一个叫做的东西<code>None</code>. <code>first</code>很好,但是作为一个 值包装 出现<code>Some</code>. 欢迎来到<code>Options</code>类型!它可能是<code>Some</code> <em>或者</em> <code>None</code>.</p>
<p>这<code>Option</code>类型有一些有用的方法:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    println!(&quot;first {} {}&quot;, first.is_some(), first.is_none());
    println!(&quot;last {} {}&quot;, last.is_some(), last.is_none());
    println!(&quot;first value {}&quot;, first.unwrap());

// first true false
// last false true
// first value 1
#}</code></pre></pre>
<p>如果你 <em>打开{unwrap}</em> <code>last</code>,你会得到一个恐慌{panic}. 但至少你可以叫<code>is_some</code>确保 - 例如,如果你有一个不同的默认 没有价值的变量:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let maybe_last = slice.get(5);
    let last = if maybe_last.is_some() {
        *maybe_last.unwrap()
    } else {
        -1
    };
#}</code></pre></pre>
<p>注意<code>*</code> - 内部的精确类型<code>Some</code>是<code>&amp;i32</code>,这是一个引用. 我们需要这回到一个<code>i32</code>的值.</p>
<p>冗长的,这是一个快捷方式-<code>unwrap_or</code>, 如果返回的值是<code>Option</code>和是<code>None</code>. - 类型必须匹配<code>get</code>一个引用. 所以你必须组成<code>&amp;i32</code>与<code>&amp;-1</code>. 最后再次使用<code>*</code>获得价值<code>i32</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let last = *slice.get(5).unwrap_or(&amp;-1);
#}</code></pre></pre>
<p>这很容易错过<code>&amp;</code>,但你在这里有编译器. 如果它是<code>-1</code>,<code>rustc</code> says 'expected &amp;{integer}, found integral variable' ,然后'help: try<code>&amp;-1</code>&quot;.</p>
<p>你可以想到<code>Option</code>作为一个可能包含一个值的 Box,或者什么也不是 (<code>None</code>)  (在 Haskell, 它被称为<code>Maybe</code>) . 它可能包含 <em>任何</em> 有价值的,就是这样 <em>类型参数</em> . 在这种情况下,完整的类型是<code>Option&lt;&amp;i32&gt;</code>,使用 C ++ 风格的表示法 <em>仿制药{generics}</em>.  打开这个Box可能会引起爆炸,但不像施罗德林格的猫,我们可以事先知道它是否包含一个值.</p>
<p>这是非常常见的 rust 函数/方法返回这些可能的Box,所以学习如何舒适地<a href="https://doc.rust-lang.org/std/option/enum.Option.html">使用它们</a>.</p>
<a class="header" href="print.html#a向量" id="a向量"><h2>向量</h2></a>
<p>我们将再次返回切片方法,但首先返回 向量{Vec} . 这些是 <em>可重复使用的</em> 数组和行为很像 Python <code>List</code>和 C++ <code>std::vector</code>. rust 的<code>Vec</code>事实上,不同的是,你可以将额外的值附加到一个向量上,注意它必须声明为可变的.</p>
<pre><pre class="playpen"><code class="language-rust">// vec1.rs
fn main() {
    let mut v = Vec::new();
    v.push(10);
    v.push(20);
    v.push(30);

    let first = v[0];  // will panic if out-of-range
    let maybe_first = v.get(0);

    println!(&quot;v is {:?}&quot;, v);
    println!(&quot;first is {}&quot;, first);
    println!(&quot;maybe_first is {:?}&quot;, maybe_first);
}
// v is [10, 20, 30]
// first is 10
// maybe_first is Some(10)
</code></pre></pre>
<p>一个常见的初学者错误是忘记<code>mut</code>你会得到一个有用的错误信息:</p>
<pre><code>3 |     let v = Vec::new();
  |         - use `mut v` here to make mutable
4 |     v.push(10);
  |     ^ cannot borrow mutably
</code></pre>
<p>向量和切片之间有非常密切的关系:</p>
<pre><pre class="playpen"><code class="language-rust">// vec2.rs
fn dump(arr: &amp;[i32]) {
    println!(&quot;arr is {:?}&quot;, arr);
}

fn main() {
    let mut v = Vec::new();
    v.push(10);
    v.push(20);
    v.push(30);

    dump(&amp;v);

    let slice = &amp;v[1..];
    println!(&quot;slice is {:?}&quot;, slice);
}
</code></pre></pre>
<p>那么小,那么重要的借用<code>&amp;</code>是为了 <em>强迫</em> 向量进入切片. 它是完全有意义的,因为向量也在监视数组的值,数组的 <em>动态地</em> 分配也不同.</p>
<p>如果你来自一种动态的语言,那么现在是时候开始讨论了. 在系统语言中,程序存储器有两种: 堆栈和堆. 在堆栈上分配数据非常简单,但是堆栈是有限的;通常是按兆字节的顺序. 堆可以是千兆字节,但是分配相对昂贵,并且这样的内存必须是 <em>释放</em> 后来. 在所谓的'管理'的语言 (如java,Go和所谓的脚本语言) 这些细节都隐藏在你的便利的市政工程称 <em>垃圾收集器</em>. 一旦系统确定数据不再引用的其他数据,它回到可用内存池.</p>
<p>一般来说，这是一个值得付出的代价。 玩堆栈非常不安全，
因为如果你犯了一个错误，覆盖当前的返回地址在一次函数中, 那么你倒下了</p>
<p>我写的第一个C程序（在DOS PC上）
拿出整台电脑。 Unix系统总是表现得更好，只有 <em>segfault</em> 进程死掉了
。 为什么这比Rust（或Go）程序恐慌{panic}更糟？
因为当原始问题发生了会发生恐慌{panic}, 而不是之前
已经变得毫无希望地困惑和吃掉你所有的功课。</p>
<p>恐慌{panic} <em>memory safe</em> 因为它们在任何非法访问内存之前发生。 这是一个常见原因 C 中的安全问题，因为所有内存访问都是不安全的并且是狡猾的攻击者
可以利用这个弱点。</p>
<p>恐慌{panic}听起来绝望而无计划，但 Rust 的恐慌{panic}是结构化的 - 堆栈是 <em>unwound</em>
就像例外情况一样。 所有分配的对象都被删除，并且生成一个回溯。</p>
<p>垃圾收集的缺点？ 首先是它是浪费内存，这是
那些越来越统治我们世界的小型嵌入式微芯片中占有重要地位
其次是它会在最糟糕的时候决定进行 <em>现在</em> 清理
。 （这个妈妈的比喻是，她想在你与新的情人舞动时打扫房间
）。 这些嵌入式系统需要对事物做出响应
当它们发生时（'实时'），并且不能容忍计划外的爆发
清洗。 Roberto Ierusalimschy，Lua的首席设计师（最优雅的动态语言设计师之一）
说，他不想乘坐飞机时
依靠垃圾收集软件。</p>
<p>回到 vectors ：当一个 vectors 被修改或创建时，它从堆中分配并变成
该内存的 <em>owner</em> . 切片从 vectors 的内存中借用。
当 vectors 死亡或 <em>drops</em> 时，切片也会跟着 vectors。</p>
<a class="header" href="print.html#a迭代器" id="a迭代器"><h2>迭代器</h2></a>
<p>我们到目前为止没有提及的关键部分  rust 难题 - 迭代器.</p>
<p>for循环在使用迭代器范围是(<code>0..n</code>其实是类似于the Python 3<code>range</code>功能).</p>
<p>迭代器很容易定义. 这是一个&quot;对象&quot;<code>next</code>方法返回一个<code>Option</code>. 只要这个价值不是<code>None</code>,我们一直<code>next</code>:</p>
<pre><pre class="playpen"><code class="language-rust">// iter1.rs
fn main() {
    let mut iter = 0..3;
    assert_eq!(iter.next(), Some(0));
    assert_eq!(iter.next(), Some(1));
    assert_eq!(iter.next(), Some(2));
    assert_eq!(iter.next(), None);
}
</code></pre></pre>
<p>而这正是<code>for var in iter {}</code>.</p>
<p>这似乎是定义for循环的低效方式,但是<code>rustc</code>在发布模式中会进行疯狂的优化,并且它会和<code>while</code>循环一样快.</p>
<p>这是对数组进行迭代的第一次尝试:</p>
<pre><pre class="playpen"><code class="language-rust">// iter2.rs
fn main() {
    let arr = [10, 20, 30];
    for i in arr {
        println!(&quot;{}&quot;, i);
    }
}
</code></pre></pre>
<p>失败,但有帮助:</p>
<pre><code>4 |     for i in arr {
  |     ^ the trait `std::iter::Iterator` is not implemented for `[{integer}; 3]`
  |
  = note: `[{integer}; 3]` is not an iterator; maybe try calling
   `.iter()` or a similar method
  = note: required by `std::iter::IntoIterator::into_iter`
</code></pre>
<p>以下<code>rustc</code>的建议,下面的程序按预期工作.</p>
<pre><pre class="playpen"><code class="language-rust">// iter3.rs
fn main() {
    let arr = [10, 20, 30];
    for i in arr.iter() {
        println!(&quot;{}&quot;, i);
    }

    // slices will be converted implicitly to iterators...
    let slice = &amp;arr;
    for i in slice {
        println!(&quot;{}&quot;, i);
    }
}
</code></pre></pre>
<p>实际上,迭代数组或切片这种方式使用起来效率更高<code>for i in 0..slice.len() {}</code>因为Rust不必痴迷于检查每个索引操作.</p>
<p>我们之前有一个总结一系列整数的例子. 它涉及一个<code>mut</code>变量和循环. 这是 <em>惯用的</em> ,总结评分 sum 的方式:</p>
<pre><pre class="playpen"><code class="language-rust">// sum1.rs
fn main() {
    let sum: i32  = (0..5).sum();
    println!(&quot;sum was {}&quot;, sum);

    let sum: i64 = [10, 20, 30].iter().sum();
    println!(&quot;sum was {}&quot;, sum);
}
</code></pre></pre>
<p>请注意,这是其中一个需要明确说明的情况. <em>类型</em> 对于变量,因为否则  rust 没有足够的信息. 这里我们用两个不同的整数做和,没有问题.  (如果用尽所有的名字来创建一个新的同名变量也是没有问题的. )</p>
<p>在这样的背景下,更多的<a href="https://doc.rust-lang.org/std/primitive.slice.html">切片法</a>将更有意义.  (另一个文档提示;在每个文档页的右边有一个'[-]单击该按钮以折叠方法列表. 然后你可以扩展任何看起来很有趣的细节. 任何看起来怪异的东西,现在就忽略它.</p>
<p>这个<code>windows</code>方法提供了一个迭代器的重叠值窗口.</p>
<pre><pre class="playpen"><code class="language-rust">// slice4.rs
fn main() {
    let ints = [1, 2, 3, 4, 5];
    let slice = &amp;ints;

    for s in slice.windows(2) {
        println!(&quot;window {:?}&quot;, s);
    }
}
// window [1, 2]
// window [2, 3]
// window [3, 4]
// window [4, 5]
</code></pre></pre>
<p>或<code>块{chunks}</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    for s in slice.chunks(2) {
        println!(&quot;chunks {:?}&quot;, s);
    }
// chunks [1, 2]
// chunks [3, 4]
// chunks [5]
#}</code></pre></pre>
<a class="header" href="print.html#a更多关于向量" id="a更多关于向量"><h2>更多关于向量</h2></a>
<p>有一个有用的小宏<code>vec!</code>用于初始化向量. 注意你可以使用<code>pop</code> <em>去除{remove}</em> 向量结束时的值和 <em>延伸</em> 一个使用任何兼容迭代器的向量.</p>
<pre><pre class="playpen"><code class="language-rust">// vec3.rs
fn main() {
    let mut v1 = vec![10, 20, 30, 40];
    v1.pop();

    let mut v2 = Vec::new();
    v2.push(10);
    v2.push(20);
    v2.push(30);

    assert_eq!(v1, v2);

    v2.extend(0..2);
    assert_eq!(v2, &amp;[10, 20, 30, 0, 1]);
}
</code></pre></pre>
<p>向量相互比较,以值为单位.</p>
<p>可以将值插入到任意位置的向量中. <code>插入{insert}</code>或者使用<code>去除{remove}</code>移除.
这不像从那以后的推动和弹出一样有效
这些值将不得不被移动以腾出空间，所以请小心这些操作
向量.</p>
<p>vec 具有大小和 <em>capacity{容量}</em>。 如果你清除了一个 vec ，它的大小就变成了零，
但它仍保留其旧容量。 所以用<code>push</code>等来填充只需要
当尺寸大于该容量时重新分配。</p>
<p>vec 可以排序,然后可以删除重复的 - 这些操作就在 vec 上 . (如果你想先复制,使用<code>clone</code>).</p>
<pre><pre class="playpen"><code class="language-rust">// vec4.rs
fn main() {
    let mut v1 = vec![1, 10, 5, 1, 2, 11, 2, 40];
    v1.sort();
    v1.dedup();
    assert_eq!(v1, &amp;[1, 2, 5, 10, 11, 40]);
}
</code></pre></pre>
<a class="header" href="print.html#a字符串" id="a字符串"><h2>字符串</h2></a>
<p>Rust中的字符串比其他语言中的字符串更复杂一些; <code>String</code>类型，
像<code>Vec</code>，动态分配并可调整大小。 （所以它就像 C ++ 的<code>std::string</code>
但不像Java和 Python 的不可变字符串。）但是一个程序可能包含很多
<em>string literals {切片}</em>（如“hello”）和系统语言应该能够存储
这些静态可执行文件本身。 在嵌入式微软中，这可能意味着推出
他们在 廉价的ROM 而不是 昂贵的RAM（对于低功耗设备，RAM是
在功耗方面也很昂贵。）<em>系统</em> 语言必须具有
两种字符串，分配或静态。</p>
<p>所以&quot;hello&quot;不是<code>String</code>类型。 它是<code>＆str</code>类型（发音为'string slice'）。
这就像 C ++ 中 <code>const char*</code>和 <code>std::string</code> 之间的区别，除了
<code>＆str</code>更智能。 实际上，<code>＆str</code>和<code>String</code>有一个很好的的相似关系
如<code>&amp;[T]</code>到<code>Vec&lt;T&gt;</code>。</p>
<pre><pre class="playpen"><code class="language-rust">// string1.rs
fn dump(s: &amp;str) {
    println!(&quot;str '{}'&quot;, s);
}

fn main() {
    let text = &quot;hello dolly&quot;;  // the string slice
    let s = text.to_string();  // it's now an allocated string

    dump(text);
    dump(&amp;s);
}
</code></pre></pre>
<p>再次,借用操作 可以强制<code>String</code>成<code>&amp;str</code>, 就像<code>Vec&lt;T&gt;</code>可能会被强迫进入<code>&amp;[T]</code>.</p>
<p>在引擎盖下,<code>String</code>基本上是<code>Vec&lt;u8&gt;</code>和<code>&amp;str</code>是<code>[u8]</code>, 但是那些字节 <em>必须</em> 表示有效的UTF-8文本.</p>
<p>就像一个向量,你可以<code>push</code>和<code>pop</code>一个<code>String</code>:</p>
<pre><pre class="playpen"><code class="language-rust">// string5.rs
fn main() {
    let mut s = String::new();
    // initially empty!
    s.push('H');
    s.push_str(&quot;ello&quot;);
    s.push(' ');
    s += &quot;World!&quot;; // short for `push_str`
    // remove the last char
    s.pop();

    assert_eq!(s, &quot;Hello World&quot;);
}
</code></pre></pre>
<p><code>to_string</code>可以将许多类型转换为字符串.  (如果可以用&quot;{}&quot;显示它们,那么它们可以被转换) . <code>format!</code>宏是使用相同的格式字符串来构建更复杂的字符串的一种非常有用的方法就像<code>println!</code>.</p>
<pre><pre class="playpen"><code class="language-rust">// string6.rs
fn array_to_str(arr: &amp;[i32]) -&gt; String {
    let mut res = '['.to_string();
    for v in arr {
        res += &amp;v.to_string();
        res.push(',');
    }
    res.pop();
    res.push(']');
    res
}

fn main() {
    let arr = array_to_str(&amp;[10, 20, 30]);
    let res = format!(&quot;hello {}&quot;, arr);

    assert_eq!(res, &quot;hello [10,20,30]&quot;);
}
</code></pre></pre>
<p>注意<code>&amp;</code>在前面的<code>v.to_string()</code>- 在字符串条上定义运算符,而不是<code>String</code>因此,它需要一点说服力来匹配.</p>
<p>用于切片的符号也与字符串一起工作:</p>
<pre><pre class="playpen"><code class="language-rust">// string2.rs
fn main() {
    let text = &quot;static&quot;;
    let string = &quot;dynamic&quot;.to_string();

    let text_s = &amp;text[1..];
    let string_s = &amp;string[2..4];

    println!(&quot;slices {:?} {:?}&quot;, text_s, string_s);
}
// slices &quot;tatic&quot; &quot;na&quot;
</code></pre></pre>
<p>但是,你不能索引字符串! 这是因为它们使用一个真正的编码UTF-8,其中&quot;character&quot;可能是字节数.</p>
<pre><pre class="playpen"><code class="language-rust">// string3.rs
fn main() {
    let multilingual = &quot;Hi! ¡Hola! привет!&quot;;
    for ch in multilingual.chars() {
        print!(&quot;'{}' &quot;, ch);
    }
    println!(&quot;&quot;);
    println!(&quot;len {}&quot;, multilingual.len());
    println!(&quot;count {}&quot;, multilingual.chars().count());

    let maybe = multilingual.find('п');
    if maybe.is_some() {
        let hi = &amp;multilingual[maybe.unwrap()..];
        println!(&quot;Russian hi {}&quot;, hi);
    }
}
// 'H' 'i' '!' ' ' '¡' 'H' 'o' 'l' 'a' '!' ' ' 'п' 'р' 'и' 'в' 'е' 'т' '!'
// len 25
// count 18
// Russian hi привет!
</code></pre></pre>
<p>⚠️ 现在,让我们思考 - 有25个字节,但是只有18个字符!但是,如果你使用类似的方法<code>find</code>,你会得到一个有效的索引(如果发现)和切片会没事的.</p>
<p>(  rust <code>char{字符}</code>类型是一个4字节的Unicode代码点. 字符串不是字符
的数组!)</p>
<p>字符串切片可能会像 Vec 索引一样爆炸，因为它使用字节偏移量。 在这种情况下，
该字符串由两个字节组成，所以试图拉出第一个字节是一个Unicode错误。 所以，
注意只使用来自字符串方法的有效偏移来切分字符串。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let s = &quot;¡&quot;;
    println!(&quot;{}&quot;, &amp;s[0..1]); &lt;-- bad, first byte of a multibyte character
#}</code></pre></pre>
<p>打破字符串是一种流行和有用的消遣方式。 字符串<code>split_whitespace</code>
方法返回 <em>iterator</em>，然后我们选择如何处理它。 共同需要
是创建拆分子串的 vec 。</p>
<p><code>collect</code>非常普遍，因此需要收集一些关于 collect <em>它</em> 的线索
显式类型。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let text = &quot;the red fox and the lazy dog&quot;;
    let words: Vec&lt;&amp;str&gt; = text.split_whitespace().collect();
    // [&quot;the&quot;, &quot;red&quot;, &quot;fox&quot;, &quot;and&quot;, &quot;the&quot;, &quot;lazy&quot;, &quot;dog&quot;]
#}</code></pre></pre>
<p>你也可以这样说,通过迭代器进入<code>扩展{extend}</code>方法:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let mut words = Vec::new();
    words.extend(text.split_whitespace());
#}</code></pre></pre>
<p>在大多数语言中，我们将不得不使这些 <em>分离的strings</em>，
而在这里 Vec 中的每个片段都是从原始字符串中借用的。
我们所分配的是保留切片的空间。</p>
<p>看看这个可爱的双线 <code>| |</code>; 我们得到了一个字符的迭代器，
并只采取那些不是 空格 的字符。 再次，<code>collect</code> 的需要
一个线索（我们可能想要一个字符向量，比如说):</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let stripped: String = text.chars()
        .filter(|ch| ! ch.is_whitespace()).collect();
    // theredfoxandthelazydog
#}</code></pre></pre>
<p>这<code>filter</code>方法接受一个 <em>闭包函数</em>,这是 Rust  的 匿名功能. 这里的参数类型从上下文中是清楚的,所以显式规则是放松的.</p>
<p>是的,你可以这样做,作为一个字符的显式循环,将返回的片段推送到一个可变的向量中,但是这个更短,读得很好 ( <em>当</em> 你习惯了) ,同样快. 它不是 <em>罪{sin}</em> 然而,使用循环,我鼓励你也写这个版本.</p>
<a class="header" href="print.html#a插曲-获取命令行参数" id="a插曲-获取命令行参数"><h2>插曲: 获取命令行参数</h2></a>
<p>到目前为止,我们的节目都生活在对外界的无知之中;现在是时候给他们提供数据.</p>
<p><code>std::env::args</code>是你如何访问命令行参数;它返回一个迭代器作为字符串的参数,包括程序名.</p>
<pre><pre class="playpen"><code class="language-rust">// args0.rs
fn main() {
    for arg in std::env::args() {
        println!(&quot;'{}'&quot;, arg);
    }
}
</code></pre></pre>
<pre><code>src$ rustc args0.rs
src$ ./args0 42 'hello dolly' frodo
'./args0'
'42'
'hello dolly'
'frodo'
</code></pre>
<p>返回一个<code>Vec</code>会更好吗?这很容易使用<code>collect</code>使用迭代器来创建该向量<code>skip</code>方法跳过.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let args: Vec&lt;String&gt; = std::env::args().skip(1).collect();
    if args.len() &gt; 0 { // we have args!
        ...
    }
#}</code></pre></pre>
<p>这很好;几乎所有的语言都会这样做.</p>
<p>阅读单个参数 (连同解析整数值一起) 的更多Rust-y方法:</p>
<pre><pre class="playpen"><code class="language-rust">// args1.rs
use std::env;

fn main() {
    let first = env::args().nth(1).expect(&quot;please supply an argument&quot;);
    let n: i32 = first.parse().expect(&quot;not an integer!&quot;);
    // do your magic
}
</code></pre></pre>
<p><code>nth(1)</code>为您提供迭代器的第二个值,以及<code>expect</code>就像一个<code>unwrap</code>带有可读的信息.</p>
<p>将字符串转换为数字很简单,但您需要指定值的类型 - 还有什么可以<code>parse</code>知道吗?</p>
<p>这个程序可能会恐慌{panic},这对于笨拙的测试程序来说很好. 但是,不要因为这种便利的习惯而难以忍受.</p>
<a class="header" href="print.html#a匹配" id="a匹配"><h2>匹配</h2></a>
<p>我们提取俄罗斯问候语的<code>string3.rs</code>中的代码并不是如此
通常写。 输入 <em>match</em>：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    match multilingual.find('п') {
        Some(idx) =&gt; {
            let hi = &amp;multilingual[idx..];
            println!(&quot;Russian hi {}&quot;, hi);
        },
        None =&gt; println!(&quot;couldn't find the greeting, Товарищ&quot;)
    };
#}</code></pre></pre>
<p><code>match</code>包括几个 <em>模式{patterns}</em> 用一个匹配值跟随 胖箭头,用逗号分隔. 它方便地从<code>Options</code>把它与<code>idx{index}</code>束缚起来.  你 <em>必须</em> 指定所有的可能性,所以我们必须处理<code>None</code>.</p>
<p>一旦你习惯了 (我的意思是,把它打满几遍) ,感觉比自然的更自然. <code>is_some</code>检查需要一个额外的存储<code>Option</code>.</p>
<p>但是如果你对这里的失败不感兴趣,那么<code>if let</code>是你的朋友:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    if let Some(idx) = multilingual.find('п') {
        println!(&quot;Russian hi {}&quot;, &amp;multilingual[idx..]);
    }
#}</code></pre></pre>
<p>这是方便的,如果你想做一场 match,是 <em>只有</em> 对一个可能的结果感兴趣.</p>
<p><code>匹配{match}</code>也可以像一个C<code>switch</code>声明中,就像其他Rust构造一样
可以返回一个值:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let text = match n {
        0 =&gt; &quot;zero&quot;,
        1 =&gt; &quot;one&quot;,
        2 =&gt; &quot;two&quot;,
        _ =&gt; &quot;many&quot;,
    };
#}</code></pre></pre>
<p><code>_</code>就像C`默认的 - 这是一个备用情况.如果你不提供一个默认, 会认为这是一个错误.</p>
<p>(在c++中最好的期望是一个警告,获利很多关于各自的语言).</p>
<p>rust的<code>匹配</code>语句也可以匹配范围. 请注意，这些范围有
<em>three{三个}</em> 点 并且是包含范围，所以第一个条件将匹配3。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let text = match n {
        0...3 =&gt; &quot;small&quot;,
        4...6 =&gt; &quot;medium&quot;,
        _ =&gt; &quot;large&quot;,
     };
#}</code></pre></pre>
<a class="header" href="print.html#a读取文件" id="a读取文件"><h2>读取文件</h2></a>
<p>下一步是向世界展示我们的程序 <em>阅读文件</em>.</p>
<p>回想一下,<code>expect</code>就像<code>unwrap</code>但给了一个自定义的错误消息.
在这里我们会扔掉一些错误:</p>
<pre><pre class="playpen"><code class="language-rust">// file1.rs
use std::env;
use std::fs::File;
use std::io::Read;

fn main() {
    let first = env::args().nth(1).expect(&quot;please supply a filename&quot;);

    let mut file = File::open(&amp;first).expect(&quot;can't open the file&quot;);

    let mut text = String::new();
    file.read_to_string(&amp;mut text).expect(&quot;can't read the file&quot;);

    println!(&quot;file had {} bytes&quot;, text.len());

}
</code></pre></pre>
<pre><code>src$ file1 file1.rs
file had 366 bytes
src$ ./file1 frodo.txt
thread 'main' panicked at 'can't open the file: Error { repr: Os { code: 2, message: &quot;No such file or directory&quot; } }', ../src/libcore/result.rs:837
note: Run with `RUST_BACKTRACE=1` for a backtrace.
src$ file1 file1
thread 'main' panicked at 'can't read the file: Error { repr: Custom(Custom { kind: InvalidData, error: StringError(&quot;stream did not contain valid UTF-8&quot;) }) }', ../src/libcore/result.rs:837
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>所以<code>open</code>可以失败,因为该文件不存在或者我们不允许读它,然后呢<code>read_to_string</code>可能会失败,因为该文件不包含有效的UTF-8.  (这是足够的,你可以使用<code>read_to_end</code>并将其内容放入字节替代的 vec 中. ) 对于不太大的文件，一口一口地阅读它们是有用的
直截了当。</p>
<p>如果你知道其他语言的文件处理的任何事情,你可能会怀疑文件是什么 <em>关闭{closed}</em>. 如果我们正在写这个文件,那么不关闭它可能导致数据丢失. 但是当函数结束时,这里的文件被关闭,而<code>File</code>变量是 <em>下降{dropped}</em>.</p>
<p>这种&quot;抛出错误&quot;的做法是习惯太过分了. 你不想将这些代码放入函数中,因为它知道它可以很容易地使整个程序崩溃. 所以现在我们必须谈论到底<code>File::open</code> 返回什么. 如果<code>Option</code>是一个值,可能包含或不包含任何内容<code>Result</code>是一个可能包含某些内容或错误的值. 他们都明白<code>unwrap</code> (和它的表弟<code>expect</code>) 但它们完全不同. <code>Result</code>由 <em>二</em> 类型参数定义,为<code>Ok</code>价值和<code>Err</code>价值. <code>Result</code>Box有两个隔间,一个标签<code>Ok</code>而另一个<code>Err</code>.</p>
<pre><pre class="playpen"><code class="language-rust">fn good_or_bad(good: bool) -&gt; Result&lt;i32,String&gt; {
    if good {
        Ok(42)
    } else {
        Err(&quot;bad&quot;.to_string())
    }
}

fn main() {
    println!(&quot;{:?}&quot;,good_or_bad(true));
    //Ok(42)
    println!(&quot;{:?}&quot;,good_or_bad(false));
    //Err(&quot;bad&quot;)

    match good_or_bad(true) {
        Ok(n) =&gt; println!(&quot;Cool, I got {}&quot;,n),
        Err(e) =&gt; println!(&quot;Huh, I just got {}&quot;,e)
    }
    // Cool, I got 42

}
</code></pre></pre>
<p>(实际的&quot;错误&quot;类型是任意的,很多人使用字符串,直到它们对  rust 错误类型感到满意) . 这是一种方便的方法. <em>任何一个</em> 返回一个值 <em>或</em> 另一个.</p>
<p>该版本的文件读取功能不会崩溃. 它返回一个<code>Result</code>这就是 <em>呼叫者{caller}</em> 谁必须决定如何处理这个错误.</p>
<pre><pre class="playpen"><code class="language-rust">// file2.rs
use std::env;
use std::fs::File;
use std::io::Read;
use std::io;

fn read_to_string(filename: &amp;str) -&gt; Result&lt;String,io::Error&gt; {
    let mut file = match File::open(&amp;filename) {
        Ok(f) =&gt; f,
        Err(e) =&gt; return Err(e),
    };
    let mut text = String::new();
    match file.read_to_string(&amp;mut text) {
        Ok(_) =&gt; Ok(text),
        Err(e) =&gt; Err(e),
    }
}

fn main() {
    let file = env::args().nth(1).expect(&quot;please supply a filename&quot;);

    let text = read_to_string(&amp;file).expect(&quot;bad file man!&quot;);

    println!(&quot;file had {} bytes&quot;, text.len());
}
</code></pre></pre>
<p>第一次 match 安全地提取价值<code>Ok</code>这就成了match的价值所在. 如果是<code>Err</code>它返回错误,重新包装为<code>Err</code>.</p>
<p>第二个匹配返回字符串，包装为<code>Ok</code>，否则返回
（再次）错误。 <code>Ok</code>中的实际值不重要，所以我们忽略
它用<code>_</code>。</p>
<p>这不太好看; 当一个函数的大部分是错误处理时，那么
'快乐之路'迷路了。 去往往有这个问题，有很多
明确的早期返回，或者只是 <em>ignoring errors{忽视错误}</em> 。 （也就是说，顺便说一下，
在Rust世界中最接近邪恶的东西.）</p>
<p>幸运的是,有一个捷径.</p>
<p><code>std::io</code>模块定义了一个类型别名<code>io::Result&lt;T&gt;</code>这正与<code>Result&lt;T,io::Error&gt;</code>相同且更容易的类型.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn read_to_string(filename: &amp;str) -&gt; io::Result&lt;String&gt; {
    let mut file = File::open(&amp;filename)?;
    let mut text = String::new();
    file.read_to_string(&amp;mut text)?;
    Ok(text)
}
#}</code></pre></pre>
<p>那<code>?</code>, 也几乎完全匹配<code>File::open</code>,如果结果是一个错误,那么它将立即返回错误. 否则,它将返回<code>Result</code>.</p>
<p>最后,我们仍然需要结束字符串作为结果. <code>?</code>是一个很酷的东西慢慢就成了稳定. 你仍能看到宏<code>try!</code>用于旧代码:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn read_to_string(filename: &amp;str) -&gt; io::Result&lt;String&gt; {
    let mut file = try!(File::open(&amp;filename));
    let mut text = String::new();
    try!(file.read_to_string(&amp;mut text));
    Ok(text)
}
#}</code></pre></pre>
<p>总而言之，可以编写完全安全的Rust，而不是丑陋的
需要例外。</p>
<a class="header" href="print.html#a结构structs枚举enums和匹配match" id="a结构structs枚举enums和匹配match"><h1>结构{structs},枚举{enums}和匹配{match}</h1></a>
<a class="header" href="print.html#rust-喜欢-move-它-move-它" id="rust-喜欢-move-它-move-它"><h2>Rust 喜欢 move 它, move 它</h2></a>
<p>我想稍微回退一下,给你看一些令人惊讶的东西:</p>
<pre><pre class="playpen"><code class="language-rust">// move1.rs
fn main() {
    let s1 = &quot;hello dolly&quot;.to_string();
    let s2 = s1;
    println!(&quot;s1 {}&quot;, s1);
}
</code></pre></pre>
<p>我们得到以下错误:</p>
<pre><code>error[E0382]: use of moved value: `s1`
 --&gt; move1.rs:5:22
  |
4 |     let s2 = s1;
  |         -- value moved here
5 |     println!(&quot;s1 {}&quot;, s1);
  |                      ^^ value used here after move
  |
  = note: move occurs because `s1` has type `std::string::String`,
  which does not implement the `Copy` trait
</code></pre>
<p>Rust 与其他语言有不同的行为. 在变量总是<code>引用{references}</code> (如Java或Python) 的语言中,<code>s2</code>成为对引用<code>s1</code>字符串对象的又一个引用. 在 C ++ 中,<code>s1</code>是一种<code>价值{value}</code>,它是 <em>复制</em> 至<code>s2</code>. 但 Rust 会改变价值. 它没有看到<code>字符串{strings}</code>是可复制的 (&quot;没有实现复制trait&quot;) .</p>
<p>我们不会看到像数字这样的&quot;原始&quot;类型,因为它们只是数值;他们被允许复制,因为他们便宜复制. 但<code>String</code>已经分配了包含&quot;Hello dolly&quot;的内存,并且复制将涉及分配更多内存还要复制<code>字符{char}</code>.  Rust 不会默默地做到这一点.</p>
<p>考虑一个<code>String</code>包含&quot;Moby-Dick&quot;的全文. 它不是一个很大的结构,只有文本的内存地址,它的大小以及分配块的大小. 复制这将是昂贵的,因为该内存分配在堆上和需要自己的分配区块.</p>
<pre><code>    String
    | addr | ---------&gt; Call me Ishmael.....
    | size |                    |
    | cap  |                    |
                                |
    &amp;str                        |
    | addr | -------------------|
    | size |

    f64
    | 8 bytes |
</code></pre>
<p>第二个值是一个字符串切片 (<code>&amp;str</code>) ,它与字符串指向相同的内存,大小 - 仅仅只是名字. 便宜复制!</p>
<p>第三个值是一个<code>f64</code>- 只有8个字节. 它不涉及任何其他内存,所以它的复制一样便宜移动.</p>
<p><code>复制{Copy}</code>值只能通过它们在内存中的表示来定义,而当 Rust 拷贝时,它只是在其他地方复制这些字节. 类似地, 一个没有<code>复制{Copy}</code>的<code>价值{value}</code>也是 <em>只能移动{move}</em>. 与 C ++ 不同的是, Rust 在复制和移动方面没有聪明之处.</p>
<blockquote>
<p>对 具有引用的变量 隐形<code>移动{move}</code>变量, 在 rust 是错误的</p>
</blockquote>
<p>用函数调用重写将显示完全相同的错误:</p>
<pre><pre class="playpen"><code class="language-rust">// move2.rs

fn dump(s: String) {
    println!(&quot;{}&quot;, s);
}

fn main() {
    let s1 = &quot;hello dolly&quot;.to_string();
    dump(s1);
    println!(&quot;s1 {}&quot;, s1); // &lt;---error: 'value used here after move'
}
</code></pre></pre>
<p>在这里,你有一个选择. 您可以传递对该字符串的<code>引用{&amp;}</code>,或者使用它<code>clone</code>方法明确拷贝. 一般来说,第一种是更好的方法.</p>
<pre><pre class="playpen"><code class="language-rust">fn dump(s: &amp;String) {
    println!(&quot;{}&quot;, s);
}

fn main() {
    let s1 = &quot;hello dolly&quot;.to_string();
    dump(&amp;s1);
    println!(&quot;s1 {}&quot;, s1);
}
</code></pre></pre>
<p>错误消失. 但你很少看到一个简朴<code>String</code>像这样的引用,因为传递一个字符串文字是非常丑陋的 <em>和</em> 涉及创建一个临时字符串.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    dump(&amp;&quot;hello world&quot;.to_string());
#}</code></pre></pre>
<p>因此,声明该函数的最佳方式是:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn dump(s: &amp;str) {
    println!(&quot;{}&quot;, s);
}
#}</code></pre></pre>
<p>然后两个 <code>dump(&amp;s1)</code> 和 <code>dump(&quot;hello world&quot;)</code> 好好工作.  (这里就是<code>Deref</code>起的作用, Rust 会为你转换<code>&amp;String</code>至<code>&amp;str</code>. )</p>
<p>总而言之,分配 <code>非复制{non-Copy}</code>会将 值 从一个位置<code>移动{move}</code>到另一个位置. 否则,<code>锈{rust}</code>将被迫 <em>隐式</em> 做一个<code>副本{copy}</code>,并打破rust本身 <em>明确分配</em> 的<code>承诺{promise}</code>.</p>
<a class="header" href="print.html#a变量的范围" id="a变量的范围"><h2>变量的范围</h2></a>
<p>所以,经验法则是更愿意保留对原始数据的<code>引用{&amp;}</code> - 以此来<code>&quot;借用{borrow}&quot;</code>它.</p>
<p>但一个引用必须 <em>不能</em> 超过<code>拥有人{owner}</code>!</p>
<p>首先, Rust 是一个 <em>块范围的{block-scoped}</em> 语言. 变量仅在其块的持续时间内存在:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    let a = 10;
    let b = &quot;hello&quot;;
    {
        let c = &quot;hello&quot;.to_string();
        // a,b and c are visible 有
    }
    // the string c is dropped 没有了
    // a,b are visible 有
    for i in 0..a {
        let b = &amp;b[1..];
        // original b is no longer visible - it is shadowed.
        // 原来的b不再可见 - 它被罩住了。
    }
    // the slice b is dropped
    // i is _not_ visible!
}
#}</code></pre></pre>
<p>循环变量 (如<code>i</code>) 有点不同,它们只在循环块中可见. 创建一个使用相同名称的新变量并不是一个错误 (<code>'shadowing'</code>) ,但它可能会造成混淆.</p>
<p>当一个变量'超出范围',那么它是 <em>扔掉了{dropped}</em>. 任何使用的内存都会被回收,而该变量的其他 <em>资源{resources}</em> 将返回给系统 - 例如,扔掉一个<code>文件{File}</code>就会闭包它. 这是一件好事. 未使用的资源在不需要时立即回收.</p>
<p>(另一个特定于 Rust 的问题是变量可能看起来在范围内,但其值已经<code>移动{move}</code>. )</p>
<p>这里有一个引用<code>rs1</code> 到 <code>tmp</code>, 它只在其区块期间<code>{}</code>存在:</p>
<pre><pre class="playpen"><code class="language-rust">01 // ref1.rs
02 fn main() {
03    let s1 = &quot;hello dolly&quot;.to_string();
04    let mut rs1 = &amp;s1;
05    {
06        let tmp = &quot;hello world&quot;.to_string();
07        rs1 = &amp;tmp; // &lt;==
08    }
09    println!(&quot;ref {}&quot;, rs1);
10 }
</code></pre></pre>
<p>我们<code>借用{borrow}</code>的价值 <code>s1</code>然后借用的价值<code>tmp</code>. 但<code>tmp</code>在该区块之外就被扔掉了!</p>
<pre><code>error: `tmp` does not live long enough
  --&gt; ref1.rs:8:5
   |
7  |         rs1 = &amp;tmp;
   |                --- borrow occurs here
8  |     }
   |     ^ `tmp` dropped here while still borrowed
9  |     println!(&quot;ref {}&quot;, rs1);
10 | }
   | - borrowed value needs to live until here
</code></pre>
<p><code>tmp</code>哪里去了? 走了,死了,回到了天空中的大堆: <em>扔掉了{dropeed}</em>. rust 从 <strong>C</strong> 的可怕的'悬挂指针'问题中拯救你 - 一个指向陈旧数据的引用.</p>
<blockquote>
<p>在 区块中, <code>rs1</code>-指向-&gt; <code>&amp;tmp</code>, 但在区块结束后, tmp 整个都被 <em>扔掉了{dropped}</em> , 这个时候 <code>rs1</code> 也就指向一个指针 -指向-&gt; 被扔掉地址</p>
</blockquote>
<a class="header" href="print.html#a元组" id="a元组"><h2>元组</h2></a>
<p>从函数返回多个值有时非常有用. 元组是一个方便的解决方案:</p>
<pre><pre class="playpen"><code class="language-rust">// tuple1.rs

fn add_mul(x: f64, y: f64) -&gt; (f64,f64) {
    (x + y, x * y)
}

fn main() {
    let t = add_mul(2.0,10.0);

    // can debug print
    println!(&quot;t {:?}&quot;, t);

    // can 'index' the values
    println!(&quot;add {} mul {}&quot;, t.0,t.1);

    // can _extract_ values
    let (add,mul) = t;
    println!(&quot;add {} mul {}&quot;, add,mul);
}
// t (12, 20)
// add 12 mul 20
// add 12 mul 20
</code></pre></pre>
<p>元组可能包含 <em>不同</em> 类型,这是与数组的主要区别.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let tuple = (&quot;hello&quot;, 5, 'c');

assert_eq!(tuple.0, &quot;hello&quot;);
assert_eq!(tuple.1, 5);
assert_eq!(tuple.2, 'c');
#}</code></pre></pre>
<p>他们出现在一些<code>迭代器{Iterator}</code>方法. <code>enumerate</code>就像同名的 Python生成器 一样:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    for t in [&quot;zero&quot;,&quot;one&quot;,&quot;two&quot;].iter().enumerate() {
        print!(&quot; {} {};&quot;,t.0,t.1);
    }
    //  0 zero; 1 one; 2 two;
#}</code></pre></pre>
<p><code>zip</code>将两个迭代器,组合成一个 <em>包含来自两者的值的元组</em> 的迭代器:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let names = [&quot;ten&quot;,&quot;hundred&quot;,&quot;thousand&quot;];
    let nums = [10,100,1000];
    for p in names.iter().zip(nums.iter()) {
        print!(&quot; {} {};&quot;, p.0,p.1);
    }
    //  ten 10; hundred 100; thousand 1000;
#}</code></pre></pre>
<a class="header" href="print.html#a结构structs" id="a结构structs"><h2>结构{Structs}</h2></a>
<p>元组很方便,但是在说<code>t.1</code>并且追踪每个部分的含义, 不够直截了当</p>
<p>rust <em>结构</em> 包含命名 <em>字段{fields}</em> :</p>
<pre><pre class="playpen"><code class="language-rust">// struct1.rs

struct Person {
    first_name: String,
    last_name: String
}

fn main() {
    let p = Person {
        first_name: &quot;John&quot;.to_string(),
        last_name: &quot;Smith&quot;.to_string()
    };
    println!(&quot;person {} {}&quot;, p.first_name,p.last_name);
}
</code></pre></pre>
<p>虽然不应该假定任何特定的内存布局,但是结构体的值将在内存中相邻放置,因为编译器会组织内存,而不是大小来提高效率,并且可能会存在填充.</p>
<p>初始化这个结构有点笨拙,所以我们想要 移动构造一个<code>Person</code>融入其自身的函数. 通过它放进去<code>impl</code>块, 这个函数可以做成<code>Person</code>的一个 <em>关联函数</em> :</p>
<pre><pre class="playpen"><code class="language-rust">// struct2.rs

struct Person {
    first_name: String,
    last_name: String
}

impl Person {

    fn new(first: &amp;str, name: &amp;str) -&gt; Person {
        Person {
            first_name: first.to_string(),
            last_name: name.to_string()
        }
    }

}

fn main() {
    let p = Person::new(&quot;John&quot;,&quot;Smith&quot;);
    println!(&quot;person {} {}&quot;, p.first_name,p.last_name);
}
</code></pre></pre>
<p>这个名字<code>new</code>没有什么魔力或其他. 请注意,它使用类似 C ++ 进行访问 - 如使用双冒号的符号<code>::</code>.</p>
<p>下面是个<code>Person</code> <em>方法</em>,需要一个 <em>引用自我{reference self}</em> 参数:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Person {
    ...

    fn full_name(&amp;self) -&gt; String {
        format!(&quot;{} {}&quot;, self.first_name, self.last_name)
    }

}
...
    println!(&quot;fullname {}&quot;, p.full_name());
// fullname John Smith
#}</code></pre></pre>
<p>该<code>self</code>明确使用并作为<code>引用</code>传递.  (你可以想到<code>&amp;self</code>作为简称<code>self: &amp;Person</code>. )</p>
<p>关键字<code>Self</code>指的是结构类型 - 你可以在脑海中用<code>Person</code>替换<code>Self</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    fn copy(&amp;self) -&gt; Self {
        Self::new(&amp;self.first_name,&amp;self.last_name)
    }
#}</code></pre></pre>
<p>方法可以允许修改数据, 使用 <em>可变的自我{mutable self}</em> 参数:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    fn set_first_name(&amp;mut self, name: &amp;str) {
        self.first_name = name.to_string();
    }
#}</code></pre></pre>
<p>数据会 <em>移动{move}</em> 当使用简单的<code>self</code>参数时,</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    fn to_tuple(self) -&gt; (String,String) {
        (self.first_name, self.last_name)
    }
#}</code></pre></pre>
<p>(尝试使用<code>&amp;self</code>- 结构不会在没有战斗的情况下放开数据!)</p>
<p>请注意,之后<code>v.to_tuple()</code>被调用,然后<code>v</code>已经移动并且不再可用.</p>
<p>总结:</p>
<ul>
<li>没有<code>self</code>参数: 您可以将函数与结构关联,如<code>new</code>&quot;constructor&quot;.</li>
<li><code>&amp;self</code>参数: 可以使用结构体的值,但不能改变它们</li>
<li><code>&amp;mut self</code>参数: 可以修改这些值</li>
<li><code>self</code>参数: 将消耗和移动的值.</li>
</ul>
<p>如果您尝试执行一个调试转储<code>Person</code>,你会得到一个信息错误:</p>
<pre><code>error[E0277]: the trait bound `Person: std::fmt::Debug` is not satisfied
  --&gt; struct2.rs:23:21
   |
23 |     println!(&quot;{:?}&quot;, p);
   |                     ^ the trait `std::fmt::Debug` is not implemented for `Person`
   |
   = note: `Person` cannot be formatted using `:?`; if it is defined in your crate,
    add `#[derive(Debug)]` or manually implement it
   = note: required by `std::fmt::Debug::fmt`
</code></pre>
<p>编译器提供建议,所以我们放了<code>#[derive(Debug)]</code>在<code>Person</code>前面,现在有明智的输出:</p>
<pre><code>Person { first_name: &quot;John&quot;, last_name: &quot;Smith&quot; }
</code></pre>
<p>该 <em>指示{directive}</em> 使编译器生成一个 <code>Debug</code>实施{implementation}, 这是非常有益的. 对于你的结构来说这是一个很好的习惯,所以它们可以打印出来 (或者用字符串写成<code>format!</code>) .  (<em>默认</em> 非常<code>不是生锈{un- Rust like}</code>风格. ) 这是最后的小程序:</p>
<pre><pre class="playpen"><code class="language-rust">// struct4.rs
use std::fmt;

#[derive(Debug)]
struct Person {
    first_name: String,
    last_name: String
}

impl Person {

    fn new(first: &amp;str, name: &amp;str) -&gt; Person {
        Person {
            first_name: first.to_string(),
            last_name: name.to_string()
        }
    }

    fn full_name(&amp;self) -&gt; String {
        format!(&quot;{} {}&quot;,self.first_name, self.last_name)
    }

    fn set_first_name(&amp;mut self, name: &amp;str) {
        self.first_name = name.to_string();
    }

    fn to_tuple(self) -&gt; (String,String) {
        (self.first_name, self.last_name)
    }
}

fn main() {
    let mut p = Person::new(&quot;John&quot;,&quot;Smith&quot;);

    println!(&quot;{:?}&quot;, p);

    p.set_first_name(&quot;Jane&quot;);

    println!(&quot;{:?}&quot;, p);

    println!(&quot;{:?}&quot;, p.to_tuple());
    // p has now moved.

}
// Person { first_name: &quot;John&quot;, last_name: &quot;Smith&quot; }
// Person { first_name: &quot;Jane&quot;, last_name: &quot;Smith&quot; }
// (&quot;Jane&quot;, &quot;Smith&quot;)
</code></pre></pre>
<a class="header" href="print.html#a生命周期lifetimes开始咬人" id="a生命周期lifetimes开始咬人"><h2>生命周期{Lifetimes}开始咬人</h2></a>
<p>通常结构体包含值,但通常它们还需要包含<code>引用{&amp;}</code>. 假设我们想在一个结构中放置一个<code>字符串切片{&amp;str}</code>,而不是一个字符串值.</p>
<pre><pre class="playpen"><code class="language-rust">// life1.rs

#[derive(Debug)]
struct A {
    s: &amp;str
}

fn main() {
    let a = A { s: &quot;hello dammit&quot; };

    println!(&quot;{:?}&quot;, a);
}
</code></pre></pre>
<pre><code>error[E0106]: missing lifetime specifier
 --&gt; life1.rs:5:8
  |
5 |     s: &amp;str
  |        ^ expected lifetime parameter
</code></pre>
<p>为了理解<code>投诉{complaint}</code>,你必须从 Rust 的角度看问题.</p>
<p>如果不知道它的生命周期,它将不允许存储引用. 所有<code>引用{&amp;}</code>都是从某个价值中<code>借用{borrowed}</code>的,而且所有的<code>价值{value}</code>都是有<code>生命周期{lifetimes}</code>的. 引用的生命周期不能长于该值的生命周期.  Rust 不能允许这种 引用可能突然失效 的情况.</p>
<p>现在,字符串切片, 借用 <em>字符串文字</em> 像&quot;hello&quot;或来自<code>String</code>值. 字符串文字在整个程序期间存在,称为&quot;静态{static}&quot;生命周期.</p>
<p>所以这是有效的 - 我们向 Rust 保证字符串切片总是指向这样的<code>静态{static}</code>字符串:</p>
<pre><pre class="playpen"><code class="language-rust">// life2.rs

#[derive(Debug)]
struct A {
    s: &amp;'static str
}

fn main() {
    let a = A { s: &quot;hello dammit&quot; };

    println!(&quot;{:?}&quot;, a);
}
// A { s: &quot;hello dammit&quot; }
</code></pre></pre>
<p>这不是最 <em>漂亮</em> 符号,但有时丑是精确的必要代价.</p>
<p>这也可以用来指定从函数返回的字符串片段:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn how(i: u32) -&gt; &amp;'static str {
    match i {
    0 =&gt; &quot;none&quot;,
    1 =&gt; &quot;one&quot;,
    _ =&gt; &quot;many&quot;
    }
}
#}</code></pre></pre>
<p>这适用于静态字符串的特殊情况,但这是非常严格的.</p>
<p>但是我们可以指定<code>引用{&amp;}</code>的生命周期 <em>至少与之一样长</em> 就像结构本身一样.</p>
<pre><pre class="playpen"><code class="language-rust">// life3.rs

#[derive(Debug)]
struct A &lt;'a&gt; {
    s: &amp;'a str
}

fn main() {
    let s = &quot;I'm a little string&quot;.to_string();
    let a = A { s: &amp;s };

    println!(&quot;{:?}&quot;, a);
}
</code></pre></pre>
<p><code>生命周期{Lifetimes}</code>通常被称为'a','b'等,您也可以写'我{me}'.</p>
<p>在这之后,我们的<code>a</code>结构和<code>s</code>字符串受到严格合同的约束: <code>a</code>借用<code>s</code>,并且不能超越<code>s</code>.</p>
<p>有了这个结构体定义,我们想写一个函数返回一个<code>A</code>值:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn makes_a() -&gt; A {
    let string = &quot;I'm a little string&quot;.to_string();
    A { s: &amp;string }
}
#}</code></pre></pre>
<p>但 <code>A</code> 需要 lifetime - &quot;预期生命周期参数{expected lifetime parameter}&quot;:</p>
<pre><code>  = help: this function's return type contains a borrowed value,
   but there is no value for it to be borrowed from
  = help: consider giving it a 'static lifetime
</code></pre>
<p><code>rustc</code>提供建议,所以我们遵循它:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn makes_a() -&gt; A&lt;'static&gt; {
    let string = &quot;I'm a little string&quot;.to_string();
    A { s: &amp;string }
}
#}</code></pre></pre>
<p>而现在的错误是</p>
<pre><code>8 |      A { s: &amp;string }
  |              ^^^^^^ does not live long enough
9 | }
  | - borrowed value only lives until here
</code></pre>
<p>这是无法安全工作的,因为<code>string</code>将在函数结束时被删除,并且引用不可以超过<code>string</code>.</p>
<p>您可以将生命周期参数视为值类型的一部分.</p>
<p>有时候,结构中包含一个值 <em>和</em> 从该值中借用的引用 似乎是个好主意. 这基本上是不可能的,因为结构必须是 <em>可移动的</em> ,任何移动都将使引用无效. 没有必要这样做 - 例如,如果你的结构有一个字符串字段-string,并且需要提供切片-str,那么它可以保留索引并且有一个方法来生成实际的切片.</p>
<a class="header" href="print.html#a特点traits" id="a特点traits"><h2>特点{Traits}</h2></a>
<p>请注意 Rust 不会拼写<code>struct</code> <em>class</em>. 关键字<code>类</code>在其他语言中是如此超载,意味着它有效地闭包了原来的想法.</p>
<p>让我们这样说吧:  Rust 结构不能 <em>继承</em> 来自其他结构;他们都是独特的类型. 没有 <em>sub-typing{子}</em> . 他们是愚蠢的数据.</p>
<p>又怎样 <em>做</em> 一个建立类型之间的关系? 这正是 <em>Traits</em> 进来的时候.</p>
<p><code>rustc</code>经常谈到<code>实现{implementing} x 特点{trait}</code>所以现在是时候正确地讨论 <em>Traits</em> 了.</p>
<p>这里有一个定义 <em>Traits</em> 的例子 <em>implementing</em> 它适用于特定类型.</p>
<pre><pre class="playpen"><code class="language-rust">// trait1.rs

trait Show {
    fn show(&amp;self) -&gt; String;
}

impl Show for i32 {
    fn show(&amp;self) -&gt; String {
        format!(&quot;four-byte signed {}&quot;, self)
    }
}

impl Show for f64 {
    fn show(&amp;self) -&gt; String {
        format!(&quot;eight-byte float {}&quot;, self)
    }
}

fn main() {
    let answer = 42;
    let maybe_pi = 3.14;
    let s1 = answer.show();
    let s2 = maybe_pi.show();
    println!(&quot;show {}&quot;, s1);
    println!(&quot;show {}&quot;, s2);
}
// show four-byte signed 42
// show eight-byte float 3.14
</code></pre></pre>
<p>它太酷了;我们有 <em>增加了一种新方法</em> 二者皆是<code>i32</code>和<code>f64</code>!</p>
<p>熟悉 Rust 就会学习标准库的基本trait (他们倾向于打包) .</p>
<p><code>Debug</code>是非常普遍的. 我们给<code>Person</code>一个方便的默认实现<code>#[derive(Debug)]</code>,但说我们想要一个<code>Person</code>以全名显示:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fmt;

impl fmt::Debug for Person {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;{}&quot;, self.full_name())
    }
}
...
    println!(&quot;{:?}&quot;, p);
    // John Smith
#}</code></pre></pre>
<p><code>write!</code>是一个非常有用的宏 - 在这里<code>f</code>是实现<code>Write</code>.  (这也适用于<code>File</code>- 甚至是一个<code>String</code>. )</p>
<p><code>显示{Display}</code>控制如何使用&quot;{}&quot;打印值,并执行就像<code>Debug</code>. 作为一个有用的副作用,任何实现<code>Display</code>的,<code>ToString</code>自动实施. - 所以如果我们实现<code>Person</code>的<code>Display</code>, <code>p.to_string()</code>也适用.</p>
<p><code>Clone</code>定义了该方法<code>clone</code>,并且用&quot;#[deriv(Clone)]&quot;可以简单地定义,如果所有的字段都实施<code>Clone</code>.</p>
<a class="header" href="print.html#a示例-遍历浮点范围的迭代器" id="a示例-遍历浮点范围的迭代器"><h2>示例: 遍历浮点范围的迭代器</h2></a>
<p>我们已经遇到范围之前 (<code>0..n</code>) 但它们不适用于浮点值.  (您可以 <em>强制性</em> 这一点,但最终你会得到一个无趣的1.0. )</p>
<p>回想一下迭代器的非正式定义;它是一个带有结构体和可能会返回<code>Some</code>事情或<code>None</code>的<code>next</code>方法. 在这个过程中,迭代器本身被修改,它保持迭代的状态 (如 next 索引等等) . 迭代的数据通常不会改变, (但请参阅<code>Vec::drain</code>对于修改其数据的有趣的迭代器) .</p>
<p>这里是正式的定义: <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">迭代器trait</a>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Iterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
    ...
}
#}</code></pre></pre>
<p>我们在这里看到了<code>迭代器</code> trait 的<a href="https://doc.rust-lang.org/stable/book/associated-types.html">关联类型{associated type}</a>. 这个 trait 必须适用于任何类型,所以你必须以某种方式指定返回类型. 方法<code>next</code>可以在不使用特定类型的情况下编写 - 而是通过<code>Self</code>引用该类型参数的<code>Item</code>.</p>
<p><code>f64</code>迭代器 trait 写入<code>Iterator&lt;Item=f64&gt;</code>,它可以理解为&quot;Iterator的关联类型Item设置为f64&quot;.</p>
<p>该<code>...</code>指的是<code>迭代器</code>的  <em>提供的方法</em> . 你只需要定义<code>Item</code>和<code>next</code>,并为您定义提供的方法.</p>
<pre><pre class="playpen"><code class="language-rust">// trait3.rs

struct FRange {
    val: f64,
    end: f64,
    incr: f64
}

fn range(x1: f64, x2: f64, skip: f64) -&gt; FRange {
    FRange {val: x1, end: x2, incr: skip}
}

impl Iterator for FRange {
    type Item = f64;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        let res = self.val;
        if res &gt;= self.end {
            None
        } else {
            self.val += self.incr;
            Some(res)
        }
    }
}


fn main() {
    for x in range(0.0, 1.0, 0.1) {
        println!(&quot;{} &quot;, x);
    }
}
</code></pre></pre>
<p>而相当凌乱的结果是</p>
<pre><code>0
0.1
0.2
0.30000000000000004
0.4
0.5
0.6
0.7
0.7999999999999999
0.8999999999999999
0.9999999999999999
</code></pre>
<p>这是因为0.1不能精确表示为float,所以需要一些格式化帮助. 更换<code>println!</code></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
println!(&quot;{:.1} &quot;, x);
#}</code></pre></pre>
<p>我们得到更清洁的产出 (这个<a href="https://doc.rust-lang.org/std/fmt/index.html">格式</a>意思是'小数点后一位小数'. ) 所有默认的迭代器方法都可用,所以我们可以将这些值收集到一个<code>向量{Vec}</code>中,map 来使用它们等等.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let v: Vec&lt;f64&gt; = range(0.0, 1.0, 0.1).map(|x| x.sin()).collect();
#}</code></pre></pre>
<a class="header" href="print.html#a通用函数" id="a通用函数"><h2>通用函数</h2></a>
<p>我们需要一个函数来抛出实现的任何值<code>Debug</code>. 以下是对通用函数的第一次尝试,我们可以在其中传递引用 <em>任何</em> 价值类型. <code>T</code>是一个类型参数,需要在函数名称后面声明:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn dump&lt;T&gt; (value: &amp;T) {
    println!(&quot;value is {:?}&quot;,value);
}

let n = 42;
dump(&amp;n);
#}</code></pre></pre>
<p>但是, Rust 显然对这种通用类型一无所知<code>T</code>:</p>
<pre><code>error[E0277]: the trait bound `T: std::fmt::Debug` is not satisfied
...
   = help: the trait `std::fmt::Debug` is not implemented for `T`
   = help: consider adding a `where T: std::fmt::Debug` bound
</code></pre>
<p>为了这个工作, Rust 需要被告知<code>T</code>确实实施<code>Debug</code>!</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn dump&lt;T&gt; (value: &amp;T)
where T: std::fmt::Debug {
    println!(&quot;value is {:?}&quot;,value);
}

let n = 42;
dump(&amp;n);
// value is 42
#}</code></pre></pre>
<p>Rust 通用函数需要 <em>Traits bounds</em> 类型 - 我们在这里说&quot;T是实现了Debug的任何类型&quot;. <code>rustc</code>是非常有用的,并且确切地说明需要提供什么界限.</p>
<p>现在 Rust 知道这个 <em>trait</em> <code>T</code>,它可以给你敏感的编译器消息:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Foo {
    name: String
}

let foo = Foo{name: &quot;hello&quot;.to_string()};

dump(&amp;foo)
#}</code></pre></pre>
<p>而错误是&quot;<code>Foo</code> <em>Traits</em>  没有实施 <code>std::fmt::Debug</code>&quot;.</p>
<p>函数在动态语言中已经是泛型的,因为值会带有它们的实际类型,并且类型检查在运行时发生 - 或者惨败. 对于较大的程序,我们确实想在编译时想知道问题!这些语言的程序员不应平静地坐在编译器的错误之中,而必须处理程序运行时才会出现的问题. 墨菲定律意味着这些问题往往会发生在 最不方便/灾难性 的时刻.</p>
<p>平方数的操作是通用的: <code>x * x</code>将适用于整数,浮点数和一般用于任何关于乘法运算符的知识<code>*</code>. 但是类型边界是什么?</p>
<pre><pre class="playpen"><code class="language-rust">// gen1.rs

fn sqr&lt;T&gt; (x: T) -&gt; T {
    x * x
}

fn main() {
    let res = sqr(10.0);
    println!(&quot;res {}&quot;,res);
}
</code></pre></pre>
<p>第一个问题是 Rust 不知道<code>T</code>可以乘以:</p>
<pre><code>error[E0369]: binary operation `*` cannot be applied to type `T`
 --&gt; gen1.rs:4:5
  |
4 |     x * x
  |     ^
  |
note: an implementation of `std::ops::Mul` might be missing for `T`
 --&gt; gen1.rs:4:5
  |
4 |     x * x
  |     ^
</code></pre>
<p>遵循编译器的建议,让我们使用限制该类型参数<a href="https://doc.rust-lang.org/std/ops/trait.Mul.html">这个 Traits</a>,用于实现乘法运算符<code>*</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn sqr&lt;T&gt; (x: T) -&gt; T
where T: std::ops::Mul {
    x * x
}
#}</code></pre></pre>
<p>哪个仍然不起作用:</p>
<pre><code>rror[E0308]: mismatched types
 --&gt; gen2.rs:6:5
  |
6 |     x * x
  |     ^^^ expected type parameter, found associated type
  |
  = note: expected type `T`
  = note:    found type `&lt;T as std::ops::Mul&gt;::Output`
</code></pre>
<p>什么<code>rustc</code>是说这种类型的<code>x * x</code>是关联的类型<code>T::Output</code>,而不是<code>T</code>. 实际上没有理由说<code>x * x</code>与<code>x</code>类型相同,例如,两个向量的点积是一个标量.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn sqr&lt;T&gt; (x: T) -&gt; T::Output
where T: std::ops::Mul {
    x * x
}
#}</code></pre></pre>
<p>现在的错误是:</p>
<pre><code>error[E0382]: use of moved value: `x`
 --&gt; gen2.rs:6:7
  |
6 |     x * x
  |     - ^ value used here after move
  |     |
  |     value moved here
  |
  = note: move occurs because `x` has type `T`, which does not implement the `Copy` trait
</code></pre>
<p>所以,我们需要进一步限制类型!</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn sqr&lt;T&gt; (x: T) -&gt; T::Output
where T: std::ops::Mul + Copy {
    x * x
}
#}</code></pre></pre>
<p>那 (终于) 起作用了. 冷静地倾听编译器经常会让你更接近魔术点,当各种各样的事情干净地编译时.</p>
<p>确实, 它 <em>是</em> 在 C ++ 中更简单一点:</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
T sqr(x: T) {
    return x * x;
}
</code></pre>
<p>但 (说实话)  C ++ 在这里采用牛仔策略.  C ++ <code>模板{template}</code>错误很不好,因为所有的编译器都知道 (最终) 是某些操作符或方法没有被定义.  C ++ 委员会知道这是一个问题,所以他们正在努力<a href="https://en.wikipedia.org/wiki/Concepts_(C%2B%2B)">概念</a>,这几乎与 Rust 中的<code>trait约束类型</code>参数非常相似.</p>
<p>Rust 通用函数一开始可能看起来有点难接受,但是显式意味着只要看看定义,就能确切地知道可以安全地提供哪种值.</p>
<p>这些函数被调用 <em>单态{monomorphic}</em> ,与 <em>多态{polymorphic}</em> 相反 . 函数的主体是为每个 唯一类型 分别编译的. 通过多态函数,相同的机器代码可以动态地与每种匹配类型一起工作 <em>调度{dispatching}</em> 正确的方法.</p>
<p><code>Monomorphic</code>生成更快的代码,专用于特定类型,并且通常可以 <em>内联{inlined}</em>. 所以何时<code>sqr(x)</code>被看到,它被有效地取代<code>x * x</code>. 缺点是大的泛型函数会产生大量的代码,对于每一种可能导致的类型 <em>代码膨胀</em>. 与往常一样,总是有折衷的方式; 有经验的人学会为工作做出正确的选择.</p>
<a class="header" href="print.html#a简单的枚举" id="a简单的枚举"><h2>简单的枚举</h2></a>
<p><code>枚举{enums}</code>类型具有一些确定的值. 例如,一个方向只有四个可能的值.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Direction {
    Up,
    Down,
    Left,
    Right
}
...
    // `start` is type `Direction`
    let start = Direction::Left;
#}</code></pre></pre>
<p>他们可以在结构上定义方法,就像结构一样. 该<code>match</code>表达是处理<code>enum</code>值的基本方式.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Direction {
    fn as_str(&amp;self) -&gt; &amp;'static str {
        match *self { // *self has type Direction
            Direction::Up =&gt; &quot;Up&quot;,
            Direction::Down =&gt; &quot;Down&quot;,
            Direction::Left =&gt; &quot;Left&quot;,
            Direction::Right =&gt; &quot;Right&quot;
        }
    }
}
#}</code></pre></pre>
<p>标点符号很重要. 注意<code>self</code>之前的<code>*</code>. 很容易忘记,因为 Rust 经常会假设它 (我们说过<code>self.first_name</code>,而不是<code>(*self).first_name</code>) . 但是,<code>匹配{matching}</code>是一个更精确的业务. 将它排除在外可能会产生一大堆消息,这些消息可归结为这种类型的不匹配:</p>
<pre><code>   = note: expected type `&amp;Direction`
   = note:    found type `Direction`
</code></pre>
<p>这是因为<code>self</code>有类型<code>&amp;Direction</code>,所以我们必须投入<code>*</code> <em>deference{取值}</em> .</p>
<p>像结构一样,枚举可以实现 traits ,也可以实现我们的朋友<code>#[derive(Debug)]</code>可以添加到<code>Direction</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
        println!(&quot;start {:?}&quot;,start);
        // start Left
#}</code></pre></pre>
<p>所以<code>as_str</code>方法并不是真的必要,因为我们总是可以从<code>Debug</code>中得到名字.  (但<code>as_str</code>是 <em>不分配{allocate}</em> ,这可能很重要.)</p>
<p>你不应该在这里假设任何特定的顺序 - 没有的默许整数&quot;ordinal&quot;值.</p>
<p>这里有一个方法来定义每个<code>方向</code>值的'后继者'. 非常方便的<em>通配符用法</em>将枚举名称暂时放入方法上下文中：:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    fn next(&amp;self) -&gt; Direction {
        use Direction::*;
        match *self {
            Up =&gt; Right,
            Right =&gt; Down,
            Down =&gt; Left,
            Left =&gt; Up
        }
    }
    ...

    let mut d = start;
    for _ in 0..8 {
        println!(&quot;d {:?}&quot;, d);
        d = d.next();
    }
    // d Left
    // d Up
    // d Right
    // d Down
    // d Left
    // d Up
    // d Right
    // d Down
#}</code></pre></pre>
<p>所以这将在这个特定的,任意的顺序中通过各个方向循环不休. 它 (事实上) 非常简单状态机.</p>
<p>这些枚举值无法比较:</p>
<pre><code>assert_eq!(start, Direction::Left);

error[E0369]: binary operation `==` cannot be applied to type `Direction`
  --&gt; enum1.rs:42:5
   |
42 |     assert_eq!(start, Direction::Left);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
note: an implementation of `std::cmp::PartialEq` might be missing for `Direction`
  --&gt; enum1.rs:42:5
</code></pre>
<p>解决办法就是加上<code>#[derive(Debug,PartialEq)]</code>在<code>enum Direction</code>前面. 这是一个重要的观点 -   Rust 用户定义的类型一开始就是这么新鲜和朴素.</p>
<p>你通过 impl 共同的特点给他们合理的默认行为. 这也适用于结构 - 如果你要求 Rust 得出 <em>derive</em> <code>PartialEq</code>对于一个结构体来说,它会做出明智的事情,假设所有的字段都实现它并建立一个比较. 如果不是这样,或者你想重新定义平等,那么你可以自由明确定义<code>PartialEq</code>.</p>
<p>Rust 也有'C 风格的枚举':</p>
<pre><pre class="playpen"><code class="language-rust">// enum2.rs

enum Speed {
    Slow = 10,
    Medium = 20,
    Fast = 50
}

fn main() {
    let s = Speed::Slow;
    let speed = s as u32;
    println!(&quot;speed {}&quot;, speed);
}
</code></pre></pre>
<p>它们用一个整数值进行初始化,并可以通过类型转换将其转换为该整数.</p>
<p>你只需要给名字一个值,然后每次增加一个值:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Difficulty {
    Easy = 1,
    Medium,  // is 2
    Hard   // is 3
}
#}</code></pre></pre>
<p>顺便说一下,'名字'太模糊了,就像一直在说'thingy'. 这里的合适名词是 <em>变种{variant}</em> -<code>速度-Speed</code>有变种<code>慢-Slow</code>,<code>中-Medium</code>和<code>快速-Fast</code>.</p>
<p>这些枚举 <em>就</em> 有一个自然的顺序,但你必须很好地问. 在<code>enum Speed</code>前面放置<code>#[derive(PartialEq,PartialOrd)]</code>,那确实如此<code>Speed::Fast &gt; Speed::Slow</code>和<code>Speed::Medium != Speed::Slow</code>.</p>
<a class="header" href="print.html#a枚举赌上全部荣耀" id="a枚举赌上全部荣耀"><h2>枚举赌上全部荣耀</h2></a>
<p>完全形式的rust 类似于类固醇上的 C 联盟,就像 菲亚特Uno 与 法拉利 相比,. 考虑以 类型安全的方式 存储不同值的问题.</p>
<pre><pre class="playpen"><code class="language-rust">// enum3.rs

#[derive(Debug)]
enum Value {
    Number(f64),
    Str(String),
    Bool(bool)
}

fn main() {
    use Value::*;
    let n = Number(2.3);
    let s = Str(&quot;hello&quot;.to_string());
    let b = Bool(true);

    println!(&quot;n {:?} s {:?} b {:?}&quot;, n,s,b);
}
// n Number(2.3) s Str(&quot;hello&quot;) b Bool(true)
</code></pre></pre>
<p>同样,这个枚举只能包含 <em>一个</em> 这些价值;其大小将是 最大变体 的大小.</p>
<p>到目前为止,并不是真正的超级跑车,虽然枚举知道如何打印出来是很酷的. 但他们也知道如何 <em>哪一种</em> 它们包含的价值,和 <em>还有</em> <code>match</code>的超级力量:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn eat_and_dump(v: Value) {
    use Value::*;
    match v {
        Number(n) =&gt; println!(&quot;number is {}&quot;, n),
        Str(s) =&gt; println!(&quot;string is '{}'&quot;, s),
        Bool(b) =&gt; println!(&quot;boolean is {}&quot;, b)
    }
}
....
eat_and_dump(n);
eat_and_dump(s);
eat_and_dump(b);
//number is 2.3
//string is 'hello'
//boolean is true
#}</code></pre></pre>
<p>(这就是<code>Option</code>和<code>Result</code> - 枚举.)</p>
<p>我们喜欢这个<code>eat_and_dump</code>函数,但我们希望将该值作为引用传递,因为当前发生了<code>移动{move}</code>并且该值被'吃掉'了:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn dump(v: &amp;Value) {
    use Value::*;
    match *v {  // type of *v is Value
        Number(n) =&gt; println!(&quot;number is {}&quot;, n),
        Str(s) =&gt; println!(&quot;string is '{}'&quot;, s),
        Bool(b) =&gt; println!(&quot;boolean is {}&quot;, b)
    }
}

error[E0507]: cannot move out of borrowed content
  --&gt; enum3.rs:12:11
   |
12 |     match *v {
   |           ^^ cannot move out of borrowed content
13 |     Number(n) =&gt; println!(&quot;number is {}&quot;,n),
14 |     Str(s) =&gt; println!(&quot;string is '{}'&quot;,s),
   |         - hint: to prevent move, use `ref s` or `ref mut s`
#}</code></pre></pre>
<p>借用引用, 你无法做到.  Rust 不会让你 <em>提取</em> 包含在原始值中的字符串. 它没有抱怨<code>Number</code>因为它很高兴复制<code>f64</code>,但是<code>String</code>不执行<code>Copy</code>.</p>
<p>我之前提到过<code>match</code>挑剔于精确 <em>类型;</em> 在这里,我们按照提示进行操作;</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn dump(v: &amp;Value) {
    use Value::*;
    match *v {
        Number(n) =&gt; println!(&quot;number is {}&quot;, n),
        Str(ref s) =&gt; println!(&quot;string is '{}'&quot;, s),
        Bool(b) =&gt; println!(&quot;boolean is {}&quot;, b)
    }
}
    ....

    dump(&amp;s);
    // string is 'hello'
#}</code></pre></pre>
<p>现在我们只是借用对包含字符串的引用. 在我们继续前进之前,充满了成功的 Rust 编辑的欣快感,让我们暂停一下. <code>rustc</code>在生成足够上下文以供人类使用非常优秀的 <em>修正</em> 错误,但不一定 <em>理解</em> 错误.</p>
<p>这个问题是 match 的正确性,以及 借用检查者 决定阻止任何违反规则的企图的结合. 其中一条规则是你不能抽出属于某种拥有类型的价值.  C ++ 的一些知识在这里是一个障碍,因为 C ++ 将复制出问题的方式,无论是复制甚至是 <em>说得通</em> . 如果你尝试从一个 Vec 中抽出一个字符串,你会得到完全相同的错误<code>*v.get(0).unwrap()</code> (因为索引返回引用 使用<code>*</code>. )它不会让你这样做. (有时<code>clone</code>这不是一个坏的解决方案.)</p>
<p>(顺便一提,正是出于这个原因,<code>v[0]</code>,它不适用于像字符串这样的非可复制值. 你必须或者借用<code>&amp;v[0]</code>或使用 <code>v[0].clone()</code>)</p>
<p>至于<code>match</code>,你可以看到<code>Str(s)=&gt;</code>作为<code>Str(s: String)=&gt;</code>的简称. 局部变量(通常称为 <em>绑定</em> ) 被建造. 通常推断的类型很酷,当你吃掉一个值并提取其内容时. 但我们真正需要的是<code>s: &amp;String</code>,和<code>ref</code>是一个暗示,确保这一点: 我们只是想借用该字符串.</p>
<p>在这里,我们确实想提取该字符串,并且不关心之后的枚举值. <code>_</code>像往常一样会匹配任何东西</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Value {
    fn to_str(self) -&gt; Option&lt;String&gt; {
        match self {
        Value::Str(s) =&gt; Some(s),
        _ =&gt; None
        }
    }
}
    ...
    println!(&quot;s? {:?}&quot;, s.to_str());
    // s? Some(&quot;hello&quot;)
    // println!(&quot;{:?}&quot;, s) // error! s has moved...
#}</code></pre></pre>
<p>命名重要 - 这就是所谓的<code>to_str</code>,不是<code>as_str</code>. 你可以编写一个方法,只是将该字符串作为一个借用<code>Option&lt;&amp;String&gt;</code> (引用 将需要与 枚举变量 相同的生命周期. ) 但是你不会调用<code>to_str</code>.</p>
<p>你可以写<code>to_str</code>像这样 - 它完全等价:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    fn to_str(self) -&gt; Option&lt;String&gt; {
        if let Value::Str(s) = self {
            Some(s)
        } else {
            None
        }
    }
#}</code></pre></pre>
<a class="header" href="print.html#a更多关于匹配" id="a更多关于匹配"><h2>更多关于匹配</h2></a>
<p>回想一下,元组的值可以用'()'来提取:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let t = (10,&quot;hello&quot;.to_string());
    ...
    let (n,s) = t;
    // t has been moved. It is No More
    // n is i32, s is String
#}</code></pre></pre>
<p>这是一个特例</p>
<p><em>解构{destructuring}</em>;_我们有一些数据,并希望将其分开 (像这里) 或只是借用它的值. 无论哪种方式,我们都可以得到结构的各个部分.</p>
<p>语法与在中使用的相似<code>match</code>. 这里我们明确地借用了这些值.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let (ref n,ref s) = t;
    // n and s are borrowed from t. It still lives!
    // n is &amp;i32, s is &amp;String
#}</code></pre></pre>
<p>解构与结构一起工作:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    struct Point {
        x: f32,
        y: f32
    }

    let p = Point{x:1.0,y:2.0};
    ...
    let Point{x,y} = p;
    // p still lives, since x and y can and will be copied
    // both x and y are f32
#}</code></pre></pre>
<p>前两种模式是<code>let</code>解构 , 下面时间看看<code>match</code>新的模式. - 它只匹配第一个元素为零的元组,而不是 <em>任何</em> 字符串; 第二个增加了一个<code>if</code>所以它只匹配<code>(1, &quot;hello&quot;)</code>. 最后,只是一个变量匹配 <em>随便</em>. 这是有用的,如果<code>match</code>适用于表达式,并且不希望将变量绑定到该表达式. <code>_</code>像变量一样工作,但被忽略. 这是完成一个常用的方法<code>match</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn match_tuple(t: (i32,String)) {
    let text = match t {
        (0, s) =&gt; format!(&quot;zero {}&quot;, s),
        (1, ref s) if s == &quot;hello&quot; =&gt; format!(&quot;hello one!&quot;),
        tt =&gt; format!(&quot;no match {:?}&quot;, tt),
        // or say _ =&gt; format!(&quot;no match&quot;) if you're not interested in the value
     };
    println!(&quot;{}&quot;, text);
}
#}</code></pre></pre>
<p>为什么不匹配<code>(1,&quot;hello&quot;)</code>? 匹配是一个确切,编译器会抱怨:</p>
<pre><code>  = note: expected type `std::string::String`
  = note:    found type `&amp;'static str`
</code></pre>
<p>我们为什么需要<code>ref s</code>? 这是一个稍微隐晦的问题 (查找E00008错误) ,如果你有一个需要借用<em>守卫</em>,当守卫发生在不同的环境中,否则将会发生移动. 这是实施漏洞的情况.</p>
<p>如果类型 <em>是</em> <code>&amp;str</code>那么我们直接匹配它:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    match (42,&quot;answer&quot;) {
        (42,&quot;answer&quot;) =&gt; println!(&quot;yes&quot;),
        _ =&gt; println!(&quot;no&quot;)
    };
#}</code></pre></pre>
<p><code>match</code>要使用<code>if let</code>的情况. 这是一个很酷的例子,因为如果我们得到一个<code>Some</code>,我们可以在里面匹配,只从元组中提取字符串. 所以没有必要嵌套<code>if let</code>陈述在这里. 我们用<code>_</code>因为我们对元组的第一部分不感兴趣.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let ot = Some((2,&quot;hello&quot;.to_string());

    if let Some((_,ref s)) = ot {
        assert_eq!(s, &quot;hello&quot;);
    }
    // we just borrowed the string, no 'destructive destructuring'
#}</code></pre></pre>
<p>使用<code>解析{parse}</code>时会出现一个有趣的问题 (或任何需要从上下文中计算出其返回 类型 的函数)</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    if let Ok(n) = &quot;42&quot;.parse() {
        ...
    }
#}</code></pre></pre>
<p>那么,这是什么类型的<code>n</code>? 不知何故,你必须提供一个提示 - 什么样的整数?它甚至是一个整数?</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    if let Ok(n) = &quot;42&quot;.parse::&lt;i32&gt;() {
        ...
    }
#}</code></pre></pre>
<p>这种不太优雅的语法被称为&quot;涡轮运算符{turbofish operator}&quot;.</p>
<p>如果你正在返回一个函数<code>Result</code>,那么问号运算符提供了一个更加优雅的解决方案:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let n: i32 = &quot;42&quot;.parse()?;
#}</code></pre></pre>
<p>但是,解析错误需要转换为错误类型<code>Result</code>,这是我们稍后讨论时要讨论的话题<a href="./6-error-handling.zh.html">6.错误处理</a>.</p>
<a class="header" href="print.html#a闭包closures" id="a闭包closures"><h2>闭包{Closures}</h2></a>
<p>Rust 的很多力量来源于 <em>闭包</em>. 它们最简单的形式就像快捷函数一样:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let f = |x| x * x;

    let res = f(10);

    println!(&quot;res {}&quot;, res);
    // res 100
#}</code></pre></pre>
<p>在这个例子中没有明确的类型 - 一切都是从整数字面量10开始推导出来的.</p>
<p>如果我们运行,我们会收到错误<code>f</code>在不同类型 -   Rust 已经决定<code>f</code>必须在整数类型上调用:</p>
<pre><code>    let res = f(10);

    let resf = f(1.2);
  |
8 |     let resf = f(1.2);
  |                  ^^^ expected integral variable, found floating-point variable
  |
  = note: expected type `{integer}`
  = note:    found type `{float}`
</code></pre>
<p>所以,第一次调用修复了参数的类型<code>x</code>. 这相当于这个函数:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    fn f (x: i32) -&gt; i32 {
        x * x
    }
#}</code></pre></pre>
<p>但函数和闭包之间存在很大差异,<em>体现</em> 在明确的类型需要. 这里我们评估一个线性函数:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let m = 2.0;
    let c = 1.0;

    let lin = |x| m*x + c;

    println!(&quot;res {} {}&quot;, lin(1.0), lin(2.0));
    // res 3 5
#}</code></pre></pre>
<p>你不能用明确的做<code>fn</code>形式 - 它不知道闭包范围内的变量. 闭包了是从其上下文 <em>借</em> <code>m</code>和<code>c</code>.</p>
<p>现在,这是什么类型<code>lin</code>? 只要<code>rustc</code>知道. 在引擎盖下,闭包是一个 <em>结构</em> 这是可调用的 ('实现调用操作符') . 它的行为就好像它是这样写出来的:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct MyAnonymousClosure1&lt;'a&gt; {
    m: &amp;'a f64,
    c: &amp;'a f64
}

impl &lt;'a&gt;MyAnonymousClosure1&lt;'a&gt; {
    fn call(&amp;self, x: f64) -&gt; f64 {
        self.m * x  + self.c
    }
}
#}</code></pre></pre>
<p>编译器当然是有帮助的,把简单的闭包语法变成所有的代码! 你确实需要知道闭包是一个 <em>结构</em> 和它 <em>借用</em> 来自其环境的价值. 因此它有一个 <em>lifetime</em>.</p>
<p>所有闭包都是独特的类型,但它们有共同的特点. 所以即使我们不知道确切的类型,我们知道一般的约束:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn apply&lt;F&gt;(x: f64, f: F) -&gt; f64
where F: Fn(f64)-&gt;f64  {
    f(x)
}
...
    let res1 = apply(3.0,lin);
    let res2 = apply(3.14, |x| x.sin());
#}</code></pre></pre>
<p>子曰: <code>应用{apply}</code>效劳于 <code>T</code>这样 的 <em>任何</em> 类型且具备<code>Fn(f64) -&gt; f64</code>时- 也就是说,这是一个需要的函数<code>f64</code>并返回<code>f64</code>.</p>
<p>运行<code>apply(3.0,lin)</code>后,试图访问<code>lin</code>给出一个有趣的错误:</p>
<pre><code>    let l = lin;
error[E0382]: use of moved value: `lin`
  --&gt; closure2.rs:22:9
   |
16 |     let res = apply(3.0,lin);
   |                         --- value moved here
...
22 |     let l = lin;
   |         ^ value used here after move
   |
   = note: move occurs because `lin` has type
    `[closure@closure2.rs:12:15: 12:26 m:&amp;f64, c:&amp;f64]`,
     which does not implement the `Copy` trait
</code></pre>
<p>就是这样,<code>apply</code>吃了我们的闭包. 还有这个结构的实际类型<code>rustc</code>弥补实施它. 始终将闭包视为结构是有帮助的.</p>
<p>调用闭包是 <em>方法调用</em>: 三种函数 trait 对应于三种方法:</p>
<ul>
<li><code>Fn</code> 结构传递为<code>&amp;self</code></li>
<li><code>FnMut</code> 结构传递为<code>&amp;mut self</code></li>
<li><code>FnOnce</code> 结构传递为<code>self</code></li>
</ul>
<p>所以闭包可能会改变它的 <em>来自上层</em> 引用:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    fn mutate&lt;F&gt;(mut f: F)
    where F: FnMut() {
        f()
    }
    let mut s = &quot;world&quot;;
    mutate(|| s = &quot;hello&quot;);
    assert_eq!(s, &quot;hello&quot;);
#}</code></pre></pre>
<p>注意<code>mut</code>-<code>f</code>需要可变这个工作.</p>
<p>但是,你无法逃避借用规则. 考虑这个:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = &quot;world&quot;;

// closure does a mutable borrow of s
let mut changer = || s = &quot;world&quot;;

changer();
// does an immutable borrow of s
assert_eq!(s, &quot;world&quot;);
#}</code></pre></pre>
<p>无法完成! 错误是我们不能借用<code>s</code>在声明中,因为它之前已经被闭包<code>changer</code>作为可变的借用过. 只要闭包存在,其他代码就不能访问<code>s</code>,所以解决方案是通过将闭包放在一个 有限的范围 内来控制这个生命周期:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = &quot;world&quot;;
{
    let mut changer = || s = &quot;world&quot;;
    changer();
}
assert_eq!(s, &quot;world&quot;);
#}</code></pre></pre>
<p>在这一点上,如果你习惯了 JavaScript 或 Lua 等语言,你可能会想到 Rust 闭包的复杂性,而不是它们在这些语言中的直截了当. 这是 Rust 承诺不作出任何分配的必要成本. 在 JavaScript 中,等效<code>mutate(function() {s = &quot;hello&quot;;})</code>, 这将始终导致动态分配闭包.</p>
<p>有时你不希望闭包借用这些变量,而是 <em>移动</em> 他们.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let name = &quot;dolly&quot;.to_string();
    let age = 42;

    let c = move || {
        println!(&quot;name {} age {}&quot;, name,age);
    };

    c();

    println!(&quot;name {}&quot;,name);
#}</code></pre></pre>
<p>最后的错误<code>println</code>是: &quot;使用移动值: <code>name</code>&quot;所以这里有一个解决方案 - 如果我们没有 <em>想保持</em> <code>name</code>活着 - 是将 复制副本 移入<code>闭包{move}</code>中:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let cname = name.to_string();
    let c = move || {
        println!(&quot;name {} age {}&quot;,cname,age);
    };
#}</code></pre></pre>
<p>为什么需要移动<code>闭包{move}</code>? 因为我们可能需要在 原始上下文不再存在 的地方调用它们. 经典案例是创建一个 <em>thread{线程}</em>. 移动的闭包不会借用,所以没有 <em>lifetime</em> .</p>
<blockquote>
<p>移动后, 线程中, 所使用的变量, 就会与 原上下文 没有关系了</p>
</blockquote>
<p>迭代器方法中主要使用闭包. 回想一下<code>范围{range}</code>我们定义的迭代器遍历一系列浮点数. 使用闭包对此 (或任何其他迭代器) 进行操作很简单:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let sine: Vec&lt;f64&gt; = range(0.0,1.0,0.1).map(|x| x.sin()).collect();
#}</code></pre></pre>
<p><code>map</code>没有在 Vec 上定义 (尽管很容易创建一个这样的 trait) ,因为那样 <em>一切</em> map 将创建一个新的 Vec . 这样,我们有一个选择. 总之,没有创建临时对象:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
 let sum: f64 = range(0.0,1.0,0.1).map(|x| x.sin()).sum();
#}</code></pre></pre>
<p>它 (事实上) 会像写出明确的循环一样快! 如果 Rust 闭包与 Javascript 闭包一样&quot;无摩擦{frictionless}&quot;,那么这种性能保证是不可能的.</p>
<p><code>filter</code>是另一种有用的迭代器方法 - 它只允许通过匹配条件的值:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let tuples = [(10,&quot;ten&quot;),(20,&quot;twenty&quot;),(30,&quot;thirty&quot;),(40,&quot;forty&quot;)];
    let iter = tuples.iter().filter(|t| t.0 &gt; 20).map(|t| t.1);

    for name in iter {
        println!(&quot;{} &quot;, name);
    }
    // thirty
    // forty
#}</code></pre></pre>
<a class="header" href="print.html#a三种迭代器" id="a三种迭代器"><h2>三种迭代器</h2></a>
<p>三种类型 (再次) 对应于三种基本参数类型.</p>
<p>假设我们有一个 Vec <code>String</code>值.以下是显式的迭代器类型,然后 <em>隐式{implicitly}</em>,以及迭代器返回的实际类型.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for s in vec.iter() {...} // &amp;String
for s in vec.iter_mut() {...} // &amp;mut String
for s in vec.into_iter() {...} // String

// implicit!
for s in &amp;vec {...} // &amp;String
for s in &amp;mut vec {...} // &amp;mut String
for s in vec {...} // String
#}</code></pre></pre>
<p>就我个人而言,我更喜欢明确,但了解这两种形式及其含义非常重要.</p>
<p><code>into_iter</code> <em>提取</em> Vec 并提取它的字符串,所以之后 Vec 不再可用 - 它已被移动. 这是 Pythonistas 过去常说的一个确定的问题<code>for s in vec</code>!</p>
<p>所以隐含的形式<code>for s in &amp;vec</code>通常是你想要的,就像<code>&amp;T</code>在向函数传递参数时是一个很好的默认值.</p>
<p>理解这三种类型是如何工作是很重要的,因为 Rust 严重依赖于类型推导 - 在闭包参数中你不会经常看到明确的类型. 这是一件好事, 因为如果所有这些类型都明确的话, 它的 <em>键入</em> 会很嘈杂. 当然,这个紧凑的代码的代价, 是你需要知道隐式类型究竟是什么!</p>
<p><code>map</code>取得迭代器返回的任何值并将其转换为其他值,但是<code>filter</code>需要一个 <em>引用</em> 到那个价值. 在这种情况下,我们正在使用<code>iter</code>所以迭代器项目类型是<code>&amp;String</code>. 注意<code>filter</code>接收到这种类型的引用.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for n in vec.iter().map(|x: &amp;String| x.len()) {...} // n is usize
....
}

for s in vec.iter().filter(|x: &amp;&amp;String| x.len() &gt; 2) { // s is &amp;String
...
}
#}</code></pre></pre>
<p>在调用方法时, Rust 会自动 <em>取值</em>,所以问题不明显. 但<code>|x:&amp;&amp; String|</code>x ==&quot;one&quot;|将 <em>不会</em> 工作, 因为操作员对 类型匹配 更加严格. <code>rustc</code>会抱怨没有这样进行比较<code>&amp;&amp;String</code>和<code>&amp;str</code>. 所以你需要明确的 取值 来做到<code>&amp;&amp;String</code>变成哪一个 <em>想要</em> match的<code>&amp;String</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for s in vec.iter().filter(|x: &amp;&amp;String| *x == &quot;one&quot;) {...}
// same as implicit form:
for s in vec.iter().filter(|x| *x == &quot;one&quot;) {...}
#}</code></pre></pre>
<p>如果省略显式类型,则可以修改参数以使其类型<code>s</code>就是现在<code>&amp;String</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for s in vec.iter().filter(|&amp;x| x == &quot;one&quot;)
#}</code></pre></pre>
<p>这通常是你将如何看待它写的.</p>
<a class="header" href="print.html#a动态数据的结构" id="a动态数据的结构"><h2>动态数据的结构</h2></a>
<p>一个最强大的技术是 <em>一个包含对自身引用的结构</em>.</p>
<p>这是 <em>二叉树</em> 的基本构建块,用 C 表示 (每个人最喜欢的老亲戚都喜欢使用没有保护的电动工具. )</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    struct Node {
        const char *payload;
        struct Node *left;
        struct Node *right;
    };
#}</code></pre></pre>
<p>你不能 <em>直接{directly}</em> 这样做 - 包含<code>Node</code>字段,因为那么<code>Node</code>的大小取决于<code>Node</code>的大小... 它只是不计算. 所以我们使用指针<code>Node</code>结构,因为指针的大小总是已知的.</p>
<p>如果<code>left</code>不是<code>NULL</code>,那<code>Node</code>将有一个<code>左{left}</code>指向另一个节点,因此无限期无限.</p>
<p>Rust 不会<code>NULL</code> (至少不 <em>安全</em>) , 所以这显然是一份<code>Option</code>. 但你不能只是把一个<code>Node</code>放在那<code>Option</code>里面,因为我们不知道<code>Node</code>的大小 (等等) . 这是<code>Box</code>一部分工作, 因为它分配了包含一个指向数据的指针,并且一直具有固定大小.</p>
<p>所以这里是 Rust 的等价物,使用<code>type</code>创建一个别名:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
type NodeBox = Option&lt;Box&lt;Node&gt;&gt;;

#[derive(Debug)]
struct Node {
    payload: String,
    left: NodeBox,
    right: NodeBox
}
#}</code></pre></pre>
<p>( Rust 以这种方式宽恕 - 不需要前瞻性声明. )</p>
<p>并且第一个测试程序:</p>
<pre><pre class="playpen"><code class="language-rust">impl Node {
    fn new(s: &amp;str) -&gt; Node {
        Node{payload: s.to_string(), left: None, right: None}
    }

    fn boxer(node: Node) -&gt; NodeBox {
        Some(Box::new(node))
    }

    fn set_left(&amp;mut self, node: Node) {
        self.left = Self::boxer(node);
    }

    fn set_right(&amp;mut self, node: Node) {
        self.right = Self::boxer(node);
    }

}


fn main() {
    let mut root = Node::new(&quot;root&quot;);
    root.set_left(Node::new(&quot;left&quot;));
    root.set_right(Node::new(&quot;right&quot;));

    println!(&quot;arr {:#?}&quot;, root);
}
</code></pre></pre>
<p>由于&quot;{:#?}&quot; ('#'表示'extended') ,输出结果非常漂亮.</p>
<pre><code>root Node {
    payload: &quot;root&quot;,
    left: Some(
        Node {
            payload: &quot;left&quot;,
            left: None,
            right: None
        }
    ),
    right: Some(
        Node {
            payload: &quot;right&quot;,
            left: None,
            right: None
        }
    )
}
</code></pre>
<p>现在, <code>root</code>被丢弃发生了什么 ? 所有字段都被删除; 如果树的&quot;分支&quot;被丢弃,<em>它们</em> 就会扔掉其字段等等. <code>Box::new</code>可能是最接近你会得到一个<code>new</code>关键字,但我们没有必要<code>delete</code>要么<code>free</code>.</p>
<p>我们现在必须为这棵树制定一个用途. 请注意,可以指定字符串 顺序: 'bar'&lt;'foo','abba'&gt;'aardvark';所谓的&quot;字母顺序&quot;.  (严格来说,这是词汇顺序,因为人类语言非常多样化,并且有着奇怪的规则. )</p>
<p>这是一个按字符串的顺序插入节点的方法. 我们将新数据与当前节点进行比较 - 如果较少,则尝试插入左侧,否则尝试插入右侧. 左边可能没有节点,那么<code>set_left</code>等等.</p>
<pre><pre class="playpen"><code class="language-rust">    fn insert(&amp;mut self, data: &amp;str) {
        if data &lt; &amp;self.payload {
            match self.left {
                Some(ref mut n) =&gt; n.insert(data),
                None =&gt; self.set_left(Self::new(data)),
            }
        } else {
            match self.right {
                Some(ref mut n) =&gt; n.insert(data),
                None =&gt; self.set_right(Self::new(data)),
            }
        }
    }

    ...
    fn main() {
        let mut root = Node::new(&quot;root&quot;);
        root.insert(&quot;one&quot;);
        root.insert(&quot;two&quot;);
        root.insert(&quot;four&quot;);

        println!(&quot;root {:#?}&quot;, root);
    }
</code></pre></pre>
<p>注意<code>match</code>- 我们会提供一个可变的引用<code>Option</code>,如果是<code>Some</code>的话,并应用<code>insert</code>方法. 否则,我们需要创建一个新的<code>Node</code>对于左侧等等. <code>Box</code>是一个 <em>聪明</em> 指针; 请注意,不需要&quot;拆箱{unboxing}&quot;来呼叫<code>Node</code>方法就可以了!</p>
<p>这里是输出树:</p>
<pre><code>root Node {
    payload: &quot;root&quot;,
    left: Some(
        Node {
            payload: &quot;one&quot;,
            left: Some(
                Node {
                    payload: &quot;four&quot;,
                    left: None,
                    right: None
                }
            ),
            right: None
        }
    ),
    right: Some(
        Node {
            payload: &quot;two&quot;,
            left: None,
            right: None
        }
    )
}
</code></pre>
<p>比其他字符串'小于'的字符串放在左侧,否则放在右侧.</p>
<p>参观时间. 这是 <em>按顺序遍历</em> - 我们访问左边,在节点上做点什么,然后访问右边.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    fn visit(&amp;self) {
        if let Some(ref left) = self.left {
            left.visit();
        }
        println!(&quot;'{}'&quot;, self.payload);
        if let Some(ref right) = self.right {
            right.visit();
        }
    }
    ...
    ...
    root.visit();
    // 'four'
    // 'one'
    // 'root'
    // 'two'
#}</code></pre></pre>
<p>所以我们按顺序访问这些字符串!请注意重新出现<code>ref</code>-<code>if let</code>使用与<code>match</code>是完全相同的规则.</p>
<a class="header" href="print.html#a通用结构" id="a通用结构"><h2>通用结构</h2></a>
<p>考虑前面的二叉树的例子. 这将是 <em>严重刺激</em> 不得不重写它, 当为了所有可能的有效载荷. 所以这是我们的通用<code>Node</code>与它的类型参数<code>T</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
type NodeBox&lt;T&gt; = Option&lt;Box&lt;Node&lt;T&gt;&gt;&gt;;

#[derive(Debug)]
struct Node&lt;T&gt; {
    payload: T,
    left: NodeBox&lt;T&gt;,
    right: NodeBox&lt;T&gt;
}
#}</code></pre></pre>
<p>该实现显示了语言之间的差异. 有效载荷的基本操作是比较,所以 T 必须与之相当<code>&lt;</code> 等等 impl <code>PartialOrd</code>. 必须在<code>impl</code>其中声明类型参数:</p>
<pre><pre class="playpen"><code class="language-rust">impl &lt;T: PartialOrd&gt; Node&lt;T&gt; {
    fn new(s: T) -&gt; Node&lt;T&gt; {
        Node{payload: s, left: None, right: None}
    }

    fn boxer(node: Node&lt;T&gt;) -&gt; NodeBox&lt;T&gt; {
        Some(Box::new(node))
    }

    fn set_left(&amp;mut self, node: Node&lt;T&gt;) {
        self.left = Self::boxer(node);
    }

    fn set_right(&amp;mut self, node: Node&lt;T&gt;) {
        self.right = Self::boxer(node);
    }

    fn insert(&amp;mut self, data: T) {
        if data &lt; self.payload {
            match self.left {
                Some(ref mut n) =&gt; n.insert(data),
                None =&gt; self.set_left(Self::new(data)),
            }
        } else {
            match self.right {
                Some(ref mut n) =&gt; n.insert(data),
                None =&gt; self.set_right(Self::new(data)),
            }
        }
    }
}


fn main() {
    let mut root = Node::new(&quot;root&quot;.to_string());
    root.insert(&quot;one&quot;.to_string());
    root.insert(&quot;two&quot;.to_string());
    root.insert(&quot;four&quot;.to_string());

    println!(&quot;root {:#?}&quot;, root);
}
</code></pre></pre>
<p>所以通用结构需要在 <code>&lt;&gt;</code> 中指定类型参数,如 C ++ .  Rust 通常足够聪明, 可以从上下文中得出这个类型参数 - 它知道它有一个<code>Node&lt;T&gt;</code>,并通过<code>T</code>已知道它的<code>insert</code>方法. <code>insert</code> 的第一次运行把<code>T</code>钉成为<code>String</code>. 如果有任何进一步的运行不一致,它会投诉.</p>
<p>但是你确实需要适当地限制这种类型!</p>
<a class="header" href="print.html#a文件系统和进程" id="a文件系统和进程"><h1>文件系统和进程</h1></a>
<a class="header" href="print.html#a再看看读取-files" id="a再看看读取-files"><h2>再看看读取 Files</h2></a>
<p>在 <a href="http://chinanf-boy.github.io/gentle-intro/1-basics.zh.html#a%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6">第1部分的末尾</a>,我展示了如何读取整个文件到字符串. 自然,这并不总是一个好主意,所以这里是如何逐行读取文件.</p>
<p><code>fs::File</code> impl{实现} 了<code>io::Read</code>,这是一个可读性的  trait  . 这个 trait 定义了一个能填补<code>u8</code>切片的字节<code>read</code>方法 - 这是唯一的 <em>要求</em>  trait 的方法,你会得到一些 <em>提供</em> 免费的方法,很像<code>Iterator</code>. 您可以使用<code>read_to_end</code>填 充可读的内容 到 字节 Vec, 还有<code>read_to_string</code>可以填充一个 string - 必须是 utf-8 编码.</p>
<p>这是一个'原始{raw}'阅读,没有缓冲. 对于缓冲阅读, 我们有<code>io::BufRead</code> trait ,给出 <code>read_line</code> 和一个<code>lines</code>迭代器{Iterator}. <code>io::BufReader</code>将给 <em>任何</em> 可读性 提供<code>io::BufRead</code>实现.</p>
<p><code>fs::File</code> <em>也</em> impl <code>io::Write</code>.</p>
<p>确保所有这些 traits 可用的最简单方法是<code>use std::io::prelude::*</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fs::File;
use std::io;
use std::io::prelude::*;

fn read_all_lines(filename: &amp;str) -&gt; io::Result&lt;()&gt; {
    let file = File::open(&amp;filename)?;

    let reader = io::BufReader::new(file);

    for line in reader.lines() {
        let line = line?;
        println!(&quot;{}&quot;, line);
    }
    Ok(())
}
#}</code></pre></pre>
<p>该<code>let line = line?</code>可能看起来有点奇怪. 该<code>line</code>返回的迭代器实际上是一个<code>io::Result&lt;String&gt;</code>我们用<code>?</code>解开它. 因为事情 <em>能够</em> 在迭代过程中出现错误 如: I/O错误,吞噬不是 utf-8 的字节块,等等.</p>
<p><code>line</code>作为一个迭代器,可以直接使用<code>collect</code>从一个文件读入一个字符串向量,或者用<code>enumerate</code>迭代器{Iterator}打印带行号的 line.</p>
<p>然而,这并不是读取 所有行 的最有效方式,因为每行都分配了一个新字符串. 使用<code>read_line</code>效率更高,虽然更尴尬. 请注意,返回的行包含换行符,可以使用<code>trim_right</code>进行移除.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let mut reader = io::BufReader::new(file);
    let mut buf = String::new();
    while reader.read_line(&amp;mut buf)? &gt; 0 {
        {
            let line = buf.trim_right();
            println!(&quot;{}&quot;, line);
        }
        buf.clear();
    }
#}</code></pre></pre>
<p>这导致分配少得多,因为 <em>clearing{清除}</em> 该字符串不释放其分配的内存;一旦字符串有足够的容量,不会再有分配.</p>
<p>这是我们使用一个<code>块{}</code>来控制借用的情况之一. <code>line</code>是借用的<code>buf</code>,这个借用必须在我们修改之前完成<code>buf</code>. Rust 再一次试图阻止我们做一些愚蠢的事情,那就是访问<code>line</code> <em>后</em> 我们已经清除了缓冲区.  (借阅检查者 有时可能会受到限制,rust 是由于&quot;非词汇生命周期{non-lexical  lifetimes}&quot;,它会分析代码并看到<code>buf.clear()</code>之后<code>line</code>不使用. )</p>
<p>这不是很漂亮. 我不能给你一个适当的迭代器,它返回缓冲区的引用,但我可以给你一些 <em>看起来像</em> 一个迭代器的东西.</p>
<p>首先定义一个通用结构体; 类型参数<code>R</code>是'任意实现 Read 的类型'. `它包含读者{reader} 和我们要借用的 缓冲区{buffer}.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// file5.rs
use std::fs::File;
use std::io;
use std::io::prelude::*;

struct Lines&lt;R&gt; {
    reader: io::BufReader&lt;R&gt;,
    buf: String
}

impl &lt;R: Read&gt; Lines&lt;R&gt; {
    fn new(r: R) -&gt; Lines&lt;R&gt; {
        Lines{reader: io::BufReader::new(r), buf: String::new()}
    }
    ...
}
#}</code></pre></pre>
<p>然后<code>next</code>方法. 它返回一个<code>Option</code>- 就像迭代器,当它返回<code>None</code>时迭代器{Iterator}结束. 返回的类型是一个<code>Result</code>是因为<code>read_line</code>可能会失败, 我们永远不要丢失错误 . 所以如果失败了,我们把它的错误包括进去<code>Some&lt;Result&gt;</code>. 否则,它可能读取了零字节,这是文件的自然结束 - 不是错误,只是一个<code>None</code>.</p>
<p>此时,缓冲区包含附有换行符 (<code>\n</code>) 的行. 修剪掉它,然后打包字符串片.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    fn next&lt;'a&gt;(&amp;'a mut self) -&gt; Option&lt;io::Result&lt;&amp;'a str&gt;&gt;{
        self.buf.clear();
        match self.reader.read_line(&amp;mut self.buf) {
            Ok(nbytes) =&gt; if nbytes == 0 {
                None // no more lines!
            } else {
                let line = self.buf.trim_right();
                Some(Ok(line))
            },
            Err(e) =&gt; Some(Err(e))
        }
    }
#}</code></pre></pre>
<p>现在,请注意 生命周期 如何工作. 我们需要明确的 lifetime ,因为 Rust 永远不会让我们在不知道他们的 lifetime 的情况下发放借用的字符串片. 在这里,我们说这个借用的字符串的 lifetime 在<code>self</code> lifetime 中.</p>
<p>而且 lifetime 的这个签名不兼容<code>迭代器{Iterator}</code>的接口. 但是如果兼容就很容易出现问题; 考虑<code>collect</code>试图制作这些字符串切片的 Vec . 这是不可能的,因为它们都是从同一个可变字符串中借用的! (如果您已 read <em>所有</em> 文件转换为字符串,然后是字符串<code>line</code>迭代器{Iterator}可以返回字符串切片,因为它们都是借用原始字符串的 <em>不同</em> 部分) .</p>
<p>由此产生的循环更清晰,文件缓冲对用户是不可见的.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn read_all_lines(filename: &amp;str) -&gt; io::Result&lt;()&gt; {
    let file = File::open(&amp;filename)?;

    let mut lines = Lines::new(file);
    while let Some(line) = lines.next() {
        let line = line?;
        println!(&quot;{}&quot;, line);
    }

    Ok(())
}
#}</code></pre></pre>
<p>你甚至可以这样写循环,字符串切片拉出来 显式匹配 :</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    while let Some(Ok(line)) = lines.next() {
        println!(&quot;{}&quot;, line)?;
    }
#}</code></pre></pre>
<p>这很诱人,但你在这里抛出一个可能的错误;每当发生错误时,此循环都会静静地停止. 特别是,它将停止在 Rust 无法将 line 转换为 utf-8 的第一个位置. 适合休闲代码,不适合生产代码!</p>
<a class="header" href="print.html#a写入到files" id="a写入到files"><h2>写入到Files</h2></a>
<p>我们遇到了<code>write!</code>宏当遇到<code>Debug</code>实现- 它也适用于任何实现<code>Write</code>的东西. 所以这是另一种<code>print!</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let mut stdout = io::stdout();
    ...
    write!(stdout,&quot;answer is {}\n&quot;, 42).expect(&quot;write failed&quot;);
#}</code></pre></pre>
<p>如果有 <em>可能的</em> 错误,你必须处理它. 它可能不是很 <em>容易</em> 但它可能发生. 它通常很好,因为如果你正在做文件 I/O 你应该在一个上下文中加入<code>?</code>.</p>
<p>但有一个区别: <code>print!</code>为每个写入锁定标准输出. 这通常是您想要输出的内容,因为没有锁定 多线程程序 可能会 以有趣的方式 混淆输出. 但是,如果你 抽出大量文字,那么<code>write!</code>将会变得更快.</p>
<p>对于任意文件我们用到<code>write!</code>. 在 <code>write_out</code>的结尾, <code>out</code>会扔掉文件自然关闭</p>
<pre><pre class="playpen"><code class="language-rust">// file6.rs
use std::fs::File;
use std::io;
use std::io::prelude::*;

fn write_out(f: &amp;str) -&gt; io::Result&lt;()&gt; {
    let mut out = File::create(f)?;
    write!(out,&quot;answer is {}\n&quot;, 42)?;
    Ok(())
}

fn main() {
  write_out(&quot;test.txt&quot;).expect(&quot;write failed&quot;);
}
</code></pre></pre>
<p>如果你关心性能,你需要知道 Rust 文件默认是无缓冲的. 所以每个小的写入请求都会直接进入操作系统,而且这将会明显变慢. 我提到了这一点,因为这种默认设置与其他编程语言不同,并且可能导致令人震惊的发现: Rust 可能被脚本语言遗留下来的地方! 就像<code>Read</code>和<code>io::BufReader</code>, <code>io::BufWriter</code>是带缓冲的<code>Write</code>.</p>
<a class="header" href="print.html#a文件路径和目录" id="a文件路径和目录"><h2>文件,路径和目录</h2></a>
<p>这是一个用于在机器上打印 Cargo 目录的小程序. 最简单的情况是它是'〜/.cargo'. 这是一个Unix shell扩展,所以我们使用<code>env::home_dir</code>因为它是跨平台的.  (它可能会失败,但没有主目录的计算机, 无论如何都不会托管 Rust 工具. )</p>
<p>这里我们创建一个<a href="https://doc.rust-lang.org/std/ops/trait.Mul.html">PathBuf</a>并使用它的<code>push</code>方法构建完整的文件路径就像 <em>组件</em>.  (这比 用'/','\'或其他任何东西来要容易得多,取决于系统. )</p>
<pre><pre class="playpen"><code class="language-rust">// file7.rs
use std::env;
use std::path::PathBuf;

fn main() {
    let home = env::home_dir().expect(&quot;no home!&quot;);
    let mut path = PathBuf::new();
    path.push(home);
    path.push(&quot;.cargo&quot;);

    if path.is_dir() {
        println!(&quot;{}&quot;, path.display());
    }
}
</code></pre></pre>
<p>一个<code>PathBuf</code>就好像<code>String</code>- 它拥有一组可扩展的角色,但具有专门用于构建路径的方法. 但其大部分功能都来自借用版本<code>Path</code>,这就像<code>&amp;str</code>. 所以,例如,<code>is_dir</code>是一个<code>Path</code>方法.</p>
<p>这可能听起来像一种继承形式,但魔法<a href="https://doc.rust-lang.org/book/deref-coercions.html">Deref</a> trait 的工作方式不同. 它就像<code>String/&amp;str</code> - <code>PathBuf</code>引用可 <em>包裹{Coerce}</em> 成为<code>Path</code>引用.  ('Coerce'是一个很强的词,但这确实是 Rust 为你做转换的少数几个地方之一. )</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo(p: &amp;Path) {...}
...
let path = PathBuf::from(home);
foo(&amp;path);
#}</code></pre></pre>
<p><code>PathBuf</code>与<code>OsString</code>有亲密的关系,它代表我们直接从系统获得的字符串.  (有一个相应的<code>OsString/&amp;OsStr</code>关系. )</p>
<p>这样的字符串不是 <em>保证</em> 可以表示为 utf-8 !现实生活是一个<a href="https://news.ycombinator.com/item?id=10519932">复杂的事情</a>,特别是看到'他们为什么这么辛苦'的答案. 总而言之,首先有几年的 ASCII 传统编码,以及其他语言的多种特殊编码. 其次,人类语言很复杂. 例如'noël'是 <em>五个</em> Unicode代码点!</p>
<p>确实,现代操作系统文件名的大部分时间都是 Unicode (Unix方面的 utf-8 ,Windows方面的UTF-16) ,又或者不是. Rust必须严格处理这种可能性. 例如,<code>Path</code>有一个方法<code>as_os_str</code>它返回一个<code>&amp;OsStr</code>, 但是<code>to_str</code>方法返回一个<code>Option&lt;&amp;str&gt;</code>. 并不总是可能!</p>
<p>人们在这一点上遇到了麻烦,因为他们已经过分依赖'string'和'character'作为唯一必要的抽象. 正如爱因斯坦所说, 编程语言必须尽可能简单,但并不简单. 系统语言 <em>需要</em> 一个<code>String/&amp;str</code>区别 (拥有与借用: 这也非常方便) ,如果它希望在 Unicode 字符串上标准化,那么它需要另一种类型来处理无效 Unicode 的文本 - 因此有了<code>OsString/&amp;OsStr</code>. 请注意,这些类型没有任何有趣的 类似字符串的方法, 因为我们本来就不知道无效 Unicode.</p>
<p>但是,人们习惯于像处理字符串一样处理文件名,这就是 Rust 使用<code>PathBuf</code>方法操作文件路径更容易的原因.</p>
<p>您可以<code>pop</code>连续去除路径组件. 这里我们从程序的当前目录开始:</p>
<pre><pre class="playpen"><code class="language-rust">// file8.rs
use std::env;

fn main() {
    let mut path = env::current_dir().expect(&quot;can't access current dir&quot;);
    loop {
        println!(&quot;{}&quot;, path.display());
        if ! path.pop() {
            break;
        }
    }
}
// /home/steve/rust/gentle-intro/code
// /home/steve/rust/gentle-intro
// /home/steve/rust
// /home/steve
// /home
// /
</code></pre></pre>
<p>这是一个有用的变化. 我有一个搜索 配置{config} 文件 的程序,其规则是它可能出现在当前目录的任何子目录中. 所以我创建<code>/home/steve/rust/config.txt</code>并 启动此程序<code>/home/steve/rust/gentle-intro/code</code>:</p>
<pre><pre class="playpen"><code class="language-rust">// file9.rs
use std::env;

fn main() {
    let mut path = env::current_dir().expect(&quot;can't access current dir&quot;);
    loop {
        path.push(&quot;config.txt&quot;);
        if path.is_file() {
            println!(&quot;gotcha {}&quot;, path.display());
            break;
        } else {
            path.pop();
        }
        if ! path.pop() {
            break;
        }
    }
}
// gotcha /home/steve/rust/config.txt
</code></pre></pre>
<p>如此像 <strong>git</strong> 的工作方式当它想知道当前的回购是什么.</p>
<p>有关文件的详细信息 (其大小,类型等) 被称为它的 <em>元数据</em>. 与往常一样,可能存在错误 - 不仅仅是&quot;找不到&quot;,而且如果我们没有权限读取此文件.</p>
<pre><pre class="playpen"><code class="language-rust">// file10.rs
use std::env;
use std::path::Path;

fn main() {
    let file = env::args().skip(1).next().unwrap_or(&quot;file10.rs&quot;.to_string());
    let path = Path::new(&amp;file);
    match path.metadata() {
        Ok(data) =&gt; {
            println!(&quot;type {:?}&quot;, data.file_type());
            println!(&quot;len {}&quot;, data.len());
            println!(&quot;perm {:?}&quot;, data.permissions());
            println!(&quot;modified {:?}&quot;, data.modified());
        },
        Err(e) =&gt; println!(&quot;error {:?}&quot;, e)
    }
}
// type FileType(FileType { mode: 33204 })
// len 488
// perm Permissions(FilePermissions { mode: 436 })
// modified Ok(SystemTime { tv_sec: 1483866529, tv_nsec: 600495644 })
</code></pre></pre>
<p>文件的长度 (以字节为单位) 和修改时间很容易解释.  (注意我们可能无法获得这个时间!) 文件类型有方法<code>is_dir</code>,<code>is_file</code>和<code>is_symlink</code>.</p>
<p><code>权限{perissions}</code>是一个有趣的. Rust 努力成为跨平台的,所以这是'最低公分母'的例子. 一般来说,你可以查询的只是文件是否只读 - '权限'概念在Unix中被扩展,并为 <code>用户/群组/其他</code> 提供 <code>读/写/可执行</code>的权限.</p>
<p>但是,如果您对 Windows 不感兴趣,那么引入特定于平台的 traits 将至少为我们提供权限模式位.  (像往常一样,一个 trait 只有在它可见时才会触发. ) 然后,应用到程序它自己的能被赋予可执行:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::os::unix::fs::PermissionsExt;
...
println!(&quot;perm {:o}&quot;,data.permissions().mode());
// perm 755
#}</code></pre></pre>
<p>(注意&quot;{:o}&quot;用于打印 <em>八进制</em>)</p>
<p>(Windows 上的文件是否可执行取决于其扩展名. 可执行文件的扩展名可以在PATHEXT`环境变量 - '.exe','. bat'等等) .</p>
<p><code>std::fs</code>包含许多用于处理文件的有用功能,例如复制或移动文件,制作符号链接和创建目录.</p>
<p>要查找目录的内容,<code>std::fs::read_dir</code>提供了一个迭代器. 以下是扩展名为&quot;.rs&quot;且大小大于1024字节 的所有文件:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn dump_dir(dir: &amp;str) -&gt; io::Result&lt;()&gt; {
    for entry in fs::read_dir(dir)? {
        let entry = entry?;
        let data = entry.metadata()?;
        let path = entry.path();
        if data.is_file() {
            if let Some(ex) = path.extension() {
                if ex == &quot;rs&quot; &amp;&amp; data.len() &gt; 1024 {
                    println!(&quot;{} length {}&quot;, path.display(),data.len());
                }
            }
        }
    }
    Ok(())
}
// ./enum4.rs length 2401
// ./struct7.rs length 1151
// ./sexpr.rs length 7483
// ./struct6.rs length 1359
// ./new-sexpr.rs length 7719
#}</code></pre></pre>
<p>明显,<code>read_dir</code>可能会失败 (通常是'找不到'或'没有权限') ,但是获取每个新条目可能会失败 (这就像是<code>line</code>迭代器{Iterator} 遍历 缓冲的阅读器的内容) . 另外,我们可能无法获取与条目对应的元数据. 一个文件可能没有扩展名,所以我们也必须检查.</p>
<p>为什么不只是一个遍历路径的迭代器? 在 Unix 上这是这样的<code>opendir</code>系统调用起作用,但在 Windows 上,您无法在不获取元数据的情况下 迭代目录的内容. 所以这是一个相当优雅的妥协方案,它允许跨平台的代码尽可能高效.</p>
<p>在这一点上你可以原谅感觉'错误疲劳{error fatigue}'. 但请注意 <em>错误总是存在</em> - 这不是 Rust 正在发明新的. 它只是在努力让你无法忽视它们. 任何操作系统调用都可能失败.</p>
<p>Java 和 Python 等语言引发异常;像 Go 和 Lua 这样的语言返回两个值,其中第一个是 Resul t,第二个是 错误: 像 Rust 也一样,它考虑到是库函数引发错误的不良方式. 所以有很多错误检查和函数的早期返回.</p>
<p>Rust使用<code>Result</code>因为它 either-or{没有或者}: 你不能同时得到 Result 和 错误. 问号运算符 使处理错误更加清晰.</p>
<a class="header" href="print.html#a进程" id="a进程"><h2>进程</h2></a>
<p>一个基本的需求是程序运行程序,或者 <em>启动过程</em> . 你的程序可以 <em>启动{launch}</em> 尽可能多的子进程,顾名思义他们与父母有特殊的关系.</p>
<p>运行程序很简单,使用<code>Command</code>struct,它构建传递给程序的参数:</p>
<pre><pre class="playpen"><code class="language-rust">use std::process::Command;

fn main() {
    let status = Command::new(&quot;rustc&quot;)
        .arg(&quot;-V&quot;)
        .status()
        .expect(&quot;no rustc?&quot;);

    println!(&quot;cool {} code {}&quot;, status.success(), status.code().unwrap());
}
// rustc 1.15.0-nightly (8f02c429a 2016-12-15)
// cool true code 0
</code></pre></pre>
<p>所以<code>new</code>收到该程序的名称 (它将查找<code>PATH</code>,如果不是绝对文件名) ,<code>arg</code>增加了一个新的 <em>argument</em> ,并且<code>status</code>导致它运行. 这返回一个<code>Result</code>,这是<code>Ok</code>如果程序实际运行,包含一个<code>退出状态{ExitStatus}</code>. 在这种情况下,程序成功,并返回 退出码0 (使用<code>unwrap</code>是因为如果程序被信号杀死了,我们不总是得到代码) .</p>
<p>如果我们改变了<code>-V</code>至<code>-v</code> (一个容易的错误) <code>rustc</code>失败: `所以有三种可能性:</p>
<pre><code>error: no input filename given

cool false code 101
</code></pre>
<p>程序不存在,很糟糕,或者我们不允许运行它</p>
<ul>
<li>程序运行,但没有成功 - 非零退出代码</li>
<li>程序运行,零退出代码.</li>
<li>成功!默认情况下,程序的标准输出和标准错误流将发送到终端.</li>
</ul>
<p>我们经常对捕获这种输出非常感兴趣,所以就是<code>output</code>方法.</p>
<pre><pre class="playpen"><code class="language-rust">// process2.rs
use std::process::Command;

fn main() {
    let output = Command::new(&quot;rustc&quot;)
        .arg(&quot;-V&quot;)
        .output()
        .expect(&quot;no rustc?&quot;);

    if output.status.success() {
        println!(&quot;ok!&quot;);
    }
    println!(&quot;len stdout {} stderr {}&quot;, output.stdout.len(), output.stderr.len());
}
//Ok!
// len stdout 44 stderr 0
</code></pre></pre>
<p>与<code>status</code>一样我们的程序会阻塞,直到子进程结束,我们返回三件事情 - 状态 (如以前) ,标准输出的内容和标准错误的内容.</p>
<p>捕获的输出简单<code>Vec&lt;u8&gt;</code>- 只是字节. 回想一下,我们不能保证我们从操作系统收到的数据是正确编码的 utf-8 字符串. 事实上,我们不能保证它 <em>甚至</em> 是一个字符串 - 程序可能会返回任意二进制数据.</p>
<p>如果我们确信输出是 utf-8 ,那么<code>String::from_utf8</code>将转换这些 Vec 或字节 - 它返回一个<code>Result</code>因为这种转换可能不会成功. 一个更马虎的功能是<code>String::from_utf8_lossy</code>这将很好地进行转换, 并在失败时插入无效的 Unicode 标记.</p>
<p>下面是一个使用 shell 运行程序的有用函数. 这使用通常的 shell机制 将标准错误连接到标准输出. 在 Windows上 shell 的名字是不同的,但是除此之外的东西可以按预期工作.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn shell(cmd: &amp;str) -&gt; (String,bool) {
    let cmd = format!(&quot;{} 2&gt;&amp;1&quot;,cmd);
    let shell = if cfg!(windows) {&quot;cmd.exe&quot;} else {&quot;/bin/sh&quot;};
    let flag = if cfg!(windows) {&quot;/c&quot;} else {&quot;-c&quot;};
    let output = Command::new(shell)
        .arg(flag)
        .arg(&amp;cmd)
        .output()
        .expect(&quot;no shell?&quot;);
    (
        String::from_utf8_lossy(&amp;output.stdout).trim_right().to_string(),
        output.status.success()
    )
}


fn shell_success(cmd: &amp;str) -&gt; Option&lt;String&gt; {
    let(output,success) = shell(cmd);
    if success {Some(output)} else {None}
}
#}</code></pre></pre>
<p>我修整了右边的任何空格, 所以如果你说的话,<code>shell(&quot;which rustc&quot;)</code>,您将获得没有任何额外换行的路径.</p>
<p>您可以控制由启动程序的执行通过<code>Process</code>, 指定它将运行的目录使用<code>current_dir</code>方法和它所使用的环境变量<code>env</code>.</p>
<p>到目前为止,我们的程序只是等待子进程完成. 如果你使用<code>spawn</code>方法,我们立即返回,并且必须明确地等待它完成 - 或者在此期间去做其他事情! 这个例子还显示了如何同时抑制 标准错误和标准错误:</p>
<pre><pre class="playpen"><code class="language-rust">// process5.rs
use std::process::{Command,Stdio};

fn main() {
    let mut child = Command::new(&quot;rustc&quot;)
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .spawn()
        .expect(&quot;no rustc?&quot;);

    let res = child.wait();
    println!(&quot;res {:?}&quot;, res);
}
</code></pre></pre>
<p>默认情况下,子项&quot;继承{inherits}&quot;父项的标准输入和输出. 在这里,我们将 孩子的输出控制 重定向到&quot;nowhere&quot;. 这相当于在 Unix shell 中说<code>&gt;/dev/null 2&gt;/dev/null</code>.</p>
<p>现在, 在 Rust可以使用 shell  (<code>sh</code>要么<code>cmd</code>) 来完成这些事情 . 但通过这种方式,您可以完全程序化地控制进程创建.</p>
<p>例如,如果我们有<code>.stdout(Stdio::piped())</code>那么孩子的标准输出被重定向到管道. 然后<code>child.stdout</code>是你可以用来直接读取输出的东西 (例如: implements <code>Read</code>) . 同样,你可以使用<code>.stdin(Stdio::piped())</code>方法,以便您可以写入<code>child.stdin</code>.</p>
<p>但如果我们使用了<code>wait_with_output</code>代替<code>wait</code>, 那么它返回一个<code>Result&lt;Output&gt;</code>并将孩子的输出记录到<code>Output</code>的<code>sudout</code>字段作为一个<code>Vec&lt;u8&gt;</code>就像以前一样.</p>
<p>该<code>Child</code>结构也给你一个明确的<code>kill</code>方法.</p>
<a class="header" href="print.html#a模块和cargo" id="a模块和cargo"><h1>模块和Cargo</h1></a>
<a class="header" href="print.html#a模块" id="a模块"><h2>模块</h2></a>
<p>随着程序变得越来越大,有必要将它们分散到多个文件中,并将函数和类型放在不同的 <em>命名空间</em>. 这两种解决方案都是Rust解决方案 <em>模块</em>.</p>
<p>C 做的是第一个,而不是第二个,所以你最终会遇到类似的可怕名字<code>primitive_display_set_width</code>等等. 实际的文件名可以任意命名.</p>
<p>Rust 在全名看起来像<code>primitive::display::set_width</code>,之后说<code>use primitive::display</code>你可以把它称为<code>display::set_width</code>. 你甚至可以说<code>use primitive::display::set_width</code>然后只能用<code>set_width</code>, 但这并不是一个好主意. <code>rustc</code>不会混淆,但是 <em>您</em> 稍后可能会感到困惑. 但为了这个工作,文件名必须遵循一些简单的规则.</p>
<p>一个新的关键字<code>mod</code>用于将模块定义为可以写入 Rust 类型或函数的块:</p>
<pre><pre class="playpen"><code class="language-rust">mod foo {
    #[derive(Debug)]
    struct Foo {
        s: &amp;'static str
    }
}

fn main(){
    let f = foo::Foo{s: &quot;hello&quot;};
    println!(&quot;{:?}&quot;, f);
}
</code></pre></pre>
<p>但它仍然不太正确 - 我们得到'struct Foo is 私人{private}'. 为了解决这个问题,我们需要<code>pub</code>要导出的关键字<code>Foo</code>. 然后错误更改为'结构foo::Foo 字段是私人的',所以放了<code>pub</code>后, 出口<code>Foo::s</code>. 然后事情就会奏效.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    pub struct Foo {
        pub s: &amp;'static str
    }
#}</code></pre></pre>
<p>需要一个明确的<code>pub</code>意味着你必须 <em>选择</em> 哪些项目要通过模块公开. 从模块导出的一组函数和类型称为它的 <em>接口{interface}</em>.</p>
<p>隐藏结构的内部通常会更好,并且只允许通过方法访问:</p>
<pre><pre class="playpen"><code class="language-rust">mod foo {
    #[derive(Debug)]
    pub struct Foo {
        s: &amp;'static str
    }

    impl Foo {
        pub fn new(s: &amp;'static str)-&gt; Foo {
            Foo{s: s}
        }
    }
}

fn main(){
    let f = foo::Foo::new(&quot;hello&quot;);
    println!(&quot;{:?}&quot;, f);
}
</code></pre></pre>
<p>为什么「没有pub」隐藏 impl{实现} 是一件好事? 因为这意味着您可以在不中断接口的情况下稍后进行更改,否则模块的使用者不会太依赖其细节. 大规模编程的大敌是代码纠结的倾向,因此理解一段代码实际确切做了什么是不可能的.</p>
<p>在一个完美的世界里,一个模块做一件事,做得好,并保持自己的秘密.</p>
<p>何时不要隐藏? 正如 Stroustrup 所说,当接口 <em>是</em> 实现,就像<code>struct Point {x: f32,y: f32}</code>.</p>
<p>一个模块 <em>中</em> ,所有项目对所有其他项目都可见. 这是一个舒适的地方,每个人都可以成为朋友,知道彼此的私密细节.</p>
<p>每个人都可以根据自己的喜好,将程序分成不同的文件. 我开始对 500条线路 感到不舒服,但我们都同意 超过2000条线路 正在推动它.</p>
<p>那么如何将这个程序分解成单独的文件呢?</p>
<p>我们把这个<code>foo</code>代码到<code>foo.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// foo.rs
#[derive(Debug)]
pub struct Foo {
    s: &amp;'static str
}

impl Foo {
    pub fn new(s: &amp;'static str)-&gt; Foo {
        Foo{s: s}
    }
}
#}</code></pre></pre>
<p>并使用一个<code>mod foo</code>声明, 并 <em>没有</em> 在一个<code>区块{}</code> 主<code>main</code>程序中:</p>
<pre><pre class="playpen"><code class="language-rust">// mod3.rs
mod foo;

fn main(){
    let f = foo::Foo::new(&quot;hello&quot;);
    println!(&quot;{:?}&quot;, f);
}
</code></pre></pre>
<p>现在<code>rustc mod3.rs</code>也会引发<code>foo.rs</code>编译. 没有必要用 makefiles 来搞笑!</p>
<p>编译器也会看<code>MODNAME/mod.rs</code>,所以这将工作,如果我创建一个目录<code>boo</code>包含一个文件<code>mod.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// boo/mod.rs
pub fn answer()-&gt;u32 {
    42
}
#}</code></pre></pre>
<p>现在主程序可以将两个模块作为单独的文件使用:</p>
<pre><code>// mod3.rs
mod foo;
mod boo;

fn main(){
    let f = foo::Foo::new(&quot;hello&quot;);
    let res = boo::answer();
    println!(&quot;{:?} {}&quot;, f,res);
}
</code></pre>
<p>到目前为止,还有<code>mod3.rs</code>,含有<code>main</code>,一个模块<code>foo.rs</code>和一个含<code>mod.rs</code>的目录<code>boo</code>. 通常的惯例是包含的文件<code>main</code>只是叫<code>main.rs</code>.</p>
<p>为什么有两种方法可以做同样的事情? 因为<code>boo/mod.rs</code>可以在<code>boo</code>引用其中定义的其他模块,更新<code>boo/mod.rs</code>并添加一个新模块 - 注意这是明确导出的. (没有<code>pub</code>,<code>bar</code>只能在里面看到<code>boo</code>模块).</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// boo/mod.rs
pub fn answer()-&gt;u32 {
    42
}

pub mod bar {
    pub fn question()-&gt; &amp;'static str {
        &quot;the meaning of everything&quot;
    }
}
#}</code></pre></pre>
<p>然后我们有与答案相对应的问题(<code>pub</code>模块在里面<code>boo</code>):</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let q = boo::bar::question();
#}</code></pre></pre>
<p>该模块块可以被拉出<code>boo/bar.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// boo/bar.rs
pub fn question()-&gt; &amp;'static str {
    &quot;the meaning of everything&quot;
}
#}</code></pre></pre>
<p>和<code>boo/mod.rs</code>变为:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// boo/mod.rs
pub fn answer()-&gt;u32 {
    42
}

pub mod bar;
#}</code></pre></pre>
<p>总之,模块是关于组织和可见性的,这可能涉及或不涉及单独的文件.</p>
<p>请注意<code>use</code>与导入无关,只是指定模块名称的可见性. 例如:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    use boo::bar;
    let q = bar::question();
    ...
}
{
    use boo::bar::question();
    let q = question();
    ...
}
#}</code></pre></pre>
<p>重要的一点是这里没有 <em>单独编译</em> . 主程序及其模块文件将每次重新编译. 尽管如此,较大的程序需要花费相当长的时间, 当然<code>rustc</code>在渐进式编译中越来越好.</p>
<a class="header" href="print.html#crates" id="crates"><h2>Crates</h2></a>
<p>Rust 的&quot;编译单位&quot;是 <em>箱{crate}</em> ,它是一个可执行文件或一个库.</p>
<p>要分别编译上一节中的文件,请先构建<code>foo.rs</code>作为 rust <em>静态库</em> 箱:</p>
<pre><code>src$ rustc foo.rs --crate-type=lib
src$ ls -l libfoo.rlib
-rw-rw-r-- 1 steve steve 7888 Jan  5 13:35 libfoo.rlib
</code></pre>
<p>我们现在可以 <em>链接</em> 这到我们的主要程序中:</p>
<pre><code>src$ rustc mod4.rs --extern foo=libfoo.rlib
</code></pre>
<p>但主要程序现在必须像这样,在那里<code>extern</code>名称与链接时使用的名称相同. 有一个隐含的顶级模块<code>foo</code>与 库 crate 相关联:</p>
<pre><code>// mod4.rs
extern crate foo;

fn main(){
    let f = foo::Foo::new(&quot;hello&quot;);
    println!(&quot;{:?}&quot;, f);
}
</code></pre>
<p>人们已经开始吟唱'Cargo!Cargo!' 让我来证明这个构建 Rust 的快速. 我是'Know Thy Toolchain'的忠实信徒, 当我们看着使用 Cargo 管理项目时,这会减少你需要学习的新魔法数量. 模块是基本的语言功能,可用于 Cargo 项目之外.</p>
<p>现在该理解为什么 Rust 的二进制文件如此之大:</p>
<pre><code>src$ ls -lh mod4
-rwxrwxr-x 1 steve steve 3,4M Jan  5 13:39 mod4
</code></pre>
<p>这很胖! <em>许多</em> 在该可执行文件中的调试信息.</p>
<p>这不是一件坏事,如果你想使用一个调试器,并且当你的程序发生混乱时实际上需要有意义的回溯. 那么让我们去除这些调试信息并查看:</p>
<pre><code>src$ strip mod4
src$ ls -lh mod4
-rwxrwxr-x 1 steve steve 300K Jan  5 13:49 mod4
</code></pre>
<p>对于如此简单的事情,仍感觉有点大,但是这个程序 <em>静态</em> 链接到 Rust 标准库. 这是一件好事,因为您可以将此可执行文件交给任何具有正确操作系统的人 - 他们不需要&quot;Rust 运行时&quot;.(和<code>rustup</code>甚至可以让你为 其他操作系统和平台 进行交叉编译. )</p>
<p>我们可以 <code>动态-dynamic</code> 链接到 Rust运行时 并获得真正的小:</p>
<pre><code>src$ rustc -C prefer-dynamic mod4.rs --extern foo=libfoo.rlib
src$ ls -lh mod4
-rwxrwxr-x 1 steve steve 14K Jan  5 13:53 mod4
src$ ldd mod4
    linux-vdso.so.1 =&gt; (0x00007fffa8746000)
    libstd-b4054fae3db32020.so =&gt; not found
    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6(0x00007f3cd47aa000)
    /lib64/ld-linux-x86-64.so.2(0x00007f3cd4d72000)
</code></pre>
<p>这'找不到 no found'是因为<code>rustup</code>不会全局安装动态库. 至少在 Unix 上 我们可以用我们的快乐方式破解(是的,我知道最好的解决方案是符号链接).</p>
<pre><code>src$ export LD_LIBRARY_PATH=~/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib
src$ ./mod4
Foo { s: &quot;hello&quot; }
</code></pre>
<p>Rust 没有 <em>哲学上</em> 动态链接的问题,与 Go 一样. 只是当每6周有一个稳定版本时,不得不重新编译所有内容. 如果你有一个适合你的稳定版本,那么很酷. 随 着Rust的稳定版本 越来越多地被 OS包管理器控制, 动态链接将变得更加流行.</p>
<a class="header" href="print.html#cargo" id="cargo"><h2>Cargo</h2></a>
<p>与 Java 或 Python 相比,Rust标准库不是很大,</p>
<p>虽然功能 比 C 或 C ++ 更强大,但主要依赖于操作系统提供的库.</p>
<p>但用 <strong>Cargo</strong>访问<a href="https://crates.io">crates.io</a>社区提供的库很简单. Cargo将查找正确的版本并为您下载源代码,并确保下载其他所需的 crate{库/箱} .</p>
<p>我们来创建一个需要 阅读JSON 的简单程序. 这种数据格式的使用非常广泛,但是对于包含在标准库中的数据格式太专业了. 所以我们初始化一个Cargo项目,使用'--bin',因为默认是创建一个库项目.</p>
<pre><code>test$ cargo init --bin test-json
     Created binary(application)project
test$ cd test-json
test$ cat Cargo.toml
[package]
name = &quot;test-json&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.org&gt;&quot;]

[dependencies]
</code></pre>
<p>使项目依赖于<a href="http://json.rs/doc/json/">JSON crate</a>,编辑'Cargo.toml'文件,如下所示:</p>
<pre><code>[dependencies]
json=&quot;0.11.4&quot;
</code></pre>
<p>然后用 Cargo 进行第一次构建:</p>
<pre><code>test-json$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading json v0.11.4
   Compiling json v0.11.4
   Compiling test-json v0.1.0(file:///home/steve/c/rust/test/test-json)
    Finished debug [unoptimized + debuginfo] target(s)in 1.75 secs
</code></pre>
<p>这个项目的主文件已经被 <em>创建</em> , 它是'src'目录中的'main.rs'. 它开始时只是一个'你好世界'的应用程序,所以让它变成一个适当的测试程序.</p>
<p>请注意非常方便的'原始{raw}'字符串文字 - 否则我们需要转义那些双引号
并以丑陋结束：</p>
<pre><pre class="playpen"><code class="language-rust">// test-json/src/main.rs
extern crate json;

fn main(){
    let doc = json::parse(r#&quot;
    {
        &quot;code&quot;: 200,
        &quot;success&quot;: true,
        &quot;payload&quot;: {
            &quot;features&quot;: [
                &quot;awesome&quot;,
                &quot;easyAPI&quot;,
                &quot;lowLearningCurve&quot;
            ]
        }
    }
    &quot;#).expect(&quot;parse failed&quot;);

    println!(&quot;debug {:?}&quot;, doc);
    println!(&quot;display {}&quot;, doc);
}
</code></pre></pre>
<p>您现在只能编译和运行此项目<code>main.rs</code>已经改变.</p>
<pre><code>test-json$ cargo run
   Compiling test-json v0.1.0(file:///home/steve/c/rust/test/test-json)
    Finished debug [unoptimized + debuginfo] target(s)in 0.21 secs
     Running `target/debug/test-json`
debug Object(Object { store: [(&quot;code&quot;, Number(Number { category: 1, exponent: 0, mantissa: 200 }),
 0, 1),(&quot;success&quot;, Boolean(true), 0, 2),(&quot;payload&quot;, Object(Object { store: [(&quot;features&quot;,
 Array([Short(&quot;awesome&quot;), Short(&quot;easyAPI&quot;), Short(&quot;lowLearningCurve&quot;)]), 0, 0)] }), 0, 0)] })
display {&quot;code&quot;:200,&quot;success&quot;:true,&quot;payload&quot;:{&quot;features&quot;:[&quot;awesome&quot;,&quot;easyAPI&quot;,&quot;lowLearningCurve&quot;]}}
</code></pre>
<p>调试输出 display 了JSON文档的一些内部细节,但一个普通的&quot;{}&quot;,使用了<code>Display</code> trait,从解析的文档重新生成JSON.</p>
<p>我们来探索一下 JSON API. 如果我们无法提取数值,这将毫无用处. 该<code>as_TYPE</code>方法返回<code>Option&lt;TYPE&gt;</code>, 因为我们无法确定该字段是否存在或是否属于正确类型. (见<a href="http://json.rs/doc/json/enum.JsonValue.html">文档JsonValue</a>)</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let code = doc[&quot;code&quot;].as_u32().unwrap_or(0);
    let success = doc[&quot;success&quot;].as_bool().unwrap_or(false);

    assert_eq!(code, 200);
    assert_eq!(success, true);

    let features = &amp;doc[&quot;payload&quot;][&quot;features&quot;];
    for v in features.members(){
        println!(&quot;{}&quot;, v.as_str().unwrap()); // MIGHT explode
    }
    // awesome
    // easyAPI
    // lowLearningCurve
#}</code></pre></pre>
<p><code>features</code>这里是一个<code>JsonValue</code>引用- 它必须是一个引用,否则我们会试图移动一个 <em>值</em> 会脱离 <code>doc : JSON</code>. 这里我们知道它是一个数组,所以<code>members()</code>将返回一个非空的迭代器<code>&amp;JsonValue</code>.</p>
<p>如果&quot;payload&quot;对象没有&quot;features&quot;键,该怎么办? 那么<code>features</code>将被设置为<code>空值{Null}</code>. 不会有爆炸. 这种便利表达了 JSON 的自由形式,任何东西的本质. 如果结构不匹配,您应该检查收到的任何文档的结构, 并创建自己的错误.</p>
<p>您可以修改这些结构. 如果我们有<code>let mut doc</code>那么这会做你所期望的:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let features = &amp;mut doc[&quot;payload&quot;][&quot;features&quot;];
    features.push(&quot;cargo!&quot;).expect(&quot;couldn't push&quot;);
#}</code></pre></pre>
<p>如果<code>feature</code>不是一个数组,因此它返回<code>Result&lt;()&gt;</code>, 所以该<code>push</code>将失败.</p>
<p>这是一个非常漂亮的使用宏来生成 <em>JSON literals</em>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let data = object!{
        &quot;name&quot;    =&gt; &quot;John Doe&quot;,
        &quot;age&quot;     =&gt; 30,
        &quot;numbers&quot; =&gt; array![10,53,553]
    };
    assert_eq!(
        data.dump(),
        r#&quot;{&quot;name&quot;:&quot;John Doe&quot;,&quot;age&quot;:30,&quot;numbers&quot;:[10,53,553]}&quot;#
    );
#}</code></pre></pre>
<p>为了这个工作,你需要显式地从 JSON箱导入宏 :</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[macro_use]
extern crate json;
#}</code></pre></pre>
<p>由于 JSON的无定形,动态类型性质 和 Rust的结构化,静态性质之间的不匹配,使用这个 crate 有一个缺点. (自述明确提到'摩擦{friction}')所以如果你 <em>没有</em> 想要将 JSON 映射到 Rust 数据结构,您最终会做很多检查,因为您不能认为接收到的结构与您的结构相匹配! 为此,更好的解决方案是<a href="https://github.com/serde-rs/json">serde_json</a>, 它可以 <em>序列</em> Rust数据结构转换为JSON和 <em>反序列化</em> JSON进入Rust.</p>
<p>为此,请创建另一个 Cargo 二进制项目<code>Cargo new --bin test-serde-json</code>,进入<code>test-serde-json</code>目录和编辑<code>Cargo.toml</code>. 像这样编辑它:</p>
<pre><code>[dependencies]
serde=&quot;0.9&quot;
serde_derive=&quot;0.9&quot;
serde_json=&quot;0.9&quot;
</code></pre>
<p>并编辑<code>src/main.rs</code>是这样的:</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate serde_derive;
extern crate serde_json;

#[derive(Serialize, Deserialize, Debug)]
struct Person {
    name: String,
    age: u8,
    address: Address,
    phones: Vec&lt;String&gt;,
}

#[derive(Serialize, Deserialize, Debug)]
struct Address {
    street: String,
    city: String,
}

fn main(){
    let data = r#&quot; {
     &quot;name&quot;: &quot;John Doe&quot;, &quot;age&quot;: 43,
     &quot;address&quot;: {&quot;street&quot;: &quot;main&quot;, &quot;city&quot;:&quot;Downtown&quot;},
     &quot;phones&quot;:[&quot;27726550023&quot;]
    } &quot;#;
    let p: Person = serde_json::from_str(data).expect(&quot;deserialize error&quot;);
    println!(&quot;Please call {} at the number {}&quot;, p.name, p.phones[0]);

    println!(&quot;{:#?}&quot;,p);
}
</code></pre></pre>
<p>你已经看到了<code>derive</code>属性之前,但是<code>serde_derive</code> crate 定义 <em>自定义派生{custom derives}</em> 为特别的<code>序列化</code>和<code>反序列化</code> trait . 结果生成的 Rust 结构体:</p>
<pre><code>Please call John Doe at the number 27726550023
Person {
    name: &quot;John Doe&quot;,
    age: 43,
    address: Address {
        street: &quot;main&quot;,
        city: &quot;Downtown&quot;
    },
    phones: [
        &quot;27726550023&quot;
    ]
}
</code></pre>
<p>现在,如果你使用了<code>json</code>那么你需要几百行自定义转换代码,主要是错误处理. 单调乏味,容易搞砸,这些都不是你想要付出努力的地方.</p>
<p>如果你从外部来源处理结构良好的JSON (如果需要,可以重新映射字段名称),这显然是最好的解决方案,并为 Rust 程序通过网络与其他程序共享数据提供了一个强大的方法(因为一切都能理解 JSON 这些天). 关于很酷的事情<code>serde</code>(用于SERialization:序列化 DEserialization: 反序列化)是也支持其他文件格式,例如<code>toml</code>,这是 cargo 中常用的配置友好格式. 因此,您的程序可以将.toml文件读入结构中,并将这些结构编写为.json.</p>
<p>序列化是一项重要的技术,Java 和 Go 存在类似的解决方案 , 但有很大的不同. 在这些语言中,数据的结构可以在 <em>运行时</em> 运用 <em>反射</em> 这里找到,但在这种情况下,序列化代码是在 <em>编译时</em>- 更高效!</p>
<p>Cargo 被认为是 Rust 生态系统的一大优势,因为它为我们做了很多工作. 否则,我们不得不从 Github 下载这些库,构建为 静态库-crate ,并将它们与程序链接. 这对于 C ++ 项目来说是很痛苦的,如果 Cargo 不存在的话,对于Rust项目来说,这几乎是痛苦的. C ++ 在它的痛苦中有点独特,所以我们应该将它与其他语言的包管理器进行比较. npm(用于JavaScript) 和 pip(用于Python) 为您管理依赖关系和下载, 但分发故事更难,因为程序的用户需要安装 NodeJS 或 Python. 但 Rust 程序与它们的 依赖关系 是静态链接的,所以它们可以在没有外部依赖的情况下再次发给你的好友.</p>
<a class="header" href="print.html#a更多宝石" id="a更多宝石"><h2>更多宝石</h2></a>
<p>处理除简单文本以外的任何内容时,正则表达式使您的生活变得更加轻松. 这些通常适用于大多数语言,我将在这里假定对正则表示法有基本的了解. 使用<a href="https://github.com/rust-lang/regex">正则表达式</a>, 把&quot;regex =&quot;0.2.1&quot;'放在&quot;[dependencies]&quot;在您的 Cargo.toml.</p>
<p>我们将再次使用&quot;raw strings&quot;,以便反斜杠不必转义. 在中文,这个正则表达式意思是 &quot;完全匹配两个数字,接字符':',然后是任意数字. 捕获两组数字:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate regex;
use regex::Regex;

let re = Regex::new(r&quot;(\d{2}):(\d+)&quot;).unwrap();
println!(&quot;{:?}&quot;, re.captures(&quot;  10:230&quot;));
println!(&quot;{:?}&quot;, re.captures(&quot;[22:2]&quot;));
println!(&quot;{:?}&quot;, re.captures(&quot;10:x23&quot;));
// Some(Captures({0: Some(&quot;10:230&quot;), 1: Some(&quot;10&quot;), 2: Some(&quot;230&quot;)}))
// Some(Captures({0: Some(&quot;22:2&quot;), 1: Some(&quot;22&quot;), 2: Some(&quot;2&quot;)}))
// None
#}</code></pre></pre>
<p>成功的产出实际上有三个 <em>捕获</em>- 整场 match ,和两组数字.  默认情况下这些正则表达式不是 <em>确定的</em> , 所以 <em>正则表达式</em> 将追捕第一场 match ,跳过任何不匹配的东西. (如果你遗漏了'()',它只会给我们整场 match . )</p>
<p>可以 <em>命名</em> 那些捕捉,并且将正则表达式分散在多行,甚至包括注释! 编译正则表达式可能会失败(第一个 <em>期望</em>)或者匹配可能失败(第二个 <em>期望</em>). 在这里,我们可以使用结果作为关联数组, 并查找按名称捕获.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let re = Regex::new(r&quot;(?x)
(?P&lt;year&gt;\d{4}) # the year
-
(?P&lt;month&gt;\d{2})# the month
-
(?P&lt;day&gt;\d{2})  # the day
&quot;).expect(&quot;bad regex&quot;);
let caps = re.captures(&quot;2010-03-14&quot;).expect(&quot;match failed&quot;);

assert_eq!(&quot;2010&quot;, &amp;caps[&quot;year&quot;]);
assert_eq!(&quot;03&quot;, &amp;caps[&quot;month&quot;]);
assert_eq!(&quot;14&quot;, &amp;caps[&quot;day&quot;]);
#}</code></pre></pre>
<p>正则表达式可以分解符合模式的字符串,但不会检查它们是否有意义. 也就是说,你可以指定和匹配 <em>句法{syntax}</em> 的 ISO 风格的日期,但 <em>语义</em> 他们可能是无稽之谈,比如&quot;2014-24-52&quot;.</p>
<p>为此,您需要专门的日期时间处理,由其提供<a href="https://github.com/lifthrasiir/rust-chrono">计时chrono</a>. 你需要在做日期时决定一个时区:</p>
<pre><pre class="playpen"><code class="language-rust">extern crate chrono;
use chrono::*;

fn main(){
    let date = Local.ymd(2010,3,14);
    println!(&quot;date was {}&quot;, date);
}
// date was 2010-03-14+02:00
</code></pre></pre>
<p>但是,这不推荐,因为喂它不好的日期会导致 恐慌!(尝试一个假日期来看看这个. )你需要的方法是 <code>ymd_opt</code>返回<code>LocalResult&lt;Date&gt;</code></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let date = Local.ymd_opt(2010,3,14);
    println!(&quot;date was {:?}&quot;, date);
    // date was Single(2010-03-14+02:00)

    let date = Local.ymd_opt(2014,24,52);
    println!(&quot;date was {:?}&quot;, date);
    // date was None
#}</code></pre></pre>
<p>您还可以直接解析日期时间,无论是以 标准UTC格式 还是 使用自定义<a href="https://lifthrasiir.github.io/rust-chrono/chrono/format/strftime/index.html#specifiers">格式{formats}</a> 这些自我相同的格式允许您, 按照您想要的格式打印日期. 我特别强调了这两个有用的 crate ,因为它们将成为大多数其他语言的标准库的一部分.</p>
<p>事实上,这些 crate 的胚胎形态曾经是 Rust stdlib 的一部分,但被切开了. 这是一个蓄意的决定: Rust团队非常重视 stdlib 的稳定性,所以一旦他们在不稳定的夜间版本 中进行孵化, 那么在只有 beta 和 stable 才能保持稳定. 对于需要实验和改进的 库 来说,他们保持独立并且能够跟踪 Cargo 会更好. 出于所有实际目的,这两个 crate 是 <em>标准</em> 它们不会消失,并且可能会在某个时候折回到 stdlib 中.</p>
<a class="header" href="print.html#a标准库容器" id="a标准库容器"><h1>标准库容器</h1></a>
<a class="header" href="print.html#a阅读文档" id="a阅读文档"><h2>阅读文档</h2></a>
<p>在本节中,我将简要介绍 Rust 标准库的一些常见部分. 文档非常好,但有一点讲解和一些例子总是有用的.</p>
<p>最初,阅读 Rust 文档可能很具挑战性,所以我会经历<code>Vec</code>举个例子. 一个有用的提示是勾选'[-]'框来折叠文档.(如果使用下载标准库源代码<code>rustup component add rust-src</code> 一个 '[src]'链接将出现在此旁边.)这可以让您全面了解所有可用的方法.</p>
<p>首先要注意的是 <em>并非所有可能的方法</em> 被定义<code>Vec</code>本身. 它们是(大部分) 可改变 vec 的方法,例如<code>push</code>. 有些方法仅适用于类型匹配某些约束的 Vec.例如,你只能打电话<code>dedup</code>(删除重复项) ,如果这个类型确实是可以相互比较的东西. 有多个<code>impl</code>定义的块<code>Vec</code>针对不同类型的约束.</p>
<p>然后是非常特殊的关系<code>Vec&lt;T&gt;</code>和<code>&amp;[T]</code>. 任何在 切片 上工作的方法也可以直接在 vec 上工作,而不必明确地使用<code>as_slice</code>方法. 这种关系表达为<code>Deref&lt;Target=[T]&gt;</code>. 当你通过引用预计会发生 切片 的东西来传递一个 Vec 时,这也会起作用 - 这是类型之间自动转换的少数几个地方之一. 所以像 切片 方法<code>first</code>,它可能 - 返回对第一个元素的引用,或者<code>last</code>,也为 Vec 工作. 许多方法与相应的字符串方法类似,所以就是这样<code>split_at</code>为了在索引处获得一对 切片 ,<code>starts_with</code>检查 vec 是否以值序列开始,并且<code>contains</code>检查 vec 是否包含特定值.</p>
<p>没有<code>search</code>方法来查找特定值的索引,但这里有一条经验法则: 如果在容器上找不到方法,请在 迭代器 上查找一个方法:</p>
<pre><code class="language-Rust">    let v = vec![10,20,30,40,50];
    assert_eq!(v.iter().position(|&amp;i| i == 30).unwrap(), 2);
</code></pre>
<p>(该<code>&amp;</code>是因为这是一个 迭代器  _引用 _- 或者你可以说<code>*i== 30</code>为了比较).</p>
<p>同样,没有<code>map</code>对 vec 的方法,因为<code>iter().map(...).collect()</code>也会做这项工作.  Rust 不喜欢不必要地分配 - 通常你不需要这样的结果<code>map</code>作为实际分配的 Vec.</p>
<p>所以我建议你熟悉所有的 迭代器 方法,因为它们对编写好的 Rust 代码至关重要,而不必一直写出循环. 与往常一样,编写小程序来探索 迭代器 方法,而不是在更复杂的程序中与它们搏斗.</p>
<p>该<code>Vec&lt;T&gt;</code>和<code>&amp;[T]</code>方法之后是共同的 trait :  Vec 知道如何进行自己的调试显示(但只有在元素实现时才是如此) <code>Debug</code>).同样,如果它们的元素是可克隆的,它们是可克隆的. 他们执行<code>Drop</code>当 vec 最终死亡时发生这种情况;内存被释放,并且所有元素也被丢弃.</p>
<p>该<code>Extend</code> trait 意味着来自 迭代器 的值可以被添加到一个没有循环的 Vec 中:</p>
<pre><code class="language-Rust">v.extend([60,70,80].iter());
let mut strings = vec![&quot;hello&quot;.to_string(), &quot;dolly&quot;.to_string()];
strings.extend([&quot;you&quot;,&quot;are&quot;,&quot;fine&quot;].iter().map(|s| s.to_string()));
</code></pre>
<p>还有<code>FromIterator</code>,它可以让 vec <em>初始化{constructed}</em> 来自 迭代器 .(迭代器  <code>collect</code>方法倾向于此).</p>
<p>任何容器都需要可迭代. 回想一下有<a href="2-structs-enums-lifetimes.html#the-three-kinds-of-iterators">三种 迭代器 </a></p>
<pre><code class="language-Rust">for x in v {...} // returns T, consumes v
for x in &amp;v {...} // returns &amp;T
for x in &amp;mut v {...} // returns &amp;mut T
</code></pre>
<p>该<code>for</code>声明依赖于<code>IntoIterator</code>特质,实际上有三种实现.</p>
<p>然后是索引,由<code>Index</code>控制(从 vec 中读取) 和<code>IndexMut</code>(修改一个 Vec). 有很多可能性,因为还有分片索引,就像<code>v[0..2]</code>,返回这些返回片,以及平原<code>v[0]</code>它返回对第一个元素的引用.</p>
<p>这里有一些实现<code>From</code> trait.例如<code>Vec::from(&quot;hello&quot;.to_string())</code>会给你一个字符串底层字节的 Vec <code>Vec&lt;u8&gt;</code>. 现在,已经有一种方法<code>into_bytes</code>在<code>String</code>上,为什么冗余?有多种方式来做同样的事情似乎令人困惑. 但是这是必要的,因为显式 trait 使泛型方法成为可能.</p>
<p>有时候 Rust 类型系统的局限性会让事情变得笨拙. 这里的一个例子是如何<code>PartialEq</code>是 <em>分别</em> 定义为最大尺寸为32的阵列!(这会变得更好.)这可以方便地将 Vec 与数组进行比较,但要注意大小限制.</p>
<p>还有[隐藏的宝石](http://xion.io/post/code/ Rust -iter-patterns.html)深埋在文档中. 正如 Karol Kuczmarski 所说: &quot;因为说实话: 没有人滚动那么远&quot;. 如何处理 迭代器 中的错误? 假设你映射了一些可能失败并返回的操作<code>Result</code>,然后想要收集结果:</p>
<pre><code class="language-Rust">fn main() {
    let nums =[&quot;5&quot;,&quot;52&quot;,&quot;65&quot;];
    let iter = nums.iter().map(|s| s.parse::&lt;i32&gt;());
    let converted: Vec&lt;_&gt; = iter.collect();
    println!(&quot;{:?}&quot;,converted);
}
//[Ok(5), Ok(52), Ok(65)]
</code></pre>
<p>很公平,但现在你必须小心地解开这些错误! 但是,如果你要求 vec 的话, Rust 已经知道如何做正确的事情 <em>包括</em> 在一个<code>Result</code>- 也就是说,无论是 vec 还是错误:</p>
<pre><code class="language-Rust">    let converted: Result&lt;Vec&lt;_&gt;,_&gt; = iter.collect();
//Ok([5, 52, 65])
</code></pre>
<p>如果转换错误?然后你会得到<code>Err</code>遇到第一个错误. 这是非常灵活的一个很好的例子 <code>collect</code>是.(这里的符号可能会吓人 -<code>Vec&lt;_&gt;</code>意味着&quot;这是一个 Vec ,为我制定出实际的类型<code>和</code>Result&lt;vec&lt;<em>&gt;</em>&gt;还要求 Rust 计算错误类型.)</p>
<p>所以有一个 <em>批量{lot}</em> 文档中的详细信息. 但它肯定比C ++文档所说的更清晰<code>的std::vec</code></p>
<blockquote>
<p>对元素施加的要求取决于对容器执行的实际操作. 一般来说,要求元素类型是完整类型并且符合Erasable的要求,但是许多成员函数会施加更严格的要求.</p>
</blockquote>
<p>用C ++,你是独立的. rust 的清晰度一开始令人望而生畏,但当你学习阅读约束条件时,你将确切地知道任何特定的方法<code>Vec</code>需要.</p>
<p>我建议你使用源代码<code>rustup component add rust-src</code>,因为标准库源代码非常易读,并且方法实现通常不如方法声明那么可怕.</p>
<a class="header" href="print.html#maps" id="maps"><h2>Maps</h2></a>
<p><em>Maps</em>(有时叫 <em>关联数组</em> 要么 <em>dicts{字典}</em> ); 让你查看与一个相关的值 <em>key{key}</em>. 这不是一个真正的花式概念,可以用一系列元组来完成:</p>
<pre><code class="language-Rust">    let entries =[(&quot;one&quot;,&quot;eins&quot;),(&quot;two&quot;,&quot;zwei&quot;),(&quot;three&quot;,&quot;drei&quot;)];

    if let Some(val) = entries.iter().find(|t| t.0 == &quot;two&quot;) {
        assert_eq!(val.1,&quot;zwei&quot;);
    }
</code></pre>
<p>这对于小 map 来说很好,只需要为key定义相等,但搜索需要线性时间 - 与 map 大小成比例.</p>
<p>一个<code>HashMap</code>有一个更好 <em>批量{lot}</em> 要搜索的 key/值 对的列表:</p>
<pre><code class="language-Rust">use std::collections::HashMap;

let mut map = HashMap::new();
map.insert(&quot;one&quot;,&quot;eins&quot;);
map.insert(&quot;two&quot;,&quot;zwei&quot;);
map.insert(&quot;three&quot;,&quot;drei&quot;);

assert_eq!(map.contains_key(&quot;two&quot;), true);
assert_eq!(map.get(&quot;two&quot;), Some(&amp;&quot;zwei&quot;));
</code></pre>
<p><code>&amp;&quot;zwei&quot;</code>?这是因为<code>get</code>返回一个 <em>引用</em> 到价值,而不是价值本身. 这里的值类型是<code>&amp;str</code>,所以我们得到一个<code>&amp;&amp;str</code>. 一般来说它 <em>具有</em> 作为引用,因为我们不能 <em>移动{move}</em> 一种超出其拥有类型的价值.</p>
<p><code>get_mut</code>就好像<code>get</code>但返回一个可能的可变引用. 这里我们有一个从字符串到整数的映射,并希望更新key'two'的值:</p>
<pre><code class="language-Rust">let mut map = HashMap::new();
map.insert(&quot;one&quot;,1);
map.insert(&quot;two&quot;,2);
map.insert(&quot;three&quot;,3);

println!(&quot;before {}&quot;, map.get(&quot;two&quot;).unwrap());

{
    let mut mref = map.get_mut(&quot;two&quot;).unwrap();
    *mref = 20;
}

println!(&quot;after {}&quot;, map.get(&quot;two&quot;).unwrap());
// before 2
// after 20
</code></pre>
<p>请注意,获取可写入的引用发生在它自己的块中 - 否则,我们将有一个可变的借位持续到结束,然后 Rust 不会允许您从<code>map</code>再次借与<code>map.get(&quot;two&quot;)</code>;它不能允许任何可读的引用,同时已经有一个可写引用的范围.(如果是这样,它不能保证那些可读的引用将保持有效.)所以解决方案是确保可变借用不会持续很长时间.</p>
<p>这不是最优雅的API,但我们不能抛弃任何可能的错误. Python会抛出一个异常,而C ++只会创建一个默认值.(这很方便,但偷偷摸摸;容易忘记的价格a_map[ &quot;two&quot;]`总是返回一个整数是我们不能区分 zero 和 '未找到' 之间的区别, <em>加</em> 一个额外的条目被创建!)</p>
<p>没有人只是运行 <code>unwrap</code>, 除了例子中除外. 但是,您看到的大多数 Rust 代码都由一些独立的示例组成!比赛发生的可能性更大: 我们可以遍历key/值对,但不是以任何特定的顺序.</p>
<pre><code class="language-Rust">if let Some(v) = map.get(&quot;two&quot;) {
    let res = v + 1;
    assert_eq!(res, 3);
}
...
match map.get_mut(&quot;two&quot;) {
    Some(mref) =&gt; *mref = 20,
    None =&gt; panic!(&quot;_now_ we can panic!&quot;)
}
</code></pre>
<p>也有</p>
<pre><code class="language-Rust">for(k,v) in map.iter() {
    println!(&quot;key {} value {}&quot;, k,v);
}
// key one value eins
// key three value drei
// key two value zwei
</code></pre>
<p>按<code>key</code>和<code>值</code>方法分别通过key和值返回 迭代器 ,这使得创建值的 Vec 变得容易.</p>
<a class="header" href="print.html#a示例-计算单词" id="a示例-计算单词"><h2>示例: 计算单词</h2></a>
<p>与文本有关的一个有趣的事情是计数字频率.</p>
<p>将文本分解为单词很简单<code>split_whitespace</code>,但是我们真的要尊重标点符号.  所以这些词应该被定义为只包含字母字符. 这些词也需要作为小写字母进行比较. 在 map 上做一个可变的查找很简单,但是处理查找失败的情况有点尴尬.</p>
<p>幸运的是,有一种更新 map 值的方式:</p>
<pre><code class="language-Rust">let mut map = HashMap::new();

for s in text.split(|c: char| ! c.is_alphabetic()) {
    let word = s.to_lowercase();
    let mut count = map.entry(word).or_insert(0);
    *count += 1;
}
</code></pre>
<p>如果没有对应于某个单词的现有计数,那么让我们为该单词和单词创建一个包含零和 <em>插{insert}</em> 它进入 map.它正是C ++映射所做的,除非它明确地完成并且没有偷偷摸摸.</p>
<p>这段代码中只有一个显式类型,这就是<code>char</code>因为弦的怪癖而需要<code>模式{Pattern}</code>使用的特质<code>split</code>. 但我们可以推断出 key 类型是<code>String</code>和 value 类型是<code>i32</code>.</p>
<p>运用<a href="http://www.gutenberg.org/cache/epub/1661/pg1661.txt">福尔摩斯历险记</a>来自古腾堡计划,我们可以更彻底地进行测试. 唯一字词的总数(<code>map.len()</code>) 是8071.</p>
<p>如何找到最常见的二十个单词?首先,将映射转换为(key, value) 元组的 Vec .(因为我们使用了,所以这消耗了 map <code>into_iter</code>.)</p>
<pre><code class="language-Rust">let mut entries: Vec&lt;_&gt; = map.into_iter().collect();
</code></pre>
<p>接下来我们可以按降序排列. <code>sort_by</code>期待的结果<code>cmp</code>方法来自于<code>Ord</code> trait ,它是由整型值类型实现的:</p>
<pre><code class="language-Rust">    entries.sort_by(|a,b| b.1.cmp(&amp;a.1));
</code></pre>
<p>最后打印出前20个条目:</p>
<pre><code class="language-Rust">    for e in entries.iter().take(20) {
        println!(&quot;{} {}&quot;, e.0, e.1);
    }
</code></pre>
<p>(好吧,你 <em>可以</em> 只是循环<code>0..20</code>并在这里给这个 Vec 编制索引 - 这没有错,只是有点不经意 - 而且对于大型迭代来说可能更昂贵.)</p>
<pre><code> 38765
the 5810
and 3088
i 3038
to 2823
of 2778
a 2701
in 1823
that 1767
it 1749
you 1572
he 1486
was 1411
his 1159
is 1150
my 1007
have 929
with 877
as 863
had 830
</code></pre>
<p>有点惊喜 - 那个空的文本是什么?这是因为<code>split</code>适用于单字符分隔符,因此任何标点符号或额外空格都会导致新的分割.</p>
<a class="header" href="print.html#sets" id="sets"><h2>Sets</h2></a>
<p>Sets 是 map ,您只关心关key字,而不关联任何关联的值. 所以<code>inserts</code>只需要一个值,然后使用<code>contains</code>用于测试一个值是否在一个集合中.</p>
<p>像所有容器一样,您可以创建一个<code>HashSet</code>来自 迭代器.这正是什么 <code>collect</code>确实,一旦你给了它必要的类型提示.</p>
<pre><code class="language-Rust">// set1.rs
use std::collections::HashSet;

fn make_set(words: &amp;str) -&gt; HashSet&lt;&amp;str&gt; {
    words.split_whitespace().collect()
}

fn main() {
    let fruit = make_set(&quot;apple orange pear orange&quot;);

    println!(&quot;{:?}&quot;, fruit);
}
// {&quot;orange&quot;, &quot;pear&quot;, &quot;apple&quot;}
</code></pre>
<p>注意(如预期的那样) 重复插入同一个key不起作用,并且集合中值的顺序并不重要.</p>
<p>没有通常的操作,它们不会被设置:</p>
<pre><code class="language-Rust">let fruit = make_set(&quot;apple orange pear&quot;);
let colours = make_set(&quot;brown purple orange yellow&quot;);

for c in fruit.intersection(&amp;colours) {
    println!(&quot;{:?}&quot;,c);
}
// &quot;orange&quot;
</code></pre>
<p>他们都创建 迭代器 ,并且可以使用 <code>collect</code>使这些成为集合.</p>
<p>这是一个快捷方式,就像我们为 vec 定义的那样:</p>
<pre><code class="language-Rust">use std::hash::Hash;

trait ToSet&lt;T&gt; {
    fn to_set(self) -&gt; HashSet&lt;T&gt;;
}

impl&lt;T,I&gt; ToSet&lt;T&gt; for I
where T: Eq + Hash, I: Iterator&lt;Item=T&gt; {

    fn to_set(self) -&gt; HashSet&lt;T&gt; {
       self.collect()
    }
}

...

let intersect = fruit.intersection(&amp;colours).to_set();
</code></pre>
<p>就像所有的 Rust 泛型一样,你需要限制类型 - 这只能用于理解平等的类型(<code>Eq</code>) 并且为其存在&quot;散列函数&quot;(<code>Hash</code>).请记住,没有 <em>类型</em> 叫<code>迭代器</code>,所以<code>I</code>代表任何类型 <em>impl</em> <code>迭代器</code>.</p>
<p>这种在标准库类型上实现我们自己的方法的技术似乎有点过于强大,但是同样存在规则. 我们只能为自己的特质做到这一点. 如果结构和 trait 来自同一个箱子(特别是 stdlib ) ,那么这种实现将不被允许. 通过这种方式,您可以避免造成混乱.</p>
<p>在祝贺自己如此聪明,方便的捷径之前,您应该意识到后果. 如果<code>make_set</code>是这样写的,所以这些是拥有字符串的集合,然后是实际类型<code>相交{intersect}</code>可能会惊喜:</p>
<pre><code class="language-Rust">fn make_set(words: &amp;str) -&gt; HashSet&lt;String&gt; {
    words.split_whitespace().map(|s| s.to_string()).collect()
}
...
// intersect is HashSet&lt;&amp;String&gt;!
let intersect = fruit.intersection(&amp;colours).to_set();
</code></pre>
<p>除此之外, Rust 不会突然开始复制拥有的字符串. <code>相交</code>contains单个<code>&amp;String</code>借来<code>fruit</code>. 我可以向你保证,当你开始修补生命时,这会给你带来麻烦!更好的解决方案是使用 迭代器 <code>clone</code>方法来创建交集的所有字符串副本.</p>
<pre><code class="language-Rust">// intersect is HashSet&lt;String&gt; - much better
let intersect = fruit.intersection(&amp;colours).cloned().to_set();
</code></pre>
<p>一个更强大的定义<code>to_set</code>可能<code>self.cloned().collect()</code>,我邀请您试用.</p>
<a class="header" href="print.html#a示例-交互式命令处理" id="a示例-交互式命令处理"><h2>示例: 交互式命令处理</h2></a>
<p>与程序进行交互式会话通常很有用. 每行都被读入并分成单词;该命令在第一个单词上查找,其余单词作为参数传递给该命令.</p>
<p>自然实现是从命令名到闭包的映射. 但是,我们如何存储关闭,因为它们都会有不同的大小? 拳击他们将他们复制到堆上:</p>
<p>这是第一次尝试:</p>
<pre><code class="language-Rust">    let mut v = Vec::new();
    v.push(Box::new(|x| x * x));
    v.push(Box::new(|x| x / 2.0));

    for f in v.iter() {
        let res = f(1.0);
        println!(&quot;res {}&quot;, res);
    }
</code></pre>
<p>我们在第二次推动时遇到了非常明显的错误:</p>
<pre><code>  = note: expected type `[closure@closure4.rs:4:21: 4:28]`
  = note:    found type `[closure@closure4.rs:5:21: 5:28]`
note: no two closures, even if identical, have the same type
</code></pre>
<p><code>rustc</code>导出了一个过于具体的类型,所以有必要强制该 Vec 具有该类型 <em>盒装 trait 类型</em> 在事情刚刚开始之前:</p>
<pre><code class="language-Rust">    let mut v: Vec&lt;Box&lt;Fn(f64)-&gt;f64&gt;&gt; = Vec::new();
</code></pre>
<p>我们现在可以使用相同的技巧,并将这些盒装封口保存在一个<code>HashMap</code>. 我们仍然需要警惕终身,因为关闭可以从他们的环境中借用.</p>
<p>作为第一个制作它们很诱人<code>FnMut</code>- 也就是说,他们可以修改任何捕获的变量. 但是我们会有不止一个命令,每个命令都有自己的闭包,所以你不能随意借用相同的变量.</p>
<p>所以关闭通过了_可变引用_作为一个参数,加上一段字符串 切片(<code>&amp;[&amp;str]</code>) 代表命令参数. 他们会返回一些<code>Result</code>- 我们会用<code>String</code>首先是错误.</p>
<p><code>D</code>是数据类型,可以是任何大小的数据.</p>
<pre><code class="language-Rust">type CliResult = Result&lt;String,String&gt;;

struct Cli&lt;'a,D&gt; {
    data: D,
    callbacks: HashMap&lt;String, Box&lt;Fn(&amp;mut D,&amp;[&amp;str])-&gt;CliResult + 'a&gt;&gt;
}

impl&lt;'a,D: Sized&gt; Cli&lt;'a,D&gt; {
    fn new(data: D) -&gt; Cli&lt;'a,D&gt; {
        Cli{data: data, callbacks: HashMap::new()}
    }

    fn cmd&lt;F&gt;(&amp;mut self, name: &amp;str, callback: F)
    where F: Fn(&amp;mut D, &amp;[&amp;str])-&gt;CliResult + 'a {
        self.callbacks.insert(name.to_string(),Box::new(callback));
    }
</code></pre>
<p><code>cmd</code>传递一个名称和任何与我们的签名相匹配的封闭,这个签名被装箱并输入到 map 中. <code>Fn</code>意味着我们的关闭借用他们的环境,但不能修改它. 它是声明比实际实现更可怕的通用方法之一!忘记明确的生命是一个常见的错误 -   Rust 不会让我们忘记这些封闭只限于他们的环境!</p>
<p>现在阅读和运行命令:</p>
<pre><code class="language-Rust">    fn process(&amp;mut self,line: &amp;str) -&gt; CliResult {
        let parts: Vec&lt;_&gt; = line.split_whitespace().collect();
        if parts.len() == 0 {
            return Ok(&quot;&quot;.to_string());
        }
        match self.callbacks.get(parts[0]) {
            Some(callback) =&gt; callback(&amp;mut self.data,&amp;parts[1..]),
            None =&gt; Err(&quot;no such command&quot;.to_string())
        }
    }

    fn go(&amp;mut self) {
        let mut buff = String::new();
        while io::stdin().read_line(&amp;mut buff).expect(&quot;error&quot;) &gt; 0 {
            {
                let line = buff.trim_left();
                let res = self.process(line);
                println!(&quot;{:?}&quot;, res);

            }
            buff.clear();
        }
    }
</code></pre>
<p>这是非常简单明了的 - 将行分成单词作为 vec ,查找 map 中的第一个单词,并用存储的可变数据和其余单词调用闭包. 空行会被忽略,不会被视为错误.</p>
<p>接下来,让我们定义一些帮助函数,使我们的闭包更容易返回正确和不正确的结果. 有一个 有点 <em>小</em> 聪明在继续;它们是通用函数,适用于任何可以转换为的类型<code>String</code>.</p>
<pre><code class="language-Rust">fn ok&lt;T: ToString&gt;(s: T) -&gt; CliResult {
    Ok(s.to_string())
}

fn err&lt;T: ToString&gt;(s: T) -&gt; CliResult {
    Err(s.to_string())
}
</code></pre>
<p>最后,主程序. 看看如何<code>OK(答案)</code>作品 - 因为整数知道如何将自己转换为字符串!</p>
<pre><code class="language-Rust">use std::error::Error;

fn main() {
    println!(&quot;Welcome to the Interactive Prompt! &quot;);

    struct Data {
        answer: i32
    }

    let mut cli = Cli::new(Data{answer: 42});

    cli.cmd(&quot;go&quot;,|data,args| {
        if args.len() == 0 { return err(&quot;need 1 argument&quot;); }
        data.answer = match args[0].parse::&lt;i32&gt;() {
            Ok(n) =&gt; n,
            Err(e) =&gt; return err(e.description())
        };
        println!(&quot;got {:?}&quot;, args);
        ok(data.answer)
    });

    cli.cmd(&quot;show&quot;,|data,_| {
        ok(data.answer)
    });

    cli.go();
}
</code></pre>
<p>这里的错误处理有点笨拙,我们稍后会看到如何在这种情况下使用问号运算符. 基本上,特定的错误<code>std::num::ParseIntError</code>实现这个特点 <code>std::error::Error</code>,我们必须把它带入使用范围<code>描述</code>方法 - 铁锈不让 trait 运作,除非它们是可见的.</p>
<p>在行动中:</p>
<pre><code>Welcome to the Interactive Prompt!
go 32
got[&quot;32&quot;]
Ok(&quot;32&quot;)
show
Ok(&quot;32&quot;)
goop one two three
Err(&quot;no such command&quot;)
go 42 one two three
got[&quot;42&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;]
Ok(&quot;42&quot;)
go boo!
Err(&quot;invalid digit found in string&quot;)
</code></pre>
<p>以下是一些明显的改进,供您尝试. 首先,如果我们给<code>cmd</code>第三个参数是帮助行,然后我们可以存储这些帮助行并自动执行&quot;帮助&quot;命令. 其次,有一些命令编辑和历史是 <em>非常</em> 方便,所以使用[ Rust yline](https://crates.io/crates/ Rust yline)从Cargo的库中.</p>
<a class="header" href="print.html#a错误处理" id="a错误处理"><h1>错误处理</h1></a>
<a class="header" href="print.html#a基本的错误处理" id="a基本的错误处理"><h2>基本的错误处理</h2></a>
<p>如果你不能使用问号操作符来实现快乐,那么在生锈中的错误处理可能很笨拙,我们需要返回一个<code>Result</code>它可以接受任何错误. 所有错误都会实现这个 trait <code>std::error::Error</code>, 所以 <em>任何</em> 错误可以转换成一个<code>Box&lt;Error&gt;</code>.</p>
<p>说我们 <em>都</em> 需要处理 I/O 错误和从转换String到数字的错误:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// box-error.rs
use std::fs::File;
use std::io::prelude::*;
use std::error::Error;

fn run(file: &amp;str) -&gt; Result&lt;i32,Box&lt;Error&gt;&gt; {
    let mut file = File::open(file)?;
    let mut contents = String::new();
    file.read_to_string(&amp;mut contents)?;
    Ok(contents.trim().parse()?)
}
#}</code></pre></pre>
<p>所以这是I/O错误的两个问号 (无法打开文件,或无法读取为String) 以及转换错误的一个问号. 最后,我们将结果包装在内<code>Ok</code>.rust可以从返回类型中得出结论<code>parse</code>应该转换为<code>i32</code>.</p>
<p>很容易为此创建一个快捷方式<code>Result</code>类型:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
type BoxResult&lt;T&gt; = Result&lt;T,Box&lt;Error&gt;&gt;;
#}</code></pre></pre>
<p>但是,我们的程序将具有特定于应用程序的错误条件,并且需要创建我们自己的错误类型. 基本要求很简单:</p>
<ul>
<li>可以 impl <code>Debug</code></li>
<li>必须 impl <code>Display</code></li>
<li>必须 impl <code>Error</code></li>
</ul>
<p>否则,你的错误可以做到它喜欢的东西.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// error1.rs
use std::error::Error;
use std::fmt;

#[derive(Debug)]
struct MyError {
    details: String
}

impl MyError {
    fn new(msg: &amp;str) -&gt; MyError {
        MyError{details: msg.to_string()}
    }
}

impl fmt::Display for MyError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f,&quot;{}&quot;,self.details)
    }
}

impl Error for MyError {
    fn description(&amp;self) -&gt; &amp;str {
        &amp;self.details
    }
}

// a test function that returns our error result
fn raises_my_error(yes: bool) -&gt; Result&lt;(),MyError&gt; {
    if yes {
        Err(MyError::new(&quot;borked&quot;))
    } else {
        Ok(())
    }
}
#}</code></pre></pre>
<p>打字<code>Result&lt;T,MyError&gt;</code>变得单调乏味,许多防锈模块定义它们自己的模块<code>Result</code>- 例如<code>IO::Result&lt;T&gt;</code>是简短的<code>Result&lt;T,io::Error&gt;</code>.</p>
<p>在下一个例子中,当一个String不能被解析为一个浮点数时,我们需要处理特定的错误.</p>
<p>现在这样<code>?</code>工作寻找从错误的转换 <em>表达</em> 到必须的错误 <em>返回</em>. 并且这个转换由表达<code>From</code> trait. <code>Box&lt;Error&gt;</code>像它一样工作,因为它实现<code>From</code>为所有类型实施<code>Error</code>.</p>
<p>此时您可以继续使用便捷的别名<code>BoxResult</code>并且赶上所有事情;会有我们的错误转化为<code>Box&lt;Error&gt;</code>这对小型应用程序来说是一个很好的选择. 但我想显示其他错误可以明确地与我们的错误类型合作.</p>
<p><code>ParseFloatError</code> impl <code>Error</code>, 所以<code>description()</code>被定义为.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::num::ParseFloatError;

impl From&lt;ParseFloatError&gt; for MyError {
    fn from(err: ParseFloatError) -&gt; Self {
        MyError::new(err.description())
    }
}

// and test!
fn parse_f64(s: &amp;str, yes: bool) -&gt; Result&lt;f64,MyError&gt; {
    raises_my_error(yes)?;
    let x: f64 = s.parse()?;
    Ok(x)
}
#}</code></pre></pre>
<p>首先<code>?</code>是好的 (一种类型总是转换为自己的<code>From</code>) 和第二个<code>?</code>将转换<code>ParseFloatError</code>至<code>MyError</code>.</p>
<p>结果如下:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot; {:?}&quot;, parse_f64(&quot;42&quot;,false));
    println!(&quot; {:?}&quot;, parse_f64(&quot;42&quot;,true));
    println!(&quot; {:?}&quot;, parse_f64(&quot;?42&quot;,false));
}
//  Ok(42)
//  Err(MyError { details: &quot;borked&quot; })
//  Err(MyError { details: &quot;invalid float literal&quot; })
</code></pre></pre>
<p>不要太复杂,虽然有点啰嗦. 该繁琐的一点是不得不写<code>From</code>所有其他错误类型都需要进行转换<code>MyError</code>- 或者你只是依靠<code>Box&lt;Error&gt;</code>. 新手会因为多种方式在 rust 中做同样的事情而感到困惑;总是有另一种方法去剥离鳄梨 (或者如果你感觉嗜血,那么就去皮肤上) . 灵活性的代价有很多选择. 200行程序的错误处理可以比大型应用程序简单得多. 如果您想将您的宝贵物品作为 Cargo 打包,那么错误处理就变得至关重要.</p>
<p>目前,问号运算符仅适用于<code>Result</code>,不<code>Option</code>,这是一个功能,而不是一个限制. <code>Option</code>有一个<code>ok_or_else</code>它将自己转换成一个<code>Result</code>例如,说我们有一个<code>HashMap</code>并且如果没有定义键则必须失败:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let val = map.get(&quot;my_key&quot;).ok_or_else(|| MyError::new(&quot;my_key not defined&quot;))?;
#}</code></pre></pre>
<p>现在这里返回的错误是完全清楚的! (该表单使用闭包,因此只有在查找失败时才会创建错误值. )</p>
<a class="header" href="print.html#simeple-error的简单错误" id="simeple-error的简单错误"><h2>simeple-error的简单错误</h2></a>
<p>该<a href="https://docs.rs/simple-error/0.1.9/simple_error/">simple-error</a>crate为你提供基于String的基本错误类型,正如我们在这里定义的那样,以及一些方便的宏. 就像任何错误一样,<code>Box&lt;Error&gt;</code>也可以正常工作:</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate simple_error;

use std::error::Error;

type BoxResult&lt;T&gt; = Result&lt;T,Box&lt;Error&gt;&gt;;

fn run(s: &amp;str) -&gt; BoxResult&lt;i32&gt; {
    if s.len() == 0 {
        bail!(&quot;empty string&quot;);
    }
    Ok(s.trim().parse()?)
}

fn main() {
    println!(&quot;{:?}&quot;, run(&quot;23&quot;));
    println!(&quot;{:?}&quot;, run(&quot;2x&quot;));
    println!(&quot;{:?}&quot;, run(&quot;&quot;));
}
// Ok(23)
// Err(ParseIntError { kind: InvalidDigit })
// Err(StringError(&quot;empty string&quot;))
</code></pre></pre>
<p><code>bail!(s)</code>扩展到<code>return SimpleError::new(s).into();</code>- 尽早返回转换 <em>成</em> 接收类型.</p>
<p>你需要使用<code>BoxResult</code>用于混合<code>SimpleError</code>键入其他错误,因为我们无法执行<code>From</code>, 因为它的特点和类型都来自其他箱子.</p>
<a class="header" href="print.html#a严重错误的error-chain" id="a严重错误的error-chain"><h2>严重错误的error-chain</h2></a>
<p>对于非平凡的应用程序有一个看点<a href="http://brson.github.io/2016/11/30/starting-with-error-chain">error_chain</a>crate.</p>
<p>rust 的一个小宏魔法漫长路</p>
<p>创建一个二进制包<code>cargo new --bin test-error-chain</code>并到这个目录. 编辑<code>Cargo.toml</code>并添加<code>error-chain=&quot;0.8.1&quot;</code>到最后.</p>
<p><strong>error-chain</strong> 为你做的是什么, 创建我们所需的所有定义的手动执行错误类型;创建一个结构体,并实现必要的 trait : <code>Display</code>,<code>Debug</code>和<code>Error</code>它也是默认的 impl <code>From</code> , 所以String可以转换成错误.</p>
<p>我们的<code>src/main.rs</code>文件看起来像这样. 所有的主要程序都是运行<code>run</code>,打印出错误,并用非零退出代码结束程序. 宏<code>error_chain</code>生成所需的所有定义<code>Error</code>模块 - 在一个更大的程序中,你会把它放在它自己的文件中. 我们需要把所有东西都放进去<code>Error</code>回到全局范围,因为我们的代码将需要生成生成的 trait. 默认情况下,会有一个<code>Error</code>结构和一个<code>Result</code>用这个错误定义.</p>
<p>这里我们也要求<code>From</code>要这样做<code>std::io::Error</code>将使用转换为我的错误类型<code>foreign_links</code>:</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate error_chain;

mod errors {
    error_chain!{
        foreign_links {
            Io(::std::io::Error);
        }
    }
}
use errors::*;

fn run() -&gt; Result&lt;()&gt; {
    use std::fs::File;

    File::open(&quot;file&quot;)?;

    Ok(())
}


fn main() {
    if let Err(e) = run() {
        println!(&quot;error: {}&quot;, e);

        std::process::exit(1);
    }
}
// error: No such file or directory (os error 2)
</code></pre></pre>
<p>'foreign_links'让我们的生活更轻松,因为问号操作员现在知道如何转换<code>std::io::Error</code>进入我们的<code>error::Error</code>.  (在引擎盖下,宏正在创建一个<code>From&lt;std::io::Error&gt;</code>转换,正如前面所述. )</p>
<p>所有的行动都发生在<code>run</code>;让我们打印出作为第一个程序参数给出的文件的前10行. 有可能也可能不会有这样的论点,这不一定是错误的. 这里我们要转换一个<code>Option&lt;String&gt;</code>变成一个<code>Result&lt;String&gt;</code>. 那里有两个<code>Option</code>做这种转换的方法,我选择了最简单的一种. 我们的<code>Error</code>类型的工具<code>From</code>对于<code>&amp;str</code>,所以用一个简单的文本信息就很容易发生错误.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn run() -&gt; Result&lt;()&gt; {
    use std::env::args;
    use std::fs::File;
    use std::io::BufReader;
    use std::io::prelude::*;

    let file = args().skip(1).next()
        .ok_or(Error::from(&quot;provide a file&quot;))?;

    let f = File::open(&amp;file)?;
    let mut l = 0;
    for line in BufReader::new(f).lines() {
        let line = line?;
        println!(&quot;{}&quot;, line);
        l += 1;
        if l == 10 {
            break;
        }
    }

    Ok(())
}
#}</code></pre></pre>
<p>(再次) 有一个有用的小宏<code>bail!</code>为'抛出'错误. 替代方案<code>ok_or</code>方法可能是:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let file = match args().skip(1).next() {
        Some(s) =&gt; s,
        None =&gt; bail!(&quot;provide a file&quot;)
    };
#}</code></pre></pre>
<p>喜欢<code>?</code>它做了一个 <em>提前返回</em>.</p>
<p>返回的错误包含一个枚举<code>ErrorKind</code>,这使我们能够区分各种各样的错误. 总是有一个变体<code>Msg</code> (当你说<code>Error::from(str)</code>) 和<code>foreign_links</code>已宣布<code>Io</code>它包装 I/O 错误:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    if let Err(e) = run() {
        match e.kind() {
            &amp;ErrorKind::Msg(ref s) =&gt; println!(&quot;msg {}&quot;,s),
            &amp;ErrorKind::Io(ref s) =&gt; println!(&quot;io {}&quot;,s),
        }
        std::process::exit(1);
    }
}
// $ cargo run
// msg provide a file
// $ cargo run foo
// io No such file or directory (os error 2)
</code></pre></pre>
<p>添加新的错误很简单. 添加一个<code>Error</code>部分<code>error_chain!</code>宏:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    error_chain!{
        foreign_links {
            Io(::std::io::Error);
        }

        errors {
            NoArgument(t: String) {
                display(&quot;no argument provided: '{}'&quot;, t)
            }
        }

    }
#}</code></pre></pre>
<p>这定义了如何<code>Display</code>适用于这种新的错误. 现在我们可以更具体地处理'no argument'的错误,喂养<code>ErrorKind::NoArgument</code>一个<code>String</code>值:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let file = args().skip(1).next()
        .ok_or(ErrorKind::NoArgument(&quot;filename needed&quot;.to_string()))?;
#}</code></pre></pre>
<p>现在有一个额外的<code>ErrorKind</code>您必须匹配的变体:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    if let Err(e) = run() {
        println!(&quot;error {}&quot;,e);
        match e.kind() {
            &amp;ErrorKind::Msg(ref s) =&gt; println!(&quot;msg {}&quot;, s),
            &amp;ErrorKind::Io(ref s) =&gt; println!(&quot;io {}&quot;, s),
            &amp;ErrorKind::NoArgument(ref s) =&gt; println!(&quot;no argument {:?}&quot;, s),
        }
        std::process::exit(1);
    }
}
// cargo run
// error no argument provided: 'filename needed'
// no argument &quot;filename needed&quot;
</code></pre></pre>
<p>一般来说,尽可能使错误尽可能具有特定的意义,<em>尤其</em> 如果这是一个库函数!这种 match-on-kind 技术几乎相当于传统的异常处理,您可以匹配异常类型在<code>catch</code>要么<code>except</code>块.</p>
<p>综上所述,<strong>error-chain</strong>创建一个类型<code>Error</code>, 和为你定义<code>Result&lt;T&gt;</code>成为<code>std::result::Result&lt;T,Error&gt;</code>. <code>Error</code>包含一个枚举<code>ErrorKind</code>并且默认情况下有一个变体<code>Msg</code>用于从String创建的错误. 你用来定义外部错误<code>foreign_links</code>这有两件事. 首先,它创建一个新的<code>ErrorKind</code>变种. 其次,它定义了<code>From</code>在这些外部错误,所以他们可以转换为无辜的. 新的错误变体可以很容易地添加. 许多恼人的样板代码被淘汰.</p>
<a class="header" href="print.html#a链接错误" id="a链接错误"><h2>链接错误</h2></a>
<p>但这个 箱子{crate} 提供的非常酷的东西是 <em>error-chainning</em>.</p>
<p>作为一个 <em>库用户</em> ,当一个方法只是'抛出'一个通用的I/O错误时,这是​​令人烦恼的. 好吧,它不能打开一个文件,很好,但是什么文件?基本上,这个信息对我有什么用处?</p>
<p><code>error_chain</code>作为 <em>error-chainning</em> 这有助于解决过度通用错误的问题. 当我们尝试打开文件时,我们可以懒洋洋地依靠转<code>io::Error</code>而用<code>?</code>, 要么 <em>链{chain}</em> 错误.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// non-specific error
let f = File::open(&amp;file)?;

// a specific chained error
let f = File::open(&amp;file).chain_err(|| &quot;unable to read the damn file&quot;)?;
#}</code></pre></pre>
<p>这里是该程序的新版本 <em>没有</em> 导入'foreign'错误,只是默认值:</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate error_chain;

mod errors {
    error_chain!{
    }

}
use errors::*;

fn run() -&gt; Result&lt;()&gt; {
    use std::env::args;
    use std::fs::File;
    use std::io::BufReader;
    use std::io::prelude::*;

    let file = args().skip(1).next()
        .ok_or(Error::from(&quot;filename needed&quot;))?;

    ///////// chain explicitly! ///////////
    let f = File::open(&amp;file).chain_err(|| &quot;unable to read the damn file&quot;)?;

    let mut l = 0;
    for line in BufReader::new(f).lines() {
        let line = line.chain_err(|| &quot;cannot read a line&quot;)?;
        println!(&quot;{}&quot;, line);
        l += 1;
        if l == 10 {
            break;
        }
    }

    Ok(())
}


fn main() {
    if let Err(e) = run() {
        println!(&quot;error {}&quot;, e);

        /////// look at the chain of errors... ///////
        for e in e.iter().skip(1) {
            println!(&quot;caused by: {}&quot;, e);
        }

        std::process::exit(1);
    }
}
// $ cargo run foo
// error unable to read the damn file
// caused by: No such file or directory (os error 2)
</code></pre></pre>
<p>所以<code>chain_err</code>方法接受原始错误,并创建一个包含原始错误的新错误 - 这可以无限期地继续. 预计关闭将返回任何可能的值 <em>转换</em> 进入错误.</p>
<p>Rust 宏可以明显地为您节省大量的打字工作. <code>error-chain</code>甚至提供了一个取代整个主程序的捷径:</p>
<pre><pre class="playpen"><code class="language-rust">quick_main!(run);
</code></pre></pre>
<p>(<code>run</code>无论如何,所有的行动都是在那里进行的. )</p>
<a class="header" href="print.html#a线程网络和共享" id="a线程网络和共享"><h1>线程,网络和共享</h1></a>
<a class="header" href="print.html#a改变不变" id="a改变不变"><h2>改变不变</h2></a>
<p>如果你感觉猪头 (如我) ,你想知道是否 <em>有过</em> 可能避开借用检查器的限制.</p>
<p>考虑下面的小程序,它编译和运行没有问题.</p>
<pre><pre class="playpen"><code class="language-rust">// cell.rs
use std::cell::Cell;

fn main() {
    let answer = Cell::new(42);

    assert_eq!(answer.get(), 42);

    answer.set(77);

    assert_eq!(answer.get(), 77);
}
</code></pre></pre>
<p>答案已经改变了 - 但还是 <em>变量</em> <code>回答</code>是不可变的!</p>
<p>这显然是非常安全的,因为单元格内的值只能通过访问<code>set</code>和<code>get</code>. 这是通过的盛大名称 <em>内部可变性</em>. 通常被称为 <em>遗传可变性</em>: 如果我有一个结构值<code>v</code>,如果<code>v</code>本身是可写的, 那么我只能写字段<code>v.a</code>. <code>Cell</code>价值观放宽了这个规则,因为我们可以改变其中包含的价值<code>set</code>即使细胞本身不可变.</p>
<p>然而,<code>Cell</code>只适用于<code>Copy</code>类型 (例如派生的原始类型和用户类型<code>Copy</code>特征) .</p>
<p>对于其他值,我们必须得到一个可以工作的引用,可变或不可变. 这是什么<code>RefCell</code>规定 - 您明确要求引用包含的值:</p>
<pre><pre class="playpen"><code class="language-rust">// refcell.rs
use std::cell::RefCell;

fn main() {
    let greeting = RefCell::new(&quot;hello&quot;.to_string());

    assert_eq!(*greeting.borrow(), &quot;hello&quot;);
    assert_eq!(greeting.borrow().len(), 5);

    *greeting.borrow_mut() = &quot;hola&quot;.to_string();

    assert_eq!(*greeting.borrow(), &quot;hola&quot;);
}
</code></pre></pre>
<p>再次,<code>greeting</code>没有被宣布为可变!</p>
<p>明确的解除引用操作符<code>*</code>可能在Rust中有点混乱,因为通常你不需要它 - 例如<code>greeting.borrow().len()</code>因为方法调用会隐含地解除引用,所以很好. 但是你需要 <em>确实</em> <code>*</code>拉出底层 - <code>&amp;String</code>从<code>greeting.borrow()</code>或者<code>&amp;mut String</code>从<code>greeting.borrow_mut()</code>.</p>
<p>用一个<code>RefCell</code>并不总是安全的,因为从这些方法返回的任何引用必须遵循通常的规则.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let mut gr = greeting.borrow_mut(); // gr is a mutable borrow
    *gr = &quot;hola&quot;.to_string();

    assert_eq!(*greeting.borrow(), &quot;hola&quot;); //&lt;== we blow up here!
....
thread 'main' panicked at 'already mutably borrowed: BorrowError'
#}</code></pre></pre>
<p>你不能永久借, 如果你已经可以借用 - 这很重要 - 违反规则的事情发生在 <em>运行时</em>. 解决方案 (一如既往) 是尽可能地限制可变借入的范围 - 在这种情况下,您可以在此处放置前两行<code>区域块{}</code>,以便可变引用<code>gr</code>在我们再次借用之前下降.</p>
<p>所以,这不是一个你没有理由使用的功能,因为你 <em>不</em> 会得到一个编译时错误. 这些类型提供 <em>动态借用</em> 在通常的规则使某些事情不可能的情况下.</p>
<a class="header" href="print.html#a共享引用" id="a共享引用"><h2>共享引用</h2></a>
<p>到目前为止,价值与其借用引用之间的关系在编译时已经清楚并且已知. 价值是所有者,并且引用不能超过它. 但许多案例根本不适合这种整洁的模式. 例如,假设我们有一个<code>播放机{Player}</code>结构和一个<code>Role{Role}</code>结构. 一个<code>播放机{Player}</code>保持引用的向量<code>Role{Role}</code>对象. 这些价值观之间并没有一个整齐的一对一关系,并且说服<code>rustc</code>合作变得讨厌.</p>
<p><code>Rc</code>工作上像<code>Box</code>- 堆内存被分配并且值被移动到它. 如果你克隆一个<code>Box</code>它会分配一个值的完整克隆副本. 但克隆一个<code>Rc</code>是便宜的,因为每次你克隆它只是更新一个 <em>引用计数</em> 到了 <em>相同的数据</em>. 这是一种古老且非常 流{stream}  行的内存管理策略,例如用于 iOS / MacOS上的 Objective C 运行时.  (在现代C ++中,它是用<code>std::shared_ptr</code>. )</p>
<p>当一个<code>Rc</code>被丢弃时,引用计数递减. 当该计数变为零时,拥有的值将被丢弃并释放内存.</p>
<pre><pre class="playpen"><code class="language-rust">// rc1.rs
use std::rc::Rc;

fn main() {
    let s = &quot;hello dolly&quot;.to_string();
    let rs1 = Rc::new(s); // s moves to heap; ref count 1
    let rs2 = rs1.clone(); // ref count 2

    println!(&quot;len {}, {}&quot;, rs1.len(), rs2.len());
} // both rs1 and rs2 drop, string dies.
</code></pre></pre>
<p>您可以根据自己的喜好制作尽可能多的引用文献,以获得最初的价值 - 这会再次 <em>动态借用</em> . 您不必仔细追踪价值之间的关系<code>T</code>及其引用资料<code>&amp;T</code>. 有一些运行时间成本,所以它不是 <em>第一</em> 你选择的解决方案,但它使分享的模式成为可能,这将会使借用检查器变得不合适. 注意<code>Rc</code>为您提供不可变的共享引用,因为否则这会破坏借用的基本规则之一. 一只豹在不停止成为豹的情况下不能改变其斑点.</p>
<p>在<code>播放机{Player}</code>的情况下,它现在可以保持它的<code>Vec&lt;Rc&lt;Role&gt;&gt;</code>并且工作很好 - 我们可以添加或删除Role,但不能在创作之后 <em>更改</em> 他们.</p>
<p>但是,如果每个都是<code>播放机{Player}</code>需要保持对 <em>球队</em> 引用作为一个向量<code>播放机{Player}</code>引用? 然后一切都变得不可变,因为所有的东西<code>播放机{Player}</code>值需要被存储为<code>Rc</code>! 这是地方<code>RefCell</code>变得必要. 团队可能被定义为<code>Vec&lt;Rc&lt;RefCell&lt;Player&gt;&gt;&gt;</code>. 现在可以更改一个<code>播放机{Player}</code>价值使用<code>borrow_mut</code>,与此同时没有人 <em>提供</em> '检查出'一个引用<code>播放机{Player}</code>. 例如,假设我们有一条规则,即如果某位球员发生了某种特殊情况,那么他们的所有球队都会变得更强大:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    for p in &amp;self.team {
        p.borrow_mut().make_stronger();
    }
#}</code></pre></pre>
<p>所以应用程序代码不是太糟糕,但类型签名会有点吓人. 你总是可以用一个简化它们<code>type</code>别名:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
type PlayerRef = Rc&lt;RefCell&lt;Player&gt;&gt;;
#}</code></pre></pre>
<a class="header" href="print.html#a多线程" id="a多线程"><h2>多线程</h2></a>
<p>在过去的二十年中,从原始处理速度转向具有多核的CPU. 因此,充分利用现代计算机的唯一方法是保持所有这些内核的繁忙. 正如我们所看到的那样,当然是可能的在后台运行子进程<code>命令</code>但仍然存在一个sync问题: 我们不确切地知道这些孩子何时完成而不等待他们.</p>
<p>还有其他原因需要分开 <em>执行线程</em>, 当然. 例如,您无法锁定整个 流{stream}  程,只能等待阻止 I / O.</p>
<p>分出子线程在Rust中很简单 - 喂食<code>spawn</code>一个在后台执行的闭包.</p>
<pre><pre class="playpen"><code class="language-rust">// thread1.rs
use std::thread;
use std::time;

fn main() {
    thread::spawn(|| println!(&quot;hello&quot;));
    thread::spawn(|| println!(&quot;dolly&quot;));

    println!(&quot;so fine&quot;);
    // wait a little bit
    thread::sleep(time::Duration::from_millis(100));
}
// so fine
// hello
// dolly
</code></pre></pre>
<p>显然,只是&quot;稍等一下&quot;并不是一个非常严格的解决方案! 运行工作最好<code>join</code>在返回的对象上 - 然后主线程等待生成的线程完成.</p>
<pre><pre class="playpen"><code class="language-rust">// thread2.rs
use std::thread;

fn main() {
    let t = thread::spawn(|| {
        println!(&quot;hello&quot;);
    });
    println!(&quot;wait {:?}&quot;, t.join());
}
// hello
// wait Ok(())
</code></pre></pre>
<p>这是一个有趣的变化: 强制新线程恐慌.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let t = thread::spawn(|| {
        println!(&quot;hello&quot;);
        panic!(&quot;I give up!&quot;);
    });
    println!(&quot;wait {:?}&quot;, t.join());
#}</code></pre></pre>
<p>我们如预期般惊慌失措,但只有恐慌线程死亡!我们仍然设法打印出来的错误信息<code>join</code>. 所以是的,恐慌并不总是致命的,但线程相对昂贵,所以这不应被视为处理恐慌的常规方式.</p>
<pre><code>hello
thread '&lt;unnamed&gt;' panicked at 'I give up!', thread2.rs:7
note: Run with `RUST_BACKTRACE=1` for a backtrace.
wait Err(Any)
</code></pre>
<p>返回的对象可以用来跟踪多个线程:</p>
<pre><pre class="playpen"><code class="language-rust">// thread4.rs
use std::thread;

fn main() {
    let mut threads = Vec::new();

    for i in 0..5 {
        let t = thread::spawn(move || {
            println!(&quot;hello {}&quot;, i);
        });
        threads.push(t);
    }

    for t in threads {
        t.join().expect(&quot;thread failed&quot;);
    }
}
// hello 0
// hello 2
// hello 4
// hello 3
// hello 1
</code></pre></pre>
<p>Rust坚持我们处理连接失败的情况 - 即该线程发生恐慌.  (当发生这种情况时,你通常不会退出主程序,只记下错误,重试等)</p>
<p>没有特定的线程执行顺序 (该程序为不同的运行提供不同的顺序) ,这是关键 - 它们确实是 <em>独立的执行线程</em>. 多线程很简单;什么是困难的 <em>并发</em>- 管理和sync多个执行线程.</p>
<a class="header" href="print.html#a线程不会借用" id="a线程不会借用"><h2>线程不会借用</h2></a>
<p>线程闭包有可能捕获值,但是可以通过 <em>移动</em>,而不是 <em>借用</em>!</p>
<pre><pre class="playpen"><code class="language-rust">// thread3.rs
use std::thread;

fn main() {
    let name = &quot;dolly&quot;.to_string();
    let t = thread::spawn(|| {
        println!(&quot;hello {}&quot;, name);
    });
    println!(&quot;wait {:?}&quot;, t.join());
}
</code></pre></pre>
<p>以下是有用的错误消息:</p>
<pre><code>error[E0373]: closure may outlive the current function, but it borrows `name`, which is owned by the current function
 --&gt; thread3.rs:6:27
  |
6 |     let t = thread::spawn(|| {
  |                           ^^ may outlive borrowed value `name`
7 |         println!(&quot;hello {}&quot;, name);
  |                             ---- `name` is borrowed here
  |
help: to force the closure to take ownership of `name` (and any other referenced variables), use the `move` keyword, as shown:
  |     let t = thread::spawn(move || {
</code></pre>
<p>这很公平! 想象一下,从一个函数产生这个线程 - 它将在函数调用完成后存在<code>name</code>被丢弃. 所以补充<code>move</code>解决了我们的问题.</p>
<p>但这是一个 <em>移动</em> ,所以<code>name</code>可能只会出现在一个线程中!我想强调一下 <em>是</em> 可能分享引用,但他们需要有<code>静态{static}</code>生命周期:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let name = &quot;dolly&quot;;
let t1 = thread::spawn(move || {
    println!(&quot;hello {}&quot;, name);
});
let t2 = thread::spawn(move || {
    println!(&quot;goodbye {}&quot;, name);
});
#}</code></pre></pre>
<p><code>name</code>在整个项目期间存在（<code>静态{static}</code>) ,所以<code>rustc</code>对封闭永不过时感到满意<code>name</code>. 但是,大多数有趣的引用文献没有<code>静态{static}</code>寿命!</p>
<p>线程无法共享相同的环境 -  by <em>设计</em> 在Rust. 特别是,他们不能共享常规引用,因为关闭会移动捕获的变量.</p>
<p><em>共享引用</em> 但很好,因为他们的生命是'与需要一样长' - 但你不能为了这而使用<code>Rc</code>. 这是因为<code>Rc</code>不是 <em>线程安全</em>- 它针对非线程情况进行了优化. 幸运的是,这是一个编译错误使用<code>Rc</code>这里;编译器一直在看你的背部.</p>
<p>对于线程,你需要<code>std::sync::Arc</code>- 'Arc'代表'原子引用计数'. 也就是说,它保证了引用计数将在一个逻辑操作中被修改. 为了保证这一点,它必须确保操作被锁定,以便只有当前线程才能访问. <code>clone</code>比实际上制作副本的成本仍然要低得多</p>
<pre><pre class="playpen"><code class="language-rust">// thread5.rs
use std::thread;
use std::sync::Arc;

struct MyString(String);

impl MyString {
    fn new(s: &amp;str) -&gt; MyString {
        MyString(s.to_string())
    }
}

fn main() {
    let mut threads = Vec::new();
    let name = Arc::new(MyString::new(&quot;dolly&quot;));

    for i in 0..5 {
        let tname = name.clone();
        let t = thread::spawn(move || {
            println!(&quot;hello {} count {}&quot;, tname.0, i);
        });
        threads.push(t);
    }

    for t in threads {
        t.join().expect(&quot;thread failed&quot;);
    }
}
</code></pre></pre>
<p>我故意创建了一个包装类型<code>String</code>这里 ('新类型') 自从我们<code>MyString</code>不执行<code>clone</code>. 但是 <em>共享引用</em> 可以克隆!</p>
<p>共享引用<code>name</code>通过使用新的引用传递给每个新线程<code>clone</code>并将其移入封口. 这有点冗长,但这是一种安全模式. 恰恰因为问题如此不可预测,安全在并发中很重要. 一个程序可能在你的机器上运行良好,但偶尔会在服务器上崩溃,通常在周末. 更糟糕的是,这些问题的症状不容易诊断.</p>
<a class="header" href="print.html#a通道" id="a通道"><h2>通道</h2></a>
<p>有线程间发送数据的方法. 这是在Rust使用 <em>渠道</em>. <code>std::sync::mpsc::channel()</code>返回由 <em>接收器{receiver}</em> 频道和 <em>寄件人{sender}</em> 渠道组成的元组. 每个线程都通过发件人的副本<code>clone</code>,和运行<code>发送{send}</code>. 同时主线程调用<code>recv</code>在接收器上.</p>
<p>'MPSC'代表'Multiple Producer Single Consumer'. 我们创建了多个试图发送到频道的线程,并且主线程&quot;消耗&quot;了频道.</p>
<pre><pre class="playpen"><code class="language-rust">// thread9.rs
use std::thread;
use std::sync::mpsc;

fn main() {
    let nthreads = 5;
    let (tx, rx) = mpsc::channel();

    for i in 0..nthreads {
        let tx = tx.clone();
        thread::spawn(move || {
            let response = format!(&quot;hello {}&quot;, i);
            tx.send(response).unwrap();
        });
    }

    for _ in 0..nthreads {
        println!(&quot;got {:?}&quot;, rx.recv());
    }
}
// got Ok(&quot;hello 0&quot;)
// got Ok(&quot;hello 1&quot;)
// got Ok(&quot;hello 3&quot;)
// got Ok(&quot;hello 4&quot;)
// got Ok(&quot;hello 2&quot;)
</code></pre></pre>
<p>由于线程在结束执行之前发送响应,因此无需 <code>join</code> 在此,但显然这可能随时发生. <code>recv</code>将阻塞,并且如果发送者通道断开连接,将返回错误. <code>recv_timeout</code>只会在给定的时间段内阻塞,并且可能还会返回超时错误.</p>
<p><code>发送{send}</code>从不阻塞,这很有用,因为线程可以在不等待接收器处理的情况下推出数据. 另外,通道被缓冲,所以可以发生多个发送操作,这将按顺序接收.</p>
<p>但是,不阻止意味着<code>好{Ok}</code>并不意味着'已成功发送消息'!</p>
<p>一个<code>sync_channel</code> <em>不</em> 阻止发送. 如果参数为零,则发送阻塞直到recv发生. 线程必须满足或 <em>会合{rendezvous}</em> (根据声音原则,法语中大多数声音听起来更好. )</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let (tx, rx) = mpsc::sync_channel(0);

    let t1 = thread::spawn(move || {
        for i in 0..5 {
            tx.send(i).unwrap();
        }
    });

    for _ in 0..5 {
        let res = rx.recv().unwrap();
        println!(&quot;{}&quot;,res);
    }
    t1.join().unwrap();
#}</code></pre></pre>
<p>通过调用,我们可以很容易地导致错误<code>recv</code>当没有相应的时候<code>发送{send}</code>例如通过循环<code>for i in 0..4</code>. 线程结束,并且<code>tx</code>被扔掉,然后<code>recv</code>将失败. 这也会发生,如果线程恐慌,导致其堆栈解开,丢弃任何值.</p>
<p>如果<code>sync_channel</code>是用一个非零参数创建<code>n</code>,那么它的行为就像一个最大尺寸为<code>n</code>的队列-<code>发送{send}</code>只会在尝试超过时才会阻止<code>n</code>值到队列.</p>
<p>频道是强类型的 - 在这里频道有类型<code>i32</code>- 但类型推理使得这种隐含的. 如果您需要传递不同类型的数据,那么枚举是表达这一点的好方法.</p>
<a class="header" href="print.html#synchronization" id="synchronization"><h2>Synchronization</h2></a>
<p>我们来看看 <em>Synchronization</em>. <code>加入{join}</code>是非常基本的,只是等到一个特定的线程完成. 一个<code>sync_channel</code>同步两个线程 - 在最后一个例子中,衍生线程和主线程完全锁定在一起.</p>
<p>Barrier - sync是线程必须等到的 <em>所有</em> 检查点 - 他们已经达到了这一点. 然后他们可以像以前一样继续前进. 屏障是由我们想要等待的线程数创建的. 和以前一样,我们使用use<code>Arc</code>与所有主题共享 Barrier.</p>
<pre><pre class="playpen"><code class="language-rust">// thread7.rs
use std::thread;
use std::sync::Arc;
use std::sync::Barrier;

fn main() {
    let nthreads = 5;
    let mut threads = Vec::new();
    let barrier = Arc::new(Barrier::new(nthreads));

    for i in 0..nthreads {
        let barrier = barrier.clone();
        let t = thread::spawn(move || {
            println!(&quot;before wait {}&quot;, i);
            barrier.wait();
            println!(&quot;after wait {}&quot;, i);
        });
        threads.push(t);
    }

    for t in threads {
        t.join().unwrap();
    }
}
// before wait 2
// before wait 0
// before wait 1
// before wait 3
// before wait 4
// after wait 4
// after wait 2
// after wait 3
// after wait 0
// after wait 1
</code></pre></pre>
<p>线程做他们半随机的事情,全部满足,然后继续. 它就像一种可恢复<code>加入{join}</code>当您需要将工作片段分散到不同的线程, 并且想要在所有线程完成时采取一些行动时有用.</p>
<a class="header" href="print.html#a共享状态" id="a共享状态"><h2>共享状态</h2></a>
<p>线程怎么样 <em>修改</em> 共享状态?</p>
<p>回想一下<code>RC&lt;RefCell&lt;T&gt;&gt;</code>功能是 <em>动态</em> 在共享引用上做一个可变的借用. 线程相当于<code>RefCell</code>是<code>互斥{Mutex}</code>- 你可以通过调用来获得可变引用<code>锁</code>. 虽然存在此引用,但其他线程无法访问它. <code>互斥{Mutex}</code>代表'相互排斥' - 我们锁定了一段代码,以便只有一个线程可以访问它,然后解锁它. 你拿到了锁<code>锁</code>方法,并在引用被删除时解锁.</p>
<pre><pre class="playpen"><code class="language-rust">// thread9.rs
use std::thread;
use std::sync::Arc;
use std::sync::Mutex;

fn main() {
    let answer = Arc::new(Mutex::new(42));

    let answer_ref = answer.clone();
    let t = thread::spawn(move || {
        let mut answer = answer_ref.lock().unwrap();
        *answer = 55;
    });

    t.join().unwrap();

    let ar = answer.lock().unwrap();
    assert_eq!(*ar, 55);

}
</code></pre></pre>
<p>这不像使用那样简单<code>RefCell</code>因为如果另一个线程在锁定时发生恐慌,那么请求互斥锁就可能失败.  (在这种情况下,文档实际上建议只是退出线程<code>unwrap</code>因为事情严重错了!)</p>
<p>把这个可变的借用保持尽可能短是更重要的,因为只要互斥锁被锁定,其他的线程 <em>受阻</em>. 这不是昂贵的计算的地方!所以通常这样的代码会像这样使用:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// ... do something in the thread
// get a locked reference and use it briefly!
{
    let mut data = data_ref.lock().unwrap();
    // modify data
}
//... continue with the thread
#}</code></pre></pre>
<a class="header" href="print.html#a更高级别的操作" id="a更高级别的操作"><h2>更高级别的操作</h2></a>
<p>最好找到更高级的线程化方法,而不是自己管理sync. 一个例子是当你需要平行做事并收集结果时. 一个非常酷的箱子是<a href="https://docs.rs/pipeliner/0.1.1/pipeliner/"> 流{stream}  水线化</a>它有一个非常直接的API. 这是'你好,世界!'<code>- 一个迭代器给我们输入,我们执行到</code>n`并行操作的值.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate pipeliner;
use pipeliner::Pipeline;

fn main() {
    for result in (0..10).with_threads(4).map(|x| x + 1) {
        println!(&quot;result: {}&quot;, result);
    }
}
// result: 1
// result: 2
// result: 5
// result: 3
// result: 6
// result: 7
// result: 8
// result: 9
// result: 10
// result: 4
</code></pre></pre>
<p>这当然是一个愚蠢的例子,因为该操作的计算起来非常便宜,但显示了并行运行代码的容易程度.</p>
<p>这是更有用的东西. 并行执行网络操作非常有用,因为它们可能需要时间,并且您不希望等待它们 <em>所有</em> 在开始工作之前完成.</p>
<p>这个例子非常粗糙 (相信我,有更好的方法可以做到这一点) ,但这里我们要关注这个原则. 我们重用这个<code>shell</code>函数定义在第4节中调用<code>ping</code>在一系列IP4地址上.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate pipeliner;
use pipeliner::Pipeline;

use std::process::Command;

fn shell(cmd: &amp;str) -&gt; (String,bool) {
    let cmd = format!(&quot;{} 2&gt;&amp;1&quot;,cmd);
    let output = Command::new(&quot;/bin/sh&quot;)
        .arg(&quot;-c&quot;)
        .arg(&amp;cmd)
        .output()
        .expect(&quot;no shell?&quot;);
    (
        String::from_utf8_lossy(&amp;output.stdout).trim_right().to_string(),
        output.status.success()
    )
}

fn main() {
    let addresses: Vec&lt;_&gt; = (1..40).map(|n| format!(&quot;ping -c1 192.168.0.{}&quot;,n)).collect();
    let n = addresses.len();

    for result in addresses.with_threads(n).map(|s| shell(&amp;s)) {
        if result.1 {
            println!(&quot;got: {}&quot;, result.0);
        }
    }

}
</code></pre></pre>
<p>我的家庭网络上的结果如下所示:</p>
<pre><code>got: PING 192.168.0.1 (192.168.0.1) 56(84) bytes of data.
64 bytes from 192.168.0.1: icmp_seq=1 ttl=64 time=43.2 ms

--- 192.168.0.1 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 43.284/43.284/43.284/0.000 ms
got: PING 192.168.0.18 (192.168.0.18) 56(84) bytes of data.
64 bytes from 192.168.0.18: icmp_seq=1 ttl=64 time=0.029 ms

--- 192.168.0.18 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 0.029/0.029/0.029/0.000 ms
got: PING 192.168.0.3 (192.168.0.3) 56(84) bytes of data.
64 bytes from 192.168.0.3: icmp_seq=1 ttl=64 time=110 ms

--- 192.168.0.3 ping statistics ---
1 packets transmitted, 1 received, 0% packet loss, time 0ms
rtt min/avg/max/mdev = 110.008/110.008/110.008/0.000 ms
got: PING 192.168.0.5 (192.168.0.5) 56(84) bytes of data.
64 bytes from 192.168.0.5: icmp_seq=1 ttl=64 time=207 ms
...
</code></pre>
<p>在前半秒内,活动地址会非常快速地通过,然后等待负面结果进入. 否则,我们会等待一分钟!您现在可以继续从输出中删除ping时间等事情,尽管这只能在Linux上运行. <code>ping</code>是普遍的,但确切的输出格式对于每个平台都是不同的. 为了做得更好,我们需要使用跨平台的Rust网络API,所以让我们进入网络.</p>
<a class="header" href="print.html#a解决地址问题的更好方法" id="a解决地址问题的更好方法"><h2>解决地址问题的更好方法</h2></a>
<p>如果你 <em>只是</em> 想要可用性和不详细的ping统计信息<code>std::net::ToSocketAddrs</code> trait 将为你做任何DNS解析:</p>
<pre><pre class="playpen"><code class="language-rust">use std::net::*;

fn main() {
    for res in &quot;google.com:80&quot;.to_socket_addrs().expect(&quot;bad&quot;) {
        println!(&quot;got {:?}&quot;, res);
    }
}
// got V4(216.58.223.14:80)
// got V6([2c0f:fb50:4002:803::200e]:80)
</code></pre></pre>
<p>它是一个迭代器,因为通常有多个接口与一个域相关联 - 同时有Google的IPV4和IPV6接口.</p>
<p>所以,我们天真地使用这种方法来重写 流{stream}  水线示例. 大多数网络协议都使用地址和端口:</p>
<pre><pre class="playpen"><code class="language-rust">extern crate pipeliner;
use pipeliner::Pipeline;

use std::net::*;

fn main() {
    let addresses: Vec&lt;_&gt; = (1..40).map(|n| format!(&quot;192.168.0.{}:0&quot;,n)).collect();
    let n = addresses.len();

    for result in addresses.with_threads(n).map(|s| s.to_socket_addrs()) {
        println!(&quot;got: {:?}&quot;, result);
    }
}
// got: Ok(IntoIter([V4(192.168.0.1:0)]))
// got: Ok(IntoIter([V4(192.168.0.39:0)]))
// got: Ok(IntoIter([V4(192.168.0.2:0)]))
// got: Ok(IntoIter([V4(192.168.0.3:0)]))
// got: Ok(IntoIter([V4(192.168.0.5:0)]))
// ....
</code></pre></pre>
<p>这比ping示例快得多,因为它只是检查IP地址是否有效 - 如果我们为它提供了一个实际域名列表,DNS查找可能需要一些时间,因此并行性的重要性.</p>
<p>令人惊讶的是,它只是工作. 标准库中的所有内容实现的事实<code>Debug</code>非常适合勘探和调试. 迭代器正在返回<code>Result</code> (因此<code>Ok</code>) 和在那<code>Result</code>是一个<code>IntoIter</code>变成一个<code>SocketAddr</code>这是一个带有ipv4或ipv6地址的枚举. 为什么<code>IntoIter</code>?由于套接字可能有多个地址 (例如,ipv4和ipv6) .</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    for result in addresses.with_threads(n)
        .map(|s| s.to_socket_addrs().unwrap().next().unwrap())
    {
        println!(&quot;got: {:?}&quot;, result);
    }
// got: V4(192.168.0.1:0)
// got: V4(192.168.0.39:0)
// got: V4(192.168.0.3:0)
#}</code></pre></pre>
<p>至少对于我们这个简单的例子来说,这也起到了令人惊讶的作用. 首先 <code>unwarp</code>摆脱了<code>Result</code>,然后我们明确地将第一个值从迭代器中取出. <code>Result</code>当我们给出一个无意义的地址时 (比如没有端口的地址名称) ,通常会变得很糟糕.</p>
<a class="header" href="print.html#tcp客户端服务器" id="tcp客户端服务器"><h2>TCP客户端服务器</h2></a>
<p>Rust为最常用的网络协议TCP提供了一个直接的界面.</p>
<p>它具有很强的抗错能力,是我们网络世界的基础 - <em>包</em> 的数据被发送和接收,并带有确认. 相比之下,UDP将数据包发送到野外而没有得到确认 - 有一个笑话是&quot;我可以告诉你一个关于UDP的笑话,但你可能得不到它. &quot; (关于网络的笑话只对&quot;有趣&quot;这个词的特殊含义有趣)</p>
<p>但是,错误处理是对于网络来说很 <em>非常</em> 重要,因为任何事情都可能发生,并且最终会.</p>
<p>TCP作为客户端/服务器模型工作;服务器监听一个地址和一个特定的地址 <em>网络端口</em>,并且客户端连接到该服务器. 建立连接后,客户端和服务器可以与套接字进行通信.</p>
<p><code>TcpStream::connect</code>需要任何可以转换成一个<code>SocketAddr</code>,特别是我们一直使用的纯 string.</p>
<p>Rust中的一个简单的TCP客户端很容易 -  一个<code>TcpStream</code>结构是可读和可写的. 像往常一样,我们必须带来<code>Read</code>,<code>Write</code>和其他<code>std::io</code> tarit 纳入范围:</p>
<pre><pre class="playpen"><code class="language-rust">// client.rs
use std::net::TcpStream;
use std::io::prelude::*;

fn main() {
    let mut stream = TcpStream::connect(&quot;127.0.0.1:8000&quot;).expect(&quot;connection failed&quot;);

    write!(stream,&quot;hello from the client!\n&quot;).expect(&quot;write failed&quot;);
 }
</code></pre></pre>
<p>服务器并不复杂,我们建立了一个监听器并等待连接. 当客户端连接时,我们得到一个<code>TcpStream</code>在服务器端. 在这种情况下,我们读取客户端写入字符串的所有内容.</p>
<pre><pre class="playpen"><code class="language-rust">// server.rs
use std::net::TcpListener;
use std::io::prelude::*;

fn main() {

    let listener = TcpListener::bind(&quot;127.0.0.1:8000&quot;).expect(&quot;could not start server&quot;);

    // accept connections and get a TcpStream
    for connection in listener.incoming() {
        match connection {
            Ok(mut stream) =&gt; {
                let mut text = String::new();
                stream.read_to_string(&amp;mut text).expect(&quot;read failed&quot;);
                println!(&quot;got '{}'&quot;, text);
            }
            Err(e) =&gt; { println!(&quot;connection failed {}&quot;, e); }
        }
    }
}
</code></pre></pre>
<p>这里我随机选择了一个无用端口的端口号,但是<a href="https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers">大多数港口</a>被赋予一些含义.</p>
<p>请注意,双方必须就协议达成一致意见 - 客户希望它能够向 流{stream}  写入文本,并且服务器期望从 流{stream}  中读取文本. 如果他们不玩同一个游戏,那么情况就会发生在一方被阻塞的情况下,等待从未到来的字节.</p>
<p>检查错误非常重要 - 网络 I / O 可能因多种原因失败,并且在本地文件系统上可能出现一次 蓝色月亮 的错误可能会定期发生. 有人可以通过网线传输,另一方可能会崩溃,等等. 这个小服务器不是很健壮,因为它会在第一次读取错误时崩溃.</p>
<p>这是一个更坚实的服务器,可以在不失败的情况下处理错误. 它还具体读取一个 <em>线{line}</em> 从 流{stream}  ,这是使用了<code>IO::BufReader</code>创造一个<code>IO::BufRead</code>, 这叫做<code>read_line</code>.</p>
<pre><pre class="playpen"><code class="language-rust">// server2.rs
use std::net::{TcpListener, TcpStream};
use std::io::prelude::*;
use std::io;

fn handle_connection(stream: TcpStream) -&gt; io::Result&lt;()&gt;{
    let mut rdr = io::BufReader::new(stream);
    let mut text = String::new();
    rdr.read_line(&amp;mut text)?;
    println!(&quot;got '{}'&quot;, text.trim_right());
    Ok(())
}

fn main() {

    let listener = TcpListener::bind(&quot;127.0.0.1:8000&quot;).expect(&quot;could not start server&quot;);

    // accept connections and get a TcpStream
    for connection in listener.incoming() {
        match connection {
            Ok(stream) =&gt; {
                if let Err(e) = handle_connection(stream) {
                    println!(&quot;error {:?}&quot;, e);
                }
            }
            Err(e) =&gt; { print!(&quot;connection failed {}\n&quot;, e); }
        }
    }
}
</code></pre></pre>
<p><code>read_line</code>可能会失败<code>handle_connection</code>,但由此产生的错误是安全处理的.</p>
<p>像这样的单向通信当然是有用的 - 例如. 通过网络提供的一组服务,希望在一个中心位置将他们的状态报告集中在一起. 但期望有礼貌的回复是合理的,即使只是'好'!</p>
<p>一个简单的例子是一个基本的'echo'服务器. 客户端将一些以换行符结尾的文本写入服务器,并使用换行符接收相同的文本 -  流{stream}  是可读写的.</p>
<pre><pre class="playpen"><code class="language-rust">// client_echo.rs
use std::io::prelude::*;
use std::net::TcpStream;

fn main() {
    let mut stream = TcpStream::connect(&quot;127.0.0.1:8000&quot;).expect(&quot;connection failed&quot;);
    let msg = &quot;hello from the client!&quot;;

    write!(stream,&quot;{}\n&quot;, msg).expect(&quot;write failed&quot;);

    let mut resp = String::new();
    stream.read_to_string(&amp;mut resp).expect(&quot;read failed&quot;);
    let text = resp.trim_right();
    assert_eq!(msg,text);
}
</code></pre></pre>
<p>服务器有一个有趣的转折点. 只要<code>handle_connection</code>变化:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn handle_connection(stream: TcpStream) -&gt; io::Result&lt;()&gt;{
    let mut ostream = stream.try_clone()?;
    let mut rdr = io::BufReader::new(stream);
    let mut text = String::new();
    rdr.read_line(&amp;mut text)?;
    ostream.write_all(text.as_bytes())?;
    Ok(())
}
#}</code></pre></pre>
<p>这是一个简单的双向套接字通信的常见问题;我们想要读取一行,因此需要将可读 流{stream}  提供给<code>BufReader</code>- 但它 <em>消耗</em> 流{stream}  !所以我们必须克隆这个 流{stream}  ,创建一个引用相同底层套接字的新结构. 然后我们有幸福.</p>
<a class="header" href="print.html#a面向对象的rust" id="a面向对象的rust"><h2>面向对象的Rust</h2></a>
<p>每个人都来自某个地方,以前的编程语言以特定的方式实现了面向对象编程 (OOP) 的可能性很大:</p>
<ul>
<li>'classes'作为工厂生成 <em>对象</em> (通常被称为 <em>实例</em>) 并定义唯一的类型.</li>
<li>类可能 <em>继承</em> 来自其他 class (他们的 <em>父母</em>) ,继承数据 (<em>fields</em>) 和行为 (<em>方法</em>)</li>
<li>如果 A 是 B 的 父母,那么可以将B的一个实例传递给期望A (<em>分类{subtyping}</em>)</li>
<li>一个对象应该隐藏它的数据 (<em>封装</em>) ,只能用方法操作.</li>
</ul>
<p>面向对象 <em>设计</em> 然后是识别类 ('名词') 和方法 ('动词') ,然后建立它们之间的关系, <em>是一个</em> 和 <em>有一个</em>.</p>
<p>在旧版&quot;星际迷航&quot;系列中,医生会对船长说: &quot;这是人生,吉姆,而不是我们所知道的生活&quot;. 这非常适用于Rust风格的面向对象: 它会带来震撼,因为Rust数据聚合 (结构,枚举和元组) 是愚蠢的. 你可以在其上定义方法,并使数据本身是私有的,所有通常的封装策略,但它们都是 <em>无关的类型</em>. 没有数据分类和数据继承 (除了专门的案例) <code>Deref</code>强制转换. )</p>
<p>Rust中各种数据类型之间的关系使用 _ trait {traits}_. 学习Rust的很大一部分是理解标准库 trait 如何操作,因为这是将所有数据类型粘合在一起的意义网络.</p>
<p>特质{trait} 很有趣,因为它们与主流语言的概念之间没有一一对应的关系. 这取决于你是动态还是静态思考. 在动态的情况下,它们更像Java或Go接口 - interfaces.</p>
<a class="header" href="print.html#a特质trait-对象" id="a特质trait-对象"><h3>特质{trait} 对象</h3></a>
<p>考虑一下第一个用来介绍特质{trait} 的例子:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Show {
    fn show(&amp;self) -&gt; String;
}

impl Show for i32 {
    fn show(&amp;self) -&gt; String {
        format!(&quot;four-byte signed {}&quot;, self)
    }
}

impl Show for f64 {
    fn show(&amp;self) -&gt; String {
        format!(&quot;eight-byte float {}&quot;, self)
    }
}
#}</code></pre></pre>
<p>这是一个有很大影响的小程序:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let answer = 42;
    let maybe_pi = 3.14;
    let v: Vec&lt;&amp;Show&gt; = vec![&amp;answer,&amp;maybe_pi];
    for d in v.iter() {
        println!(&quot;show {}&quot;,d.show());
    }
}
// show four-byte signed 42
// show eight-byte float 3.14
</code></pre></pre>
<p>这是一个Rust需要某种类型指导的情况 - 我特别需要一个引用的向量是关于 impl 的<code>显示{Show}</code>. 现在请注意i32<code>和</code>f64<code>彼此没有任何关系,但他们都明白这一点</code>显示`方法,因为它们都实施相同的特质{trait} . 这种方法是 <em>虚拟{virtual}</em>,因为实际的方法对于不同的类型有不同的代码,但是正确的方法是基于的 <em>运行时{runtime}</em> 信息. 这些引用被调用<a href="https://doc.rust-lang.org/stable/book/trait-objects.html">特质{trait} 对象</a></p>
<p>和 <em>那</em> 是如何将不同类型的对象放在同一个 向量{Vec} 中. 如果您来自Java或Go背景,您可以考虑<code>显示{Show}</code>充当接口.</p>
<p>这个例子的一点细化 - 我们 <em>框{box}</em> 价值. 一个盒子包含对分配在堆上的数据的引用,并且非常像引用 - 它是一个 <em>智能指针</em>. 当库超出范围和<code>Drop</code>启动,然后释放内存.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let answer = Box::new(42);
let maybe_pi = Box::new(3.14);

let show_list: Vec&lt;Box&lt;Show&gt;&gt; = vec![question,answer];
for d in &amp;show_list {
    println!(&quot;show {}&quot;,d.show());
}
#}</code></pre></pre>
<p>不同之处在于,您现在可以使用此 Vec ,将其作为引用传递给它,或者不必跟踪任何借用的引用就可以将其传递出去. 当 Vec 被丢弃时,这些框将被丢弃,并且所有的内存都被回收.</p>
<a class="header" href="print.html#a动物" id="a动物"><h2>动物</h2></a>
<p>出于某种原因,任何关于面向对象和继承的讨论似乎最终都会讨论动物.
它创造了一个不错的故事: &quot;看,猫是食肉动物,食肉动物是动物&quot;.</p>
<p>但我会从Ruby宇宙的经典口号开始: &quot;如果它嘎嘎叫,那就是鸭子&quot;. 你所有的对象必须做的是定义 <code>嘎嘎{quacks}</code> 他们可以被认为是鸭子,虽然在一个非常狭窄的方式.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Quack {
    fn quack(&amp;self);
}

struct Duck ();

impl Quack for Duck {
    fn quack(&amp;self) {
        println!(&quot;quack!&quot;);
    }
}

struct RandomBird {
    is_a_parrot: bool
}

impl Quack for RandomBird {
    fn quack(&amp;self) {
        if ! self.is_a_parrot {
            println!(&quot;quack!&quot;);
        } else {
            println!(&quot;squawk!&quot;);
        }
    }
}

let duck1 = Duck();
let duck2 = RandomBird{is_a_parrot: false};
let parrot = RandomBird{is_a_parrot: true};

let ducks: Vec&lt;&amp;Quack&gt; = vec![&amp;duck1,&amp;duck2,&amp;parrot];

for d in &amp;ducks {
    d.quack();
}
// quack!
// quack!
// squawk!
#}</code></pre></pre>
<p>在这里,我们有两种完全不同的类型 (其中一个非常愚蠢,甚至没有数据) ,并且是的,它们都是<code>quacks()</code>.
其中一个有点奇怪 (对于鸭子) ,但他们共享相同的方法名称,Rust可以从类型安全的方式保存这些对象的集合.</p>
<p>类型安全是一件奇妙的事情. 没有静态类型,你可以插入一个 <em>猫</em> 进入这个Quackers集合,导致运行时混乱.</p>
<p>这是一个有趣的:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// and why the hell not!
impl Quack for i32 {
    fn quack(&amp;self) {
        for i in 0..*self {
            print!(&quot;quack {} &quot;,i);
        }
        println!(&quot;&quot;);
    }
}

let int = 4;

let ducks: Vec&lt;&amp;Quack&gt; = vec![&amp;duck1,&amp;duck2,&amp;parrot,&amp;int];
...
// quack!
// quack!
// squawk!
// quack 0 quack 1 quack 2 quack 3
#}</code></pre></pre>
<p>我能说什么? 它嘎嘎声叫,它一定是一只鸭子.
有趣的是,你可以将你的 trait 应用于任何 rust 值,而不仅仅是&quot;对象&quot;.
(以来<code>嘎嘎</code>通过引用,有明确的解除引用<code>*</code>得到整数. )</p>
<p>然而,你只能用同一个库的特质{trait} 和类型来做这件事,所以标准库不能'猴子补丁',这是另一块红宝石人的做法 (也不是最受人羡慕的) .</p>
<p>到目前为止,这个特质{trait} <code>嘎嘎</code>表现得非常像Java接口,并且像现代Java接口一样 <em>提供</em> 这个方法.如果你已经实现了,它将提供一个默认实现 <em>需要</em> 方法.  (该<code>迭代器</code>特质{trait} 就是一个很好的例子. )</p>
<p>但是,请注意特质{trait} 不属于 <em>定义类型</em> 和实施任何类型的新 trait ,但要受同一库限制.</p>
<p>可以将引用传递给任何人<code>嘎嘎</code>实施者:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn quack_ref (q: &amp;Quack) {
    q.quack();
}

quack_ref(&amp;d);
#}</code></pre></pre>
<p>这是分类,Rust风格.</p>
<p>由于我们在这里进行编程语言比较101,所以我会提到Go对这个嘎嘎的业务有一个有趣的看法 - 如果有一个Go接口<code>嘎嘎</code>,而一个类型有一个<code>嘎嘎</code>方法,那么类型就满足了<code>嘎嘎</code>而不需要明确的定义. `这也打破了定义好的Java模型,并且允许编译时鸭式输入,代价是一些清晰和类型安全. 但是鸭子打字有一个问题.</p>
<p>坏OOP的标志之一是, 太多的方法有一些通用名称<code>run</code>. <code>&quot;如果它已经有了 run(),它必须是可 run 的&quot;</code>,听起来不像原来那么容易! 所以Go接口可能会是 <em>偶然</em> 有效 在Rust,两者都是<code>Debug</code>和<code>Display</code>特质{trait} 定义<code>fmt</code>方法,但他们真的意味着不同的事情.</p>
<p>所以Rust的特质{trait} 允许传​​统 <em>多态</em> OOP. 但是遗传呢?人们通常是指 <em>实现继承{impl}</em> 而Rust则是 <em>接口继承</em>. 就好像一位Java程序员从未使用过<code>延伸{extend}</code>而是使用<code>实现{implements}</code>. 实际上,这是<a href="http://www.javaworld.com/article/2073649/core-java/why-extends-is-evil.html">推荐的做法</a>通过Alan Holub. 他说:</p>
<blockquote>
<p>我曾经参加过一个Java用户组会议,James Gosling (Java的发明人) 是这个会议的特色</p>
<p>扬声器. 在令人难忘的问答环节中,有人问他: &quot;如果你能再一次做Java,</p>
<p>你会改变什么?&quot;&quot;我会放弃 class ,&quot;他回答说,在笑声平息后,</p>
</blockquote>
<blockquote>
<p>他解释说,真正的问题不是类本身,而是实现继承{implementation inheritance}(扩展关系{extends relationship}) .</p>
</blockquote>
<blockquote>
<p>接口继承 (实现关系{the implements relationshup}) 是可取的.</p>
</blockquote>
<blockquote>
<p>尽可能避免实现继承{implementation inheritance}</p>
</blockquote>
<p>所以即使在Java中,你也可能过度使用类.</p>
<p>实现继承有一些严重的问题.</p>
<p>但它的确如此 <em>方便</em>. 有这个胖基类叫动物和它有很多有用的功能 (它甚至可能暴露它的内部!) ,我们的派生类<code>猫</code>可以使用. 也就是说,它是一种代码重用的形式.</p>
<p>但是代码重用是一个单独的问题. 理解Rust时,区分 实现 和 接口继承 很重要.</p>
<p>请注意, trait 可能有 <em>提供</em> 方法. 考虑<code>迭代器</code>- 你只 <em>需要</em> 重写<code>next</code>,但却免费获得大量的方法. 这与现代Java接口的&quot;default&quot;方法类似. 这里我们只定义<code>名称{name}</code>和<code>upper_case</code>是为我们定义的. 我们 也是 <em>可以</em> 覆盖<code>upper_case</code>,但事实并非如此 <em>需要</em>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Named {
    fn name(&amp;self) -&gt; String;

    fn upper_case(&amp;self) -&gt; String {
        self.name().to_uppercase()
    }
}

struct Boo();

impl Named for Boo {
    fn name(&amp;self) -&gt; String {
        &quot;boo&quot;.to_string()
    }
}

let f = Boo();

assert_eq!(f.name(),&quot;boo&quot;.to_string());
assert_eq!(f.upper_case(),&quot;BOO&quot;.to_string());
#}</code></pre></pre>
<p>这是一个 <em>类</em> 的代码重用,为真,但请注意,它不适用于数据,只有 接口!</p>
<a class="header" href="print.html#a鸭子和泛型" id="a鸭子和泛型"><h2>鸭子和泛型</h2></a>
<p>Rust中一个通用友好的鸭子函数的例子就是这样一个简单的例子:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn quack&lt;Q&gt; (q: &amp;Q)
where Q: Quack {
    q.quack();
}

let d = Duck();
quack(&amp;d);
#}</code></pre></pre>
<p>类型参数是 <em>任何</em> 实现的类型<code>嘎嘎{Quack}</code>. 之间有一个重要的区别<code>嘎嘎</code>和<code>quack_ref</code>在上一节中定义. 这个函数的 main 是编译的 <em>每个</em> 调用类型,并且不需要虚拟方法;这些功能可以完全内联. 它使用特质{trait} <code>嘎嘎</code>以不同的方式,作为一个 <em>约束{where}</em> 在泛型类型上.</p>
<p>这是相当于通用的C ++<code>嘎嘎</code> (注意<code>常量</code>) :</p>
<pre><code class="language-cpp">template &lt;class Q&gt;
void quack(const Q&amp; q) {
    q.quack();
}
</code></pre>
<p>请注意,类型参数不受任何限制.</p>
<p>这是非常多的编译时鸭式输入 - 如果我们将 非quackable 类型引用传递,那么编译器会抱怨 <code>不嘎嘎</code> 方法. 至少这个错误是在编译时发现的,但是当一个类型被意外Quackable时会更糟,就像Go一样. 更多涉及的模板函数和类导致可怕的错误消息,因为 <em>没有</em> 对泛型的限制. 你可以定义一个可以处理Quacker指针迭代的函数:</p>
<pre><code class="language-cpp">template &lt;class It&gt;
void quack_everyone (It start, It finish) {
    for (It i = start; i != finish; i++) {
        (*i)-&gt;quack();
    }
}
</code></pre>
<p>这将会被执行 <em>每个</em> 迭代器类型<code>It</code>. Rust的等价物有点更具挑战性:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn quack_everyone &lt;I&gt; (iter: I)
where I: Iterator&lt;Item=Box&lt;Quack&gt;&gt; {
    for d in iter {
        d.quack();
    }
}

let ducks: Vec&lt;Box&lt;Quack&gt;&gt; = vec![Box::new(duck1),Box::new(duck2),Box::new(parrot),Box::new(int)];

quack_everyone(ducks.into_iter());
#}</code></pre></pre>
<p>Rust中的迭代器不是鸭式的,但是必须是 impl <code>迭代器</code>的类型
,在这种情况下,迭代器提供了一些盒子<code>嘎嘎</code>. 所涉及的类型没有歧义,值必须满足<code>嘎嘎</code>. 通常,函数签名是关于通用Rust函数的最具挑战性的事情,这就是为什么我建议阅读标准库的源代码 - impl 通常比 声明 简单得多!</p>
<p>这里唯一的类型参数是实际的迭代器类型,这意味着这将适用于任何可以传递序列的任何东西<code>Box&lt;Duck&gt;</code>,而不仅仅是一个向量迭代器.</p>
<a class="header" href="print.html#a继承" id="a继承"><h2>继承</h2></a>
<p>面向对象设计的一个常见问题是试图将事情强加到一个 <em>是一个</em> 关系,而忽视 <em>有一个</em> 关系. <a href="https://en.wikipedia.org/wiki/Design_Patterns">该四人帮 </a>
二十二年前在他们的设计模式书中说过&quot;首选组合继承&quot;.</p>
<p>这里有一个例子: 你想模拟一些公司的员工,并且<code>雇员{Employee}</code>似乎是一个 class 的好名字.</p>
<p>然后,经理是一个员工 (这是真的) ,所以我们开始用一个构建我们的层次结构</p>
<p><code>雇员</code>的子类<code>经理{Manager}</code>. <code>这并不像看起来那么聪明. 也许我们对识别重要名词感到厌倦,也许我们 (无意识地) 认为经理和员工是不同种类的动物? 这更好的是雇员</code>有一个<code>角色</code>集合,然后一个经理就是一个<code>雇员</code>有更多的责任和能力.</p>
<p>或考虑车辆 - 从自行车到300吨矿车. 有多种方式可以考虑车辆,道路 (全地形,城市,铁路等) ,电源 (电力,柴油,柴油电力等) ,货物或人等等. 您根据一个方面创建的任何固定层次的类都会忽略所有其他方面. 也就是说,有多种可能的车辆分类!</p>
<p>构成在Rust中更为重要,原因很明显,您无法从基类以惰性方式继承功能.</p>
<p>组合也很重要,因为借用检查器足够聪明,可以知道借用不同的结构域是单独的借入.</p>
<p>你可以有一个字段的可变借入,同时拥有另一个字段的不可变借入,等等. Rust不能告诉一个方法只访问一个字段,所以为了方便实现,这些字段应该用自己的方法来构造.  (该 <em>外部</em> 结构的接口可以是任何你喜欢使用合适的 trait 的. )</p>
<p>&quot;拆分拆分{split borrowing}&quot;的一个具体例子会使这个更清晰.</p>
<p>我们拥有一个一些字符串的结构,并且有一个可变的借用第一个字符串的方法.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Foo {
    one: String,
    two: String
}

impl Foo {
    fn borrow_one_mut(&amp;mut self) -&gt; &amp;mut String {
        &amp;mut self.one
    }
    ....
}
#}</code></pre></pre>
<p>(这是Rust命名约定的一个例子 - 这些方法应该以<code>_mut</code>) `</p>
<p>现在,一种借用两个字符串的方法,重用第一种方法:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    fn borrow_both(&amp;self) -&gt; (&amp;str,&amp;str) {
        (self.borrow_one_mut(), &amp;self.two)
    }
#}</code></pre></pre>
<p>不行! 我们从可变的<code>self</code>和 <em>也</em> 从中 不可变 借用 <code>self</code>. 如果Rust允许这样的情况发生,那么无法保证 不可改变的引用 不会改变.</p>
<p>解决方案很简单:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    fn borrow_both(&amp;self) -&gt; (&amp;str,&amp;str) {
        (&amp;self.one, &amp;self.two)
    }
#}</code></pre></pre>
<p>这很好,因为借款检查员认为这些是独立的借款.</p>
<p>所以想象这些字段是一些任意的类型,你可以看到在这些字段上调用的方法, 不会导致借用问题. 有一种限制但非常重要的&quot;继承&quot;<a href="https://rust-lang.github.io/book/second-edition/ch15-02-deref.html">Deref</a>
这是'取消引用'操作符'*<code>的 trait 。</code>String<code>实现</code>Deref&lt;Target=str&gt;<code>，所以</code>＆str<code>上定义的所有方法都是自动的 也可用于</code>String<code>! 以类似的方式，</code>Foo<code>的方法可以直接 调用</code>Box<Foo>`。 有些人觉得这有点神奇，但它非常方便。
现代Rust中有一种更简单的语言，但使用起来并不令人愉快。
它确实应该用于那些拥有可变类型和更简单借用的情况
类型。</p>
<p>一般在Rust中有 <em>特质{trait} 继承</em>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Show {
    fn show(&amp;self) -&gt; String;
}

trait Location {
    fn location(&amp;self) -&gt; String;
}

trait ShowTell: Show + Location {}
#}</code></pre></pre>
<p>最后一个 trait 简单地将我们两个不同的 trait 合并为一个,尽管它可以指定其他方法.</p>
<p>现在的情况和以前一样:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug)]
struct Foo {
    name: String,
    location: String
}

impl Foo {
    fn new(name: &amp;str, location: &amp;str) -&gt; Foo {
        Foo{
            name: name.to_string(),
            location: location.to_string()
        }
    }
}

impl Show for Foo {
    fn show(&amp;self) -&gt; String {
        self.name.clone()
    }
}

impl Location for Foo {
    fn location(&amp;self) -&gt; String {
        self.location.clone()
    }
}

impl ShowTell for Foo {}
#}</code></pre></pre>
<p>现在,如果我有价值<code>foo</code>类型<code>Foo</code>,那么对该值的引用将会满足<code>&amp;Show</code>,<code>&amp;Location</code>要么<code>&amp;ShowTell</code> (这暗示着两者) .</p>
<p>这是一个有用的小宏:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
macro_rules! dbg {
    ($x:expr) =&gt; {
        println!(&quot;{} = {:?}&quot;,stringify!($x),$x);
    }
}
#}</code></pre></pre>
<p>它需要一个参数 (用<code>$x</code>表示) 必须是'表达'. 我们打印出它的价值,并且一个 <em>字符串化</em> 值的版本. C程序员可以是在这一点上 <em>小</em> 得意,但这意味着如果我通过了<code>1 + 2</code> (一个表达) <code>stringify!(1 + 2)</code>是文字字符串&quot;1 + 2&quot;. 这会为我们在玩代码时节省一些打字的时间:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let foo = Foo::new(&quot;Pete&quot;,&quot;bathroom&quot;);
dbg!(foo.show());
dbg!(foo.location());

let st: &amp;ShowTell = &amp;foo;

dbg!(st.show());
dbg!(st.location());

fn show_it_all(r: &amp;ShowTell) {
    dbg!(r.show());
    dbg!(r.location());
}

let boo = Foo::new(&quot;Alice&quot;,&quot;cupboard&quot;);
show_it_all(&amp;boo);

fn show(s: &amp;Show) {
    dbg!(s.show());
}

show(&amp;boo);

// foo.show() = &quot;Pete&quot;
// foo.location() = &quot;bathroom&quot;
// st.show() = &quot;Pete&quot;
// st.location() = &quot;bathroom&quot;
// r.show() = &quot;Alice&quot;
// r.location() = &quot;cupboard&quot;
// s.show() = &quot;Alice&quot;
#}</code></pre></pre>
<p>这个 <em>是</em> 面向对象,而不是你习惯的那种.</p>
<p>请注意<code>Show</code>引用传递给<code>show</code>, 不可能是 <em>动态</em> 升级为<code>ShowTell</code>! 具有更多动态类系统的语言允许您检查给定对象是否是类的实例, 然后对该类型执行动态转换. 一般来说这不是一个好主意,因为这个原因,特别是不能在Rust中工作, <code>Show</code>引用已经&quot;忘记&quot;它最初是一个<code>ShowTell</code>引用.</p>
<p>你总是有选择: 多态,通过特质{trait} 对象,或单态,通过泛型约束的特质{trait} . 现代C ++和Rust标准库倾向于采用通用路由,但多态路由并未过时. 您必须了解不同的权衡 - 泛型生成最快的代码,可以内联. 这可能会导致代码膨胀. 但并非所有事情都必须如此 <em>尽可能快</em>- 在典型的程序 run 的生命周期中,它可能只发生&quot;少&quot;几次.</p>
<p>所以,这里有一个总结:</p>
<ul>
<li><code>类</code>扮演的角色在数据和 trait 之间共享</li>
<li>结构和枚举是愚蠢的,虽然你可以定义方法和做数据隐藏</li>
<li>一个 <em>有限</em> 子类型的形式是可能的数据使用<code>Deref</code> trait</li>
<li>trait 没有任何数据,但可以实现任何类型 (不仅仅是结构)</li>
<li>trait 可以从其他 trait 继承</li>
<li>trait 可以提供方法,允许接口代码重用</li>
<li>trait 给你两个虚拟方法 (多态) 和通用约束 (单态)</li>
</ul>
<a class="header" href="print.html#a示例-windows-api" id="a示例-windows-api"><h2>示例: Windows API</h2></a>
<p>GUI工具包是传统OOP广泛使用的领域之一. 一个<code>EditControl</code>或者一个<code>ListWindow</code>是-一个<code>窗口{Window}</code>等等. 这使得编写Rust绑定到GUI工具包比编写它更困难.</p>
<p>Win32编程可以在Rust中完成<a href="https://www.codeproject.com/Tips/1053658/Win-GUI-Programming-In-Rust-Language">直接</a>,它比原来的C稍微笨拙一点. 当我从C到C ++毕业时,我想要更干净的东西,并且做了我自己的OOP包装. 典型的Win32 API函数是<a href="https://docs.rs/user32-sys/0.0.9/i686-pc-windows-gnu/user32_sys/fn.ShowWindow.html">ShowWindow</a>用于控制窗口的可见性. 现在,一个<code>EditControl</code>有一些专门的功能,但它都是用Win32完成的<code>HWND</code> ('handle to window') 不透明的值. 你想要<code>EditControl</code>也有一个<code>show</code>方法,传统上这将通过实现继承来完成. 您 <em>不</em> 想要为每种类型输出所有这些继承的方法!但Rust trait 提供了一个解决方案. 会有一个<code>窗口{Window}</code> trait :</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Window {
    // you need to define this!
    fn get_hwnd(&amp;self) -&gt; HWND;

    // and all these will be provided
    fn show(&amp;self, visible: bool) {
        unsafe {
         user32_sys::ShowWindow(self.get_hwnd(), if visible {1} else {0})
        }
    }

    // ..... oodles of methods operating on Windows

}
#}</code></pre></pre>
<p>所以,实现struct为<code>EditControl</code>可以包含一个<code>HWND</code>, 并通过定义一种方法执行<code>窗口{Window}</code>;<code>EditControl</code>是一种继承自的<code>窗口{Window}</code>特质{trait} 并定义扩展接口. 就像是<code>ComboxBox</code>- 其行为像一个<code>EditControl</code> <em>和</em> 一个<code>ListWindow</code>可以通过 trait 继承轻松实现.</p>
<p>Win32 API ('32'不再意味着'32位') 实际上是面向对象的,但是老式的,受 Alan Kay 定义的影响: 对象包含隐藏的数据,并且由 <em>消息{messages}</em> 控制. 因此,任何Windows应用程序的核心都有一个消息循环,各种窗口 (称为'窗口类') 都用它们自己的switch 语句实现这些方法. 有一个消息叫<code>WM_SETTEXT</code>但实现可能会有所不同: 标签的文本更改,但顶级窗口的标题更改.</p>
<p><a href="https://gabdube.github.io/native-windows-gui/book_20.html">这里</a>是一个相当有前途的最小Windows GUI框架. 但根据我的口味,有太多了<code>unwrap</code>实例正在发生 - 其中一些甚至没有错误.</p>
<p>这是因为 NWG 正在利用消息的松散动态性质. 通过适当的类型安全接口,编译时会捕获更多的错误.</p>
<p>在<a href="https://rust-lang.github.io/book/second-edition/ch17-00-oop.html">下一版</a>Rust编程语言手册 对Rust中 面向对象的含义 进行了很好的讨论.</p>
<a class="header" href="print.html#a用-nom-解析文本" id="a用-nom-解析文本"><h2>用 nom 解析文本</h2></a>
<p><a href="https://github.com/Geal/nom">nom</a>,<a href="https://docs.rs/nom"> (在这里记录) </a>是Rust的解析器库,它非常值得初次投资.</p>
<p>如果你必须解析一个已知的数据格式,比如CSV或者JSON,那么最好使用一个专门的类库<a href="https://github.com/BurntSushi/rust-csv">Rust CSV</a>或者讨论的JSON库<a href="4-modules.html#cargo">第4节</a>.</p>
<p>同样,对于配置文件使用专用的解析器<a href="https://docs.rs/rust-ini/0.10.0/ini/">ini</a>要么<a href="http://alexcrichton.com/toml-rs/toml/index.html">toml</a>.  (最后一个特别酷,因为它与Serde框架结合在一起,就像我们看到的一样<a href="https://docs.rs/serde_json">serde_json</a>.</p>
<p>但是如果文本不规则,或者某种格式化,那么你需要扫描那些文本而不写很多乏味的字符串处理代码. 建议的去往往是<a href="https://github.com/rust-lang/regex">正则表达式</a>,但充分参与时,正则表达式可能令人沮丧地不透明. nom 提供了一种解析文本的方法,它可以通过组合更简单的解析器来构建. 例如,正则表达式有其局限性<a href="http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags">使用正则表达式来解析HTML</a>但是你 <em>可以</em> 使用nom解析HTML. 如果你有兴趣编写自己的编程语言,nom是一个很好的地方,你可以从这条艰难的道路开始.</p>
<p>有一些用于学习nom的优秀教程,但我想从 hello-world 级开始建立一些初步的熟悉性. 您需要了解的基本知识 - 首先,nom一直是宏,其次,nom倾向于使用 slices ,而不是字符串. 首先意味着你必须特别小心才能获得nom表达式,因为错误信息不会很友善. 第二种意思是nom可以用于 <em>任何</em> 数据格式,而不仅仅是文本. 人们使用nom解码二进制协议和文件头. 它也可以在UTF-8以外的编码中使用&quot;文本&quot;.</p>
<p>nom的最新版本与字符串切片一起工作良好,但您需要使用以其结尾的宏<code>_s</code>.</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate nom;

named!(get_greeting&lt;&amp;str,&amp;str&gt;,
    tag_s!(&quot;hi&quot;)
);

fn main() {
    let res = get_greeting(&quot;hi there&quot;);
    println!(&quot;{:?}&quot;,res);
}
// Done(&quot; there&quot;, &quot;hi&quot;)
</code></pre></pre>
<p>该<code>named!</code>宏创建一些输入类型的函数 (<code>&amp;[u8]</code>默认情况下) 并将第二个类型返回到尖括号中. <code>tag_s!</code>匹配字符流中的文字字符串,其值是表示该文字的字符串片段.  (如果你想与之合作<code>&amp;[u8]</code>然后使用<code>tag!</code>宏) .</p>
<p>我们称之为定义的解析器<code>get_greeting</code>与<code>&amp;str</code>并找回一个<a href="http://rust.unhandledexpression.com/Nom/enum.IResult.html">IResult</a>事实上,我们恢复了匹配值. 看看&quot; there&quot; - 这是匹配后剩下的字符串切片.</p>
<p>我们想忽略空白.</p>
<p>通过只是包装的<code>tag!</code>在<code>ws!</code>我们可以在空格,制表符或换行符的任何位置匹配&quot;hi&quot;:</p>
<pre><pre class="playpen"><code class="language-rust">named!(get_greeting&lt;&amp;str,&amp;str&gt;,
    ws!(tag_s!(&quot;hi&quot;))
);

fn main() {
    let res = get_greeting(&quot;hi there&quot;);
    println!(&quot;{:?}&quot;,res);
}
// Done(&quot;there&quot;, &quot;hi&quot;)
</code></pre></pre>
<p>结果就像之前的&quot;hi&quot;,剩下的字符串是&quot;there&quot;! 空格已被跳过.</p>
<p>&quot;hi&quot;很好地匹配,尽管这还不是很有用.</p>
<p>让我们匹配或&quot;hi&quot;或&quot;bye&quot;. 该<code>alt!</code>宏 (&quot;备用&quot;) 采用分隔符表达式分隔<code>|</code>并匹配 <em>任何</em> 其中. 请注意,您可以在这里使用空格来使解析器函数更易于阅读:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
named!(get_greeting&lt;&amp;str&gt;,
    ws!(alt!(tag_s!(&quot;hi&quot;) | tag_s!(&quot;bye&quot;)))
);
println!(&quot;{:?}&quot;, get_greeting(&quot; hi &quot;));
println!(&quot;{:?}&quot;, get_greeting(&quot; bye &quot;));
println!(&quot;{:?}&quot;, get_greeting(&quot;  hola &quot;));
// Done(&quot;&quot;, &quot;hi&quot;)
// Done(&quot;&quot;, &quot;bye&quot;)
// Error(Alt)
#}</code></pre></pre>
<p>最后一场比赛失败了,因为没有其他选择匹配&quot;hola&quot;.</p>
<p>显然我们需要了解<code>IResult</code>类型多点,但首先让我们比较这与正则表达式的解决方案:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let greetings = Regex::new(r&quot;\s*(hi|bye)\s*&quot;).expect(&quot;bad regex&quot;);
    let caps = greetings.captures(&quot; hi &quot;).expect(&quot;match failed&quot;);
    println!(&quot;{:?}&quot;,caps);
// Captures({0: Some(&quot; hi &quot;), 1: Some(&quot;hi&quot;)})
#}</code></pre></pre>
<p>正则表达式肯定更多 <em>紧凑{compact}</em>!我们需要将'()'放在由'|'分隔的两种可能性中, 所以我们会 <em>捕获</em> greeting 或者没有. 第一个结果是整个字符串,第二个是匹配的捕获. ('|'是正则表达式中的所谓'交替{alternation}'操作符,这是该动机的动机<code>alt!</code>宏语法. )</p>
<p>但这是一个非常简单的正则表达式,它们很快就会变得复杂. 作为一种文字迷你语言,你必须逃避重要的人物如<code>*</code>和<code>(</code>. 如果我想匹配&quot;(hi)&quot;或&quot;(bye)&quot;,则正则表达式变为 <code>\s*\((hi|bye)\)\s*</code> 但是nom解析器只是变成了<code>alt!(tag_s!(&quot;(hi)&quot;) | tag_s!(&quot;(bye)&quot;))</code>.</p>
<p>这也是一个重量级的依赖. 在这款相当微弱的i5笔记本电脑上,nom的例子大约需要0.55秒的时间进行编译,这并不比&quot;Hello world&quot;多得多. 但正则表达式的例子大约需要0.90s. nom示例的剥离版本生成可执行文件约为0.3Mb (与静态链接的Rust程序一样小) ,而正则表达式为0.8Mb.</p>
<a class="header" href="print.html#a一个nom解析器返回" id="a一个nom解析器返回"><h2>一个nom解析器返回</h2></a>
<p><a href="http://rust.unhandledexpression.com/nom/enum.IResult.html">IResult</a>与标准有一个有趣的区别<code>Result</code>类型 - 有三种可能性:</p>
<ul>
<li><code>Done</code>- 成功 - 您将得到结果和剩余的字节</li>
<li><code>Error</code>- 未能解析 - 你得到一个错误</li>
<li><code>不完全{Imcomplete}</code>- 需要更多数据</li>
</ul>
<p>我们可以写一个通用的<code>dump</code>函数处理可以调试打印的任何返回值. 这也说明了<code>to_result</code>方法返回一个常规<code>Result</code>- 这可能是您将用于大多数情况的方法,因为它返回 返回值或错误.</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate nom;
use nom::IResult;
use std::str::from_utf8;
use std::fmt::Debug;

fn dump&lt;T: Debug&gt;(res: IResult&lt;&amp;str,T&gt;) {
    match res {
      IResult::Done(rest, value) =&gt; {println!(&quot;Done {:?} {:?}&quot;,rest,value)},
      IResult::Error(err) =&gt; {println!(&quot;Err {:?}&quot;,err)},
      IResult::Incomplete(needed) =&gt; {println!(&quot;Needed {:?}&quot;,needed)}
    }
}


fn main() {
    named!(get_greeting&lt;&amp;str,&amp;str&gt;,
        ws!(
            alt!( tag_s!(&quot;hi&quot;) | tag_s!(&quot;bye&quot;))
        )
    );

    dump(get_greeting(&quot; hi &quot;));
    dump(get_greeting(&quot; bye hi&quot;));
    dump(get_greeting(&quot;  hola &quot;));

    println!(&quot;result {:?}&quot;, get_greeting(&quot; bye  &quot;).to_result());
}
// Done Ok(&quot;&quot;) &quot;hi&quot;
// Done Ok(&quot;hi&quot;) &quot;bye&quot;
// Err Alt
// result Ok(&quot;bye&quot;)
</code></pre></pre>
<p>解析器返回任何未解析的文本,并且能够指示它们没有足够的输入字符来决定,对于 流{stream} 解析非常有用. 但通常<code>to_result</code>是你的朋友.</p>
<a class="header" href="print.html#a合并解析器" id="a合并解析器"><h2>合并解析器</h2></a>
<p>让我们继续问候示例,并设想问候语包含&quot;hi&quot;或&quot;bye&quot;,再加上一个名字. <code>Nom::alpha</code>匹配一系列字母字符. 该<code>pair!</code>宏将收集匹配两个解析器作为元组的结果:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    named!(full_greeting&lt;&amp;str,(&amp;str,&amp;str)&gt;,
        pair!(
            get_greeting,
            nom::alpha
        )
    );

    println!(&quot;result {:?}&quot;, full_greeting(&quot; hi Bob  &quot;).to_result());
// result Ok((&quot;hi&quot;, &quot;Bob&quot;))
#}</code></pre></pre>
<p>现在,进一步想象 greeter 会有点害羞或不知道任何人的名字: 让我们使名字可选. 自然而然,元组的第二个值变成了<code>Option</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    named!(full_greeting&lt;&amp;str, (&amp;str,Option&lt;&amp;str&gt;)&gt;,
        pair!(
            get_greeting,
            opt!(nom::alpha)
        )
    );

    println!(&quot;result {:?}&quot;, full_greeting(&quot; hi Bob  &quot;).to_result());
    println!(&quot;result {:?}&quot;, full_greeting(&quot; bye ?&quot;).to_result());
// result Ok((&quot;hi&quot;, Some(&quot;Bob&quot;)))
// result Ok((&quot;bye&quot;, None))
#}</code></pre></pre>
<p>请注意,将现有的问候语解析器与分析器合并起来很简单,然后很容易使该名称成为可选项. 这是nom的强大力量,这也是它被称为&quot;解析器组合库&quot;的原因. 您可以从更简单的解析器构建复杂的解析器,您可以单独测试它们.  (在这一点上,等价的正则表达式开始看起来像一个Perl程序: 正则表达式不能很好地结合. )</p>
<p>但是,我们还没有回家并且干燥!<code>full_greeting(&quot; bye&quot;)</code>将会失败<code>不完全</code>错误. nom知 道&quot;bye&quot;后面可能会有一个名字,并希望我们给它更多的数据. 这是怎么一个 <em>流</em> 解析器需要工作,所以你可以按块填充文件块,但是在这里我们需要告诉nom输入已完成.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    named!(full_greeting&lt;&amp;str,(&amp;str,Option&lt;&amp;str&gt;)&gt;,
        pair!(
            get_greeting,
            opt!(complete!(nom::alpha))
        )
    );

    println!(&quot;result {:?}&quot;, full_greeting(&quot; bye &quot;).to_result());
// result Ok((&quot;bye&quot;, None))
#}</code></pre></pre>
<a class="header" href="print.html#a分析数字" id="a分析数字"><h2>分析数字</h2></a>
<p>nom提供了一个功能<code>数字{digit}</code>它与一系列数字相匹配. 所以我们使用<code>map!</code>,将字符串转换为整数,并返回完整的<code>Result</code>类型.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use nom::digit;
use std::str::FromStr;
use std::num::ParseIntError;

named!(int8 &lt;&amp;str, Result&lt;i8,ParseIntError&gt;&gt;,
    map!(digit, FromStr::from_str)
);

named!(int32 &lt;&amp;str, Result&lt;i32,ParseIntError&gt;&gt;,
    map!(digit, FromStr::from_str)
);

println!(&quot;{:?}&quot;, int8(&quot;120&quot;));
println!(&quot;{:?}&quot;, int8(&quot;1200&quot;));
println!(&quot;{:?}&quot;, int8(&quot;x120&quot;));
println!(&quot;{:?}&quot;, int32(&quot;1202&quot;));

// Done(&quot;&quot;, Ok(120))
// Done(&quot;&quot;, Err(ParseIntError { kind: Overflow }))
// Error(Digit)
// Done(&quot;&quot;, Ok(1202))
#}</code></pre></pre>
<p>所以我们得到的是一个解析器<code>IResult</code>包含转换<code>Result</code>- 当然,在这里失败的方式不止一种. 请注意,我们的转换函数的主体具有完全相同的代码;实际转换取决于函数的返回类型.</p>
<p>整数可能有一个标志. 我们可以将整数作为一对来捕获,其中第一个值可能是一个符号,第二个值可能是后面的任何数字.</p>
<p>考虑:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
named!(signed_digits&lt;&amp;str, (Option&lt;&amp;str&gt;,&amp;str)&gt;,
    pair!(
        opt!(alt!(tag_s!(&quot;+&quot;) | tag_s!(&quot;-&quot;))),  // maybe sign?
        digit
    )
);

println!(&quot;signed {:?}&quot;, signed_digits(&quot;4&quot;));
println!(&quot;signed {:?}&quot;, signed_digits(&quot;+12&quot;));
// signed Done(&quot;&quot;, (None, &quot;4&quot;))
// signed Done(&quot;&quot;, (Some(&quot;+&quot;), &quot;12&quot;))
#}</code></pre></pre>
<p>当我们对中间结果不感兴趣时​​,只需要所有的匹配输入<code>recognize!</code>是你需要的.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
named!(maybe_signed_digits&lt;&amp;str,&amp;str&gt;,
    recognize!(signed_digits)
);

println!(&quot;signed {:?}&quot;, maybe_signed_digits(&quot;+12&quot;));
// signed Done(&quot;&quot;, &quot;+12&quot;)
#}</code></pre></pre>
<p>使用这种技术,我们可以识别浮点数. 我们再次映射到所有这些匹配的字节片的字符串片. <code>tuple!</code>是泛化的<code>pair!</code>,尽管我们对这里生成的元组不感兴趣. <code>complete!</code>是需要解决我们与不完整的问候时使用的相同问题 - &quot;12&quot;是没有可选浮点部分的有效数字.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
named!(floating_point&lt;&amp;str,&amp;str&gt;,
    recognize!(
        tuple!(
            maybe_signed_digits,
            opt!(complete!(pair!(
                tag_s!(&quot;.&quot;),
                digit
            ))),
            opt!(complete!(pair!(
                alt!(tag_s!(&quot;e&quot;) | tag_s!(&quot;E&quot;)),
                maybe_signed_digits
            )))
        )
    )
);
#}</code></pre></pre>
<p>通过定义一个小助手宏,我们得到了一些通过测试. 如果测试通过<code>floating_point</code>匹配它给出的所有字符串.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
macro_rules! nom_eq {
    ($p:expr,$e:expr) =&gt; (
        assert_eq!($p($e).to_result().unwrap(), $e)
    )
}

nom_eq!(floating_point, &quot;+2343&quot;);
nom_eq!(floating_point, &quot;-2343&quot;);
nom_eq!(floating_point, &quot;2343&quot;);
nom_eq!(floating_point, &quot;2343.23&quot;);
nom_eq!(floating_point, &quot;2e20&quot;);
nom_eq!(floating_point, &quot;2.0e-6&quot;);
#}</code></pre></pre>
<p>(虽然有时候宏感觉到一点 <em>小</em> 肮脏,让你的测试很漂亮是件好事. ) 然后我们可以解析和转换浮点数.</p>
<p>在这里,我会告诫大家,并抛弃错误: 请注意,如何逐步构建复杂的解析器,并首先单独测试每个部分.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    named!(float64&lt;f64&gt;,
        map_res!(floating_point, FromStr::from_str)
    );
#}</code></pre></pre>
<p>这是解析器组合器对正则表达式的强大优势. 这是分而治之的经典编程策略. 通过</p>
<a class="header" href="print.html#a多个匹配进行操作" id="a多个匹配进行操作"><h2>多个匹配进行操作</h2></a>
<p>我们见面了<code>pairs!</code>和<code>tuple!</code>它将固定数量的匹配捕获为Rust元组.</p>
<p>还有<code>many0</code>和<code>many1</code>- 他们都捕获无限数量的匹配作为向量. 不同的是,第一个可能会捕获&quot;零或多个&quot;,第二个&quot;一个或多个&quot; (如正则表达式之间的差异<code>*</code>与<code>+</code>) 所以<code>many1!(ws!(float64))</code>会解析&quot;1 2 3&quot;<code>vec![1.0,2.0,3.0]</code>,但会在空字符串上失败.</p>
<p><code>fold_many0</code>是一个 <em>减少{reducing}</em> 操作. 使用二元运算符将匹配值组合为单个值. 例如,这就是 Rust人 以前如何对迭代器进行求和<code>sum</code>加入;这个折叠从一个初始值 (这里是零) 开始 <em>累加器</em> 并保持使用<code>+</code>该累加器的值.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let res = [1,2,3].iter().fold(0,|acc,v| acc + v);
    println!(&quot;{}&quot;,res);
    // 6
#}</code></pre></pre>
<p>以下是nom等价物:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    named!(fold_sum&lt;&amp;str,f64&gt;,
        fold_many1!(
            ws!(float64),
            0.0,
            |acc, v| acc + v
        )
    );

    println!(&quot;fold {}&quot;, fold_sum(&quot;1 2 3&quot;).to_result().unwrap());
    //fold 6
#}</code></pre></pre>
<p>到目前为止,我们必须捕获每个表达式,或者只是抓住所有匹配的字节<code>recognize!</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    named!(pointf&lt;(f64,&amp;[u8],f64)&gt;,
        tuple!(
            float64,
            tag_s!(&quot;,&quot;),
            float64
        )
    );

    println!(&quot;got {:?}&quot;, nom_res!(pointf,&quot;20,52.2&quot;).unwrap());
 //got (20, &quot;,&quot;, 52.2)
#}</code></pre></pre>
<p>对于更复杂的表达式,捕获所有解析器的结果会导致相当不整洁的类型!我们可以做得更好.</p>
<p><code>do_parse!</code>让你只提取你感兴趣的值<code>&gt;&gt;</code>- 感兴趣的匹配是形式<code>名称:解析器{name:parser}</code>. `最后,在圆括号中有一个代码块.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    #[derive(Debug)]
    struct Point {
        x: f64,
        y: f64
    }

    named!(pointf&lt;Point&gt;,
        do_parse!(
            first: float64 &gt;&gt;
            tag_s!(&quot;,&quot;) &gt;&gt;
            second: float64
            &gt;&gt;
            (Point{x: first, y: second})
        )
    );

    println!(&quot;got {:?}&quot;, nom_res!(pointf,&quot;20,52.2&quot;).unwrap());
// got Point { x: 20, y: 52.2 }
#}</code></pre></pre>
<p>我们对该标签的值不感兴趣 (它只能是逗号) ,但我们将两个浮点值分配给用于构建结构的临时值.</p>
<p>最后的代码可以是任何Rust表达式.</p>
<a class="header" href="print.html#a解析算术表达式" id="a解析算术表达式"><h2>解析算术表达式</h2></a>
<p>随着必要的背景建立,我们可以做简单的算术表达式.</p>
<p>这是真正无法用正则表达式完成的一个很好的例子.</p>
<p>这个想法是从下往上建立表达式.</p>
<p>表达式由 <em>条款{terms}</em> 组成,这是增加或减少. 术语由 <em>因素{factors}</em> 组成，它们相乘或分开。 和（现在）因素只是浮点数字：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    named!(factor&lt;f64&gt;,
        ws!(float64)
    );

    named!(term&lt;&amp;str,f64&gt;, do_parse!(
        init: factor &gt;&gt;
        res: fold_many0!(
            tuple!(
                alt!(tag_s!(&quot;*&quot;) | tag_s!(&quot;/&quot;)),
                factor
            ),
            init,
            |acc, v:(_,f64)| {
                if v.0 == &quot;*&quot; {acc * v.1} else {acc / v.1}
            }
        )
        &gt;&gt; (res)
    ));

    named!(expr&lt;&amp;str,f64&gt;, do_parse!(
        init: term &gt;&gt;
        res: fold_many0!(
            tuple!(
                alt!(tag_s!(&quot;+&quot;) | tag_s!(&quot;-&quot;)),
                term
            ),
            init,
            |acc, v:(_,f64)| {
                if v.0 == &quot;+&quot; {acc + v.1} else {acc - v.1}
            }
        )
        &gt;&gt; (res)
    ));
#}</code></pre></pre>
<p>这更准确地表达了我们的定义 - 一个表达式至少包含一个术语,然后包含零个或多个正-负项.</p>
<p>我们不收集它们,但是 <em>折叠{fold}</em> 他们使用适当的操作员. (这是Rust不能很好地处理表达式类型的情况之一,所以我们需要一个类型提示. ) 这样做会建立正确的 <em>运算符优先级</em> -<code>*</code>总是赢<code>+</code>等等.</p>
<p>我们在这里需要浮点断言,并且<a href="http://brendanzab.github.io/approx/approx/index.html">有一个库</a>.</p>
<p>将<code>approx =&quot;0.1.1&quot;</code>行添加到您的Cargo.toml中,然后离开:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[macro_use]
extern crate approx;
...
    assert_relative_eq!(fold_sum(&quot;1 2 3&quot;).to_result().unwrap(), 6.0);
#}</code></pre></pre>
<p>我们来定义一个方便的小测试宏. <code>stringify!</code>将表达式转换为我们可以输入的字符串文字<code>expr</code>, 然后将结果与Rust如何评估结果进行比较.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    macro_rules! expr_eq {
        ($e:expr) =&gt; (assert_relative_eq!(
            expr(stringify!($e).to_result().unwrap(),
            $e)
        )
    }

    expr_eq!(2.3);
    expr_eq!(2.0 + 3.0 - 4.0);
    expr_eq!(2.0*3.0 - 4.0);
#}</code></pre></pre>
<p>这非常酷 - 只需几行即可获得 表达式评估器!但它变得更好. 我们增加了一个数字的替代方案<code>因子{factor}</code>解析器 - 包含在括号内的表达式:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    named!(factor&lt;&amp;str,f64&gt;,
        alt!(
            ws!(float64) |
            ws!(delimited!( tag_s!(&quot;(&quot;), expr, tag_s!(&quot;)&quot;) ))
        )
    );

    expr_eq!(2.2*(1.1 + 4.5)/3.4);
    expr_eq!((1.0 + 2.0)*(3.0 + 4.0*(5.0 + 6.0)));
#}</code></pre></pre>
<p>凉爽的是现在定义了表达式 <em>递归</em> 在表达方面!</p>
<p>特别的魔力<code>delimited!</code>是括号可以嵌套 -  nom确保括号匹配.</p>
<p>我们现在已经超越了正则表达式的能力,0.5Mb的被剥离可执行文件仍然是&quot;hello world&quot;正则表达式程序的一半.</p>
<a class="header" href="print.html#a痛点" id="a痛点"><h2>痛点</h2></a>
<p>可以说 Rust 是一门比大多数&quot;主流&quot;语言更难学的语言. 有特殊的人不觉得这么难,但要注意'特殊'的严格意义 - 他们是 <em>例外</em>. 一开始许多人挣扎,后成功. 最初的困难是不能预测后来的!</p>
<p>我们都来自某个地方,在编程语言的情况下,这意味着以前主流语言的遗留,如Python之类的&quot;动态&quot;语言 或 C ++之类的&quot;静态&quot;语言之一. 无论哪种方式, Rust 都有很大的不同,需要转变思路. 有经验的聪明人 加入进来,对他们的聪明不立即获得回报感到失望;自我 值 较低的人 认为自己不够&quot;聪明&quot;.</p>
<p>对于那些具有动态语言经验的人 (我将包括Java) ,所有内容都是 <code>引用&amp;</code>,并且所有引用默认都是可变的. 和垃圾收集 <em>会</em> 使编写内存安全的程序更容易. 以内存使用和可预测性为代价,JVM进展非常迅速. 通常这种成本被认为是值得的 - 旧的新想法认为程序员的生产力 比 计算机的性能更重要.</p>
<p>但是世界上大多数电脑 - 处理汽车阀门控制 等真正重要的事情 - 并不具备便宜笔记本电脑所拥有的大量资源,而且他们需要 <em>即时的</em> 响应. 同样,基础软件基础架构需要 正确,稳健和快速 (旧的工程三位一体) . 这大部分都是在本质上是不安全的 C和C ++ 中完成的,这个不安全的东西的 <em>总成本</em> 是在这里看的东西. 也许你更快地组合项目,但是 <em>之后</em> 真正的开发才开始.</p>
<p>系统语言无法承担垃圾回收,因为它们是所有东西都依赖的基础. 只要你认为合适,他们让你可以自由地浪费资源.</p>
<p>如果没有垃圾回收,则内存必须以其他方式进行管理. <em>手动内存管理</em> - 我抓住内存,使用它,并明确地将其退回 - 很难找到正确的内容. 您可以在几周内学会足够的C语言以提高工作效率和危险性 - 但要成为一名安全的C语言程序员需要花费数年时间,并检查每种可能的错误情况.</p>
<p>Rust 像现代C ++一样管理内存 - 随着对象被破坏,内存被回收. 你可以在堆上分配内存<code>Box</code>,但只要该函数在函数结束,'超出范围'时,内存就会被回收. 所以有像<code>new{新建}</code>这样的事情但没有<code>删除{delete}</code>. 你可以创建一个<code>File</code>,和在最后文件控制 (一个宝贵的资源) 被闭包. 在 Rust 中,这被称为 <em>扔掉{dropping}</em>.</p>
<p>你需要共享资源 - 复制一切都是非常低效的 - 这就是事情变得有趣的地方. C ++也有引用,尽管 Rust 引用更像C指针 - 你需要使用<code>*r</code>才能用  值 {value} ,你需要说<code>&amp;</code>一个值作为引用传递.</p>
<p>Rust 的 <em>借用检查器</em> 确保在原始值被销毁后引用不可能存在.</p>
<a class="header" href="print.html#a类型推断" id="a类型推断"><h2>类型推断</h2></a>
<p>&quot;静态&quot;和&quot;动态&quot;之间的区别不是一切. 与大多数事情一样,还有更多维度在发挥. C 是静态类型的 (每个变量在编译时都有一个类型) ,但是类型很弱 (例如,<code>void*</code>可以指向 <em>任何{anything}</em>) ;Python是动态类型的 (类型在值中,而不是变量) ,但却是强类型的. Java是静态/非常强类型的 (反射「reflection」 就像 方便/危险的逃逸阀) , Rust 是静态/强类型的,没有运行时反射.</p>
<p>Java因需要在麻木的细节中 <em>键入</em> 所有的类型而出名, Rust 喜欢 <em>推断</em> 类型. 这通常是一个好主意,但这确实意味着你有时需要计算出实际类型. 你会看见<code>let n = 100</code>并想知道 - 这是什么样的整数? 默认情况下,它会是<code>i32</code>- 一个四字节有符号整数. 现在大家都同意 C 的未指定整数类型 (比如<code>int</code>和<code>long</code>) 是一个坏主意; 最好是明确的. 你可以随时拼出类型,如<code>let n: u32 = 100</code>或者让文字强制类型,如<code>let n = 100u32</code>. 但是类型推断比这更进一步! 如果你声明<code>let n = 100</code>然后全部<code>rustc</code>知道这一点<code>n</code>一定是 <em>一些</em> 整数类型. 如果你然后通过<code>n</code>到一个期望一个<code>u64</code>函数, 那么这一定是这种类型的<code>n</code>!</p>
<p>之后,你尝试给<code>n</code>到期望<code>u32</code>函数. <code>rustc</code>不会让你这样做,因为<code>n</code>已被束缚到<code>u64</code>和它 <em>将不会</em> 采取简单的方法为您转换该整数. 这是强有力的类型行动 - 没有任何一点转换和促销活动让你的生活更流畅,直到整数溢出突然咬住你的屁股. 你必须明确地通过<code>n</code>如<code>n as u32</code>- 一个 Rust 类型. 幸好,<code>rustc</code>善于以&quot;可行&quot;的方式打破坏消息 - 也就是说,您可以按照编译器的意见来解决问题.</p>
<p>所以, Rust 代码可以非常明确的类型:</p>
<pre><code class="language-Rust">let mut v = Vec::new();
// v is deduced to have type Vec&lt;i32&gt;
v.push(10);
v.push(20);
v.push(&quot;hello&quot;) &lt;--- just can't do this, man!
</code></pre>
<p>不能将字符串放入整数 Vec 是一个功能,而不是一个错误. 动态类型的灵活性也是一个诅咒.</p>
<p>(如果你将需要 <em>把</em> 整数和字符串放入同一个 Vec ,那么 Rust <code>枚举</code>类型是安全地使用它的方法. )</p>
<p>有时你需要至少给一个类型 <em>暗示</em>. <code>collect</code>是一个梦幻般的迭代器方法,但它需要一个提示. 说我有一个迭代器返回<code>char</code>. 然后<code>collect</code>可以摆动两种方式:</p>
<pre><code class="language-Rust">// a vector of char ['h','e','l','l','o']
let v: Vec&lt;_&gt; = &quot;hello&quot;.chars().collect();
// a string &quot;doy&quot;
let m: String = &quot;dolly&quot;.chars().filter(|&amp;c| c != 'l').collect();
</code></pre>
<p>当对某个变量的类型感到不确定时,总会有这种技巧,<code>rustc</code>这种力量在错误消息中显示实际类型名称:</p>
<pre><code class="language-Rust">let x: () = var;
</code></pre>
<p><code>rustc</code>可能会选择特定类型. 这里我们想把不同的引用放入一个 Vec 但需要使用<code>&amp;Debug</code>明确声明类型.</p>
<pre><code class="language-Rust">use std::fmt::Debug;

let answer = 42;
let message = &quot;hello&quot;;
let float = 2.7212;

let display: Vec&lt;&amp;Debug&gt; = vec![&amp;message, &amp;answer, &amp;float];

for d in display {
    println!(&quot;got {:?}&quot;, d);
}
</code></pre>
<a class="header" href="print.html#a可变引用" id="a可变引用"><h2>可变引用</h2></a>
<p>规则是: 一次只有一个可变引用. 原因在于追踪 <em>到处都是</em> 可变性很难. 在小笨蛋程序中不明显,但在大型代码库中可能会变得糟糕.</p>
<p>进一步的限制是,当有可变引用出现时,你不能拥有不可变引用. 否则,任何有这些引用的人都不能保证他们不会改变. C ++也有不可变的引用 (例如<code>const string&amp;</code>) 但是 <em>不能</em> 给你这个保证,是因为有人不能保留一个<code>string&amp;</code>引用并在背后修改它.</p>
<p>如果您习惯于每个引用都是可变的语言,这是一个挑战! 不安全的&quot;放松&quot;语言取决于人们了解他们自己的计划并高高兴兴地决定不做坏事. 但是大型项目是由不止一个人编写的,并且超出了单个人详细理解的能力.</p>
<p>该 <em>刺激性</em> 事情是,借用检查器并不像它那样聪明.</p>
<pre><code class="language-Rust">let mut m = HashMap::new();
m.insert(&quot;one&quot;, 1);
m.insert(&quot;two&quot;, 2);

if let Some(r) = m.get_mut(&quot;one&quot;) { // &lt;-- mutable borrow of m
    *r = 10;
} else {
    m.insert(&quot;one&quot;, 1); // can't borrow mutably again!
}
</code></pre>
<p>显然这不是 <em>真的</em> 违反规则,除非如果我们得到了<code>None</code>,而实际上并没有从 map 上借用任何东西.</p>
<p>有各种丑陋的解决方法:</p>
<pre><code class="language-Rust">let mut found = false;
if let Some(r) = m.get_mut(&quot;one&quot;) {
    *r = 10;
    found = true;
}
if ! found {
    m.insert(&quot;one&quot;, 1);
}
</code></pre>
<p>这很糟糕,但它起作用,因为令人烦恼的借用保留在第一个if语句中.</p>
<p>这里更好的方法是使用<code>HashMap</code>[Entry API](https://doc. Rust -lang.org/std/collections/hash_map/enum.Entry.html).</p>
<pre><code class="language-Rust">use std::collections::hash_map::Entry;

match m.entry(&quot;one&quot;) {
    Entry::Occupied(e) =&gt; {
        *e.into_mut() = 10;
    },
    Entry::Vacant(e) =&gt; {
        e.insert(1);
    }
};
</code></pre>
<p>当 <em>非词汇生命周期</em> 今年某个时候到达, 借用检查器获得更少的挫败感.</p>
<p>借用检查器 <em>还是</em> 了解一些重要的案例,然而. 如果你有一个结构,字段可以独立借用. 所以构造是你的朋友;一个大结构体应该包含更小的结构体,它们有自己的方法. 当你不能修改内容就定义大结构体上的所有可变方法的情况,即使这些方法可能只涉及一个字段.</p>
<p>对于可变数据,有一些独立处理数据部分的特殊方法. 例如,如果你有一个可变切片,那么<code>split_at_mut</code>将它分成两个可变切片. 这是完全安全的,因为 Rust 知道切片不重叠.</p>
<a class="header" href="print.html#a引用和生命时间" id="a引用和生命时间"><h2>引用和生命时间</h2></a>
<p>Rust 不能允许一个引用超过 值 的情况. 否则,我们会有一个&quot;悬挂引用&quot;,它指的是一个死亡值 - 一个段错误是不可避免的.</p>
<p><code>rustc</code>往往可以对函数的生命周期做出合理的假设:</p>
<pre><code class="language-Rust">fn pair(s: &amp;str, ch: char) -&gt; (&amp;str, &amp;str) {
    if let Some(idx) = s.find(ch) {
        (&amp;s[0..idx], &amp;s[idx+1..])
    } else {
        (s, &quot;&quot;)
    }
}
fn main() {
    let p = pair(&quot;hello:dolly&quot;, ':');
    println!(&quot;{:?}&quot;, p);
}
// (&quot;hello&quot;, &quot;dolly&quot;)
</code></pre>
<p>这是非常安全的,因为我们处理了未找到分隔符的情况. <code>rustc</code>在这里假定元组中的两个字符串都是从作为参数传递给函数的字符串中借用的.</p>
<p>明确地说,函数定义如下所示:</p>
<pre><code class="language-Rust">fn pair&lt;'a&gt;(s: &amp;'a str, ch: char) -&gt; (&amp;'a str, &amp;'a str) {...}
</code></pre>
<p>符号表示输出字符串存在 <em>至少与输入字符串一样长</em> . 这并不是说生命是一样的,我们可以在任何时候放弃它们,只是因为它们无法离开<code>s</code>.</p>
<p>所以,<code>rustc</code>使常见案例更漂亮 <em>生命豁免</em>.</p>
<p>现在,如果收到该函数 <em>两个</em> 字符串,那么您需要明确地进行生命周期注释来告诉 Rust 哪个输出字符串是从哪个输入字符串中借用的.</p>
<p>当一个结构借用一个引用时,你总是需要一个明确的生命周期:</p>
<pre><code class="language-Rust">struct Container&lt;'a&gt; {
    s: &amp;'a str
}
</code></pre>
<p>这再次坚持结构不能超过引用. 对于结构和函数,生命周期都需要在中声明<code>&lt;&gt;</code>像一个类型参数.</p>
<p>闭包是非常方便和强类型的功能 -   Rust 迭代器的很多强类型函数都来自它们. 但是如果你存储它们,你必须指定一个生命周期. 这是因为基本上闭包是一个可以调用的生成结构,并且默认情况下是借用它的环境. 在这里<code>linear</code>闭包有不可改变的引用<code>m</code>和<code>c</code>.</p>
<pre><code class="language-Rust">let m = 2.0;
let c = 0.5;

let linear = |x| m*x + c;
let sc = |x| m*x.cos()
...
</code></pre>
<p><code>linear</code>和<code>sc</code>都实行<code>Fn(x: f64)-&gt;f64</code>但他们是 <em>不是</em> 同样的动物 - 他们有不同的类型和大小! 所以要存储它们,你必须做出一个<code>Box&lt;Fn(x: f64)-&gt;f64 + 'a&gt;</code>.</p>
<p>非常烦人,如果你习惯了JavaScript 或 Lua 的流畅闭包,但C ++与 Rust 类似,并且需要<code>std::function</code>存储不同的闭包,对虚拟呼叫采取一点点惩罚.</p>
<a class="header" href="print.html#a字符串-1" id="a字符串-1"><h2>字符串</h2></a>
<p>在开始时,通常会对 Rust 字符串感到恼火. 有不同的方式来创建它们,并且它们都感觉冗长:</p>
<pre><code class="language-Rust">let s1 = &quot;hello&quot;.to_string();
let s2 = String::from(&quot;dolly&quot;);
</code></pre>
<p>&quot;hello&quot; 不是 <em>已经是</em> 一个字符串? 好吧,在某种程度上. <code>String</code>是一个 <em>拥有的「owned」</em> 字符串,分配在堆上; 字符串文字&quot;hello&quot;是类型的<code>&amp;str</code> (&quot;字符串切片&quot;) ,并可能被烘焙到 可执行 (&quot;静态{static}&quot;) 或借用<code>String</code>. 系统语言需要这种区别 - 考虑一个微型微控制器,它有 一点RAM 和更多的ROM . 切片字符串 将被存储在ROM (&quot;只读&quot;) 中 ,这既便宜又消耗更少的功率.</p>
<p>但是 (你可能会说) 在C ++中它非常简单:</p>
<pre><code class="language-C">std::string s = &quot;hello&quot;;
</code></pre>
<p>其中较短的是,但隐藏了字符串对象的隐式创建. 因此, Rust 喜欢明确分配内存<code>to_string</code>. 另一方面,借用一个C ++字符串需要<code>c_str</code>,而C字符串很蠢.</p>
<p>幸运的是, Rust 的情况更好 - <em>一旦</em> 你接受这两个<code>String</code>和<code>&amp;str</code>是必要的. 方法<code>String</code>主要是为了改变字符串,就像<code>push</code>添加一个字符 (在引擎盖下它非常像<code>Vec&lt;u8&gt;</code>) . 但是所有的方法<code>&amp;str</code>也可用. 同样的<code>Deref</code>机制,一个<code>String</code>可以给<code>&amp;str</code>到一个函数 - 这就是为什么你很少看到<code>&amp;String</code>在函数定义中.</p>
<p>有很多方法可以转换<code>&amp;str</code>至<code>String</code>,对应于各种 trait.  Rust 需要这些 trait来一般地处理类型. 作为一个经验法则,任何实现<code>Display</code>也知道<code>to_string</code>, 喜欢<code>42.to_string()</code>.</p>
<p>一些运营商可能不会按照直觉行事:</p>
<pre><code class="language-Rust">    let s1 = &quot;hello&quot;.to_string();
    let s2 = s1.clone();
    assert!(s1 == s2);  // cool
    assert!(s1 == &quot;hello&quot;); // fine
    assert!(s1 == &amp;s2); // WTF?
</code></pre>
<p>记得,<code>String</code>和<code>&amp;String</code>是不同的类型,和<code>==</code>没有为该组合定义. 这可能会让一个习惯于引用的 C ++人 与数值几乎可以互换. 此外,<code>&amp;s2</code>不会 <em>神奇</em> 成为一个<code>&amp;str</code>, 那是一个 <em>deref强制</em> 这只在分配给 一个<code>&amp;str</code>变量或参数 时才会发生.  (明确的<code>s2.as_str()</code>会工作. )</p>
<p>但是,这有更真正值得一个WTF:</p>
<pre><code class="language-Rust">let s3 = s1 + s2;  // &lt;--- no can do
</code></pre>
<p>你不能连接两个<code>String</code>值,但可以连接一个<code>String</code>使用<code>&amp;str</code>. 此外,您不能连接一个<code>&amp;str</code>使用<code>String</code>. 所以大多数人不会使用<code>+</code>而使用<code>format!</code>宏,这很方便,但效率不高.</p>
<p>有些字符串操作可用,但工作方式不同. 例如,语言通常有一个<code>split</code>将字符串分解为字符串数组的方法.  Rust 字符串的这个方法返回一个 <em>迭代器</em> ,你可以 <em>然后</em> collect 成 Vec .</p>
<pre><code class="language-Rust">let parts: Vec&lt;_&gt; = s.split(',').collect();
</code></pre>
<p>如果你急于获取 Vec ,这有点笨拙. 但是你可以对零件进行操作 <em>无</em> 分配一个 Vec! 例如,分割中最大的字符串的长度?</p>
<pre><code class="language-Rust">let max = s.split(',').map(|s| s.len()).max().unwrap();
</code></pre>
<p>(该<code>unwrap</code>是因为空的迭代器没有最大值,我们必须覆盖这种情况. )</p>
<p>该<code>collect</code>方法返回一个<code>Vec&lt;&amp;str&gt;</code>,其中的部分是从原始字符串中借用的 - 我们只需要为引用分配空间. 在C ++中没有像这样的方法,但直到最近才需要单独分配每个子字符串.  (C ++ 17有<code>std::string_view</code>其行为像一个 Rust 字符串切片. )</p>
<a class="header" href="print.html#a关于分号的说明" id="a关于分号的说明"><h2>关于分号的说明</h2></a>
<p>分号是 <em>不</em> 可选的,但通常在与C相同的地方被排除,例如,后<code>{}</code>块. 之后他们也不需要<code>enum</code>要么<code>struct</code> (这是一个C特性. ) 但是,如果该块必须有一个 <em>值</em> ,那么分号将被丢弃:</p>
<pre><code class="language-Rust">    let msg = if ok {&quot;ok&quot;} else {&quot;error&quot;};
</code></pre>
<p>请注意,在此之后必须有一个分号在<code>let</code>声明之后!</p>
<p>如果在这些字符串之后有分号,那么返回的值就是<code>()</code> (像<code>Nothing</code>要么<code>void</code>) . 定义函数时常见错误:</p>
<pre><code class="language-Rust">fn sqr(x: f64) -&gt; f64 {
    x * x; // 是 reutrn x * x , 多了 ;
}
</code></pre>
<p><code>rustc</code>在这种情况下会给你一个明确的错误.</p>
<a class="header" href="print.html#a特定于c-的问题" id="a特定于c-的问题"><h2>特定于C ++的问题</h2></a>
<a class="header" href="print.html#rust-值语义是不同的" id="rust-值语义是不同的"><h3>Rust 值语义是不同的</h3></a>
<p>在C ++中,可以定义类型类似于原始并复制它们自己. 另外,可以定义移动构造函数来指定如何将值移出临时上下文.</p>
<p>在 Rust 里,原始人的行为和预期一样,但是<code>Copy</code>trait只能在集合类型 (结构{struct},元组{tuple}或枚举{enum}) 本身只包含可复制类型的情况下定义. 任意类型可能有<code>Clone</code>,但你必须使用<code>clone</code>方法.  Rust 要求任何分配都是明确的,不要隐藏在复制构造函数或赋值运算符中.</p>
<p>所以,复制和移动总是被定义为只是 移动位 而不能被覆盖.</p>
<p>如果<code>s1</code>不是<code>Copy</code>值类型,像<code>s2 = s1;</code>导致移动发生,而这 <em>消耗</em> <code>s1</code>!所以,当你真的想要一个副本,使用<code>clone</code>.</p>
<p>借用通常比复制要好,但是你必须遵循借用规则. 幸运的是,借用 <em>是</em> 一个可覆盖的行为. 例如,<code>String</code>可以借用成<code>&amp;str</code>,并共享所有不可变的方法<code>&amp;str</code>.  <em>字符串切片</em> 与类似的C ++&quot;借用{borrowing}&quot;操作相比,这是非常强类型的函数,它将提取一个<code>const char *</code>运用<code>c_str</code>. <code>&amp;str</code>由一个指向一些拥有的字节 (或字符串文字) 指针 和 一个 <em>尺寸「size」</em> 组成. 这导致了一些非常有效的内存模式. 你可以有一个<code>Vec&lt;&amp;str&gt;</code>所有的字符串都是从一些底层字符串中借用的 - 只需要分配 Vec 空间:</p>
<p>例如,按空格拆分:</p>
<pre><code class="language-Rust">fn split_whitespace(s: &amp;str) -&gt; Vec&lt;&amp;str&gt; {
    s.split_whitespace().collect()
}
</code></pre>
<p>同样,一个C ++<code>s.substr(0,2)</code>调用将始终复制字符串,但切片只会借用: <code>&amp;s[0..2]</code>.</p>
<p><code>Vec&lt;T&gt;</code>和<code>&amp;[T]</code>之间有一个等价的关系.</p>
<a class="header" href="print.html#a共享引用-1" id="a共享引用-1"><h3>共享引用</h3></a>
<p>Rust 有 <em>聪明的指针</em> 像C ++  - 例如,相当于<code>std::unique_ptr</code>是<code>Box</code>. 没有必要<code>删除</code>,因为任何内存或其他资源将在盒子超出范围时被回收 ( Rust 非常包含RAII) .</p>
<pre><code class="language-Rust">let mut answer = Box::new(&quot;hello&quot;.to_string());
*answer = &quot;world&quot;.to_string();
answer.push('!');
println!(&quot;{} {}&quot;, answer, answer.len());
</code></pre>
<p>人们发现<code>to_string</code>起初有点刺激,但事实确实如此 <em>明确的</em>.</p>
<p>注意显式的取值<code>*</code>,但智能指针上的方法不需要任何特殊符号 (我们不会这么说<code>(*answer).push('!')</code>)</p>
<p>显然,只有在原始内容明确定义的所有者的情况下,借用才有效. 在许多设计中,这是不可能的.</p>
<p>在C ++中,这是<code>std::shared_ptr的</code>用处;复制仅涉及修改公用数据的引用计数. 但这不是没有成本的:</p>
<ul>
<li>即使数据是只读的,不断修改引用计数也会导致缓存失效</li>
<li><code>std::shared_ptr</code>被设计成线程安全的并且也承载锁定开销</li>
</ul>
<p>在 Rust ,<code>std::rc::Rc</code>也像使用引用计数的共享智能指针一样工作. 但是,它仅适用于不可变引用! 如果你想要一个线程安全的变体,请使用<code>std::sync::Arc</code> ('Atomic Rc') . 所以 Rust 在提供两种变体方面有些尴尬,但你可以避免非线程操作的锁定开销.</p>
<p>这些必须是不可变的引用,因为这是 Rust 内存模型的基础. 但是,有一张退出卡: <code>std::cell::RefCell</code>. 如果您将共享引用定义为<code>Rc&lt;RefCell&lt;T&gt;&gt;</code>那么你可以可变地借用它的<code>borrow_mut</code>方法. 这适用 Rust 的借用规则 <em>动态</em>- 例如任何尝试使用<code>borrow_mut</code>,然而借用已经发生会引起恐慌.</p>
<p>这仍然是 <em>安全</em>. 恐慌会任何内存都被不当地触动 <em>之前</em> 发生! 像例外情况一样,他们展开调用堆栈. 所以对于这样一个结构化的过程来说这是一个不幸的词 - 这是一个有序的撤退 而不是 恐慌的撤退.</p>
<p>完整的<code>Rc&lt;RefCell&lt;T&gt;&gt;</code>类型笨拙,但应用程序代码并不令人不快.  Rust  (再次) 倾向于明确表示.</p>
<p>如果你想线程安全地访问共享状态,那么<code>Arc&lt;T&gt;</code>是唯一的 <em>安全</em> 要走的路. 如果你需要可变权限,那么<code>Arc&lt;Mutex&lt;T&gt;&gt;</code>相当于<code>Rc&lt;RefCell&lt;T&gt;&gt;</code>. <code>Mutex</code>与通常定义的方式有点不同: 它是一个值的容器.  在 值 上你得到一个 <em>锁{lock}</em>,然后可以修改它.</p>
<pre><code class="language-Rust">let answer = Arc::new(Mutex::new(10));

// in another thread
..
{
  let mut answer_ref = answer.lock().unwrap();
  *answer_ref = 42;
}
</code></pre>
<p>为什么<code>unwrap</code>? 如果前面的持有线程恐慌,那么这个<code>锁</code>失败.  (这是文档中的一个地方,<code>unwrap</code>被认为是合理的事情,因为事情显然已经严重错误. 恐慌总是可以在线索中发现. )</p>
<p>重要的是 (像往常一样使用 Mutex 锁) 这个排他锁尽可能少地保留下来. 所以它们在一个有限的范围内发生是很常见的 - 然后当可变引用超出范围时锁定结束.</p>
<p>与C ++中显然更简单的情况 (&quot;use shared_ptr dude&quot;) ,这看起来很尴尬,但是现在任何共享状态的 <em>修改</em> 都变得明显，
和“互斥锁{Mutex}”锁定模式强制线程安全。</p>
<p>像所有内容一样，使用共享引用<a href="https://news.ycombinator.com/item?id=11698784">警告</a></p>
<a class="header" href="print.html#a迭代器-1" id="a迭代器-1"><h3>迭代器</h3></a>
<p>C ++中的迭代器非常非正式地定义;</p>
<p>他们涉及智能指针,通常从头开始<code>c.begin()</code>并以<code>c.end()</code>结束. 迭代器上的操作然后作为独立的模板函数来实现,如<code>std::find_if</code>.</p>
<p>Rust 迭代器由<code>Iterator</code> trait 定义;<code>next</code>返回一个<code>Option</code>和什么时候<code>Option</code>是<code>None</code>我们结束了.</p>
<p>最常见的操作是现在的方法. 这是等价的<code>find_if</code>. 它返回一个<code>Option</code> (没有发现的情况是<code>None</code>) 和这里<code>if let</code>语句可以方便地提取 非-<code>None</code> 案件:</p>
<pre><code class="language-Rust">let arr = [10, 2, 30, 5];
if let Some(res) = arr.find(|x| x == 2) {
    // res is 2
}
</code></pre>
<a class="header" href="print.html#a不安全和链接列表" id="a不安全和链接列表"><h3>不安全和链接列表</h3></a>
<p>Rust  stdlib 的某些部分实现是使用 <code>unsafe</code>的. 并不是什么秘密. 这并不妨碍借 用检查员 的保守方法. 请记住,&quot;unsafe&quot;具有特殊意义 -   Rust 在编译时无法完全验证的操作. 从 Rust 的角度来看,C ++始终处于不安全的模式!所以如果一个大的应用程序需要几十行不安全的代码,那很好,因为这几行代码可以被人仔细检查. 人类不善于检查 100Kloc +的代码.</p>
<p>我提到这一点,因为似乎有一种模式: 一个有经验的 C ++人 试图实现 链表或树结构,并且感到沮丧. 那么,一个双链表 <em>是</em> 可能在安全的 Rust ,与<code>Rc</code>引用前进,和<code>Weak</code>引用回去. 但是标准库在使用指针方面仍需要获得了更多的性能.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        <script type="text/javascript">
            document.addEventListener('DOMContentLoaded', function() {
                window.print();
            })
        </script>
        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="searchindex.js" type="text/javascript" charset="utf-8"></script>
        
        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

    </body>
</html>
