<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>基本 - Rust 的绅士介绍</title>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <meta name="description" content="Rust语言，标准库和生态系统介绍">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="shortcut icon" href="favicon.png">
    <link rel="stylesheet" href="css/variables.css">
    <link rel="stylesheet" href="css/general.css">
    <link rel="stylesheet" href="css/chrome.css">
    <link rel="stylesheet" href="css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800"
        rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="highlight.css">
    <link rel="stylesheet" href="tomorrow-night.css">
    <link rel="stylesheet" href="ayu-highlight.css">

    <!-- Custom theme stylesheets -->
    

    
</head>

<body class="light">
    <!-- Provide site root to javascript -->
    <script type="text/javascript">var path_to_root = "";</script>

    <!-- Work around some values being stored in localStorage wrapped in quotes -->
    <script type="text/javascript">
        try {
            var theme = localStorage.getItem('mdbook-theme');
            var sidebar = localStorage.getItem('mdbook-sidebar');

            if (theme.startsWith('"') && theme.endsWith('"')) {
                localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
            }

            if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
            }
        } catch (e) { }
    </script>

    <!-- Set the theme before any content is loaded, prevents flash -->
    <script type="text/javascript">
        var theme;
        try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
        if (theme === null || theme === undefined) { theme = 'light'; }
        document.body.className = theme;
        document.querySelector('html').className = theme + ' js';
    </script>

    <!-- Hide / unhide sidebar before it is displayed -->
    <script type="text/javascript">
        var html = document.querySelector('html');
        var sidebar = 'hidden';
        if (document.body.clientWidth >= 1080) {
            try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
            sidebar = sidebar || 'visible';
        }
        html.classList.remove('sidebar-visible');
        html.classList.add("sidebar-" + sidebar);
    </script>

    <nav id="sidebar" class="sidebar" aria-label="Table of contents">
        <ol class="chapter"><li class="affix"><a href="readme.zh.html">介绍</a></li><li><a href="1-basics.zh.html" class="active"><strong aria-hidden="true">1.</strong> 基本</a></li><li><a href="2-structs-enums-lifetimes.zh.html"><strong aria-hidden="true">2.</strong> 结构,枚举和匹配</a></li><li><a href="3-filesystem.zh.html"><strong aria-hidden="true">3.</strong> 文件系统和进程</a></li><li><a href="4-modules.zh.html"><strong aria-hidden="true">4.</strong> 模块和货物</a></li><li><a href="5-stdlib-containers.zh.html"><strong aria-hidden="true">5.</strong> 标准库容器</a></li><li><a href="6-error-handling.zh.html"><strong aria-hidden="true">6.</strong> 错误处理</a></li><li><a href="7-shared-and-networking.zh.html"><strong aria-hidden="true">7.</strong> 线程,网络和共享</a></li><li><a href="object-orientation.zh.html"><strong aria-hidden="true">8.</strong> 面向对象编程</a></li><li><a href="nom-intro.zh.html"><strong aria-hidden="true">9.</strong> 用nom解析</a></li><li><a href="pain-points.zh.html"><strong aria-hidden="true">10.</strong> 痛点</a></li></ol>
    </nav>

    <div id="page-wrapper" class="page-wrapper">

        <div class="page">
            
            <div id="menu-bar" class="menu-bar">
                <div id="menu-bar-sticky-container">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                            aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <!-- START - Rust Cookbook customization -->
                        <button id="edit-button" class="icon-button" type="button" title="Fork and edit" aria-label="Fork and edit"
                            aria-haspopup="true" aria-expanded="false" aria-controls="edit">
                            <i class="fa fa-edit">Edit</i>
                        </button>
                        <!-- END - Rust Cookbook customization -->
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme"
                            aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                            aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Rust 的绅士介绍</h1>
                    
                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

            
            <div id="search-wrapper" class="hidden">
                <form id="searchbar-outer" class="searchbar-outer">
                    <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                        aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                </form>
                <div id="searchresults-outer" class="searchresults-outer hidden">
                    <div id="searchresults-header" class="searchresults-header"></div>
                    <ul id="searchresults">
                    </ul>
                </div>
            </div>
            

            <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
            <script type="text/javascript">
                document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                    link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                });
            </script>

            <!-- // START - Rust Cookbook customization -->
            <script>
                document.getElementById("edit-button").addEventListener("click", function () {
                    var editWindow = window.open("https://github.com/chinanf-boy/gentle-intro/edit/master/src/1-basics.zh.md");
                });</script>
            <!-- // END - Rust Cookbook customization -->

            <div id="content" class="content">
                <main>
                    <a class="header" href="#a基础" id="a基础"><h1>基础</h1></a>
<a class="header" href="#a目录" id="a目录"><h2>目录</h2></a>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<ul>
<li><a href="#%E4%BD%A0%E5%A5%BD%E4%B8%96%E7%95%8C">你好,世界!</a></li>
<li><a href="#%E5%BE%AA%E7%8E%AF%E5%92%8C%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5">循环和条件语句</a></li>
<li><a href="#%E5%BC%80%E5%A7%8B%E5%A0%86%E7%A7%AF%E6%9C%A8%E5%90%A7">开始堆积木吧</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E6%98%AF%E6%98%8E%E7%A1%AE%E7%9A%84">函数类型是明确的</a></li>
<li><a href="#%E5%AD%A6%E4%B9%A0%E5%9C%A8%E5%93%AA%E9%87%8C%E6%89%BE%E5%88%B0%E7%BB%B3%E5%AD%90">学习在哪里找到绳子</a></li>
<li><a href="#%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87">数组和切片</a></li>
<li><a href="#%E5%88%87%E5%92%8C%E5%89%B2">切和割</a></li>
<li><a href="#%E5%8F%AF%E9%80%89option%E5%80%BC">可选（Option）值</a></li>
<li><a href="#%E5%90%91%E9%87%8F">向量</a></li>
<li><a href="#%E8%BF%AD%E4%BB%A3%E5%99%A8">迭代器</a></li>
<li><a href="#%E6%9B%B4%E5%A4%9A%E5%85%B3%E4%BA%8E%E5%90%91%E9%87%8F">更多关于向量</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2">字符串</a></li>
<li><a href="#%E6%8F%92%E6%9B%B2-%E8%8E%B7%E5%8F%96%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0">插曲: 获取命令行参数</a></li>
<li><a href="#%E5%8C%B9%E9%85%8D">匹配</a></li>
<li><a href="#%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6">读取文件</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<a class="header" href="#a你好世界" id="a你好世界"><h2>你好,世界!</h2></a>
<p>自从第一个 C 语言版本诞生，”hello world”的最初目的是测试编译器并运行一个实际的程序。</p>
<pre><pre class="playpen"><code class="language-rust">// hello.rs
fn main() {
    println!(&quot;Hello, World!&quot;);
}
</code></pre></pre>
<pre><code>$ rustc hello.rs
$ ./hello
Hello, World!
</code></pre>
<p>Rust 是一种带分号的花括号语言, C ++ 风格注释和一个<code>main</code>函数 一 目前来说，非常熟悉吧。 <code>感叹号{!}</code>表明这是一个 <em>宏</em> 调用。 对于 C ++ 程序员来说，这可能是一个退步，因为它们使用了非常愚蠢的 C 宏 - 但我可以确保这些宏能够更强大和更理智。</p>
<p>对于其他任何人来说，会是”现在好了，我不得不记得说，砰!”。 但是，编译器很强的，知道吧;如果你忽略了那个惊叹号，你会得到:</p>
<pre><code>error[E0425]: unresolved name `println`
    --&gt; hello2.rs:2:5
    |
2 |     println(&quot;Hello, World!&quot;);
    |     ^^^^^^^ did you mean the macro `println!`?
</code></pre>
<p>学习一门语言意味着要熟悉它的错误。 试着把编译器当做是一个严格但友好的帮手，而不是一台对你 <em>大喊大叫{shouting}</em> 的电脑，因为你在最开始时，就会看到很多红墨迹。对于编程人员来说，你的编译器提前指出你的错误比程序在用户面前炸毁要好得多。</p>
<p>下一步是介绍一个 <em>变量{variable}</em>:</p>
<pre><pre class="playpen"><code class="language-rust">// let1.rs
fn main() {
    let answer = 42;
    println!(&quot;Hello {}&quot;, answer);
}
</code></pre></pre>
<p>拼写错误是 <em>编译{compile}</em> 错误，而不是类似 Python 或 JavaScript 等动态语言的运行时错误。 这将为您节省很多压力!如果我写了’answr’而不是’answer’，编译器实际上会有关于它的 <em>不错提示</em> :</p>
<pre><code>    4 |     println!(&quot;Hello {}&quot;, answr);
      |                         ^^^^^ did you mean `answer`?
</code></pre>
<p><code>println!</code>宏需要一个<a href="https://doc.rust-lang.org/std/fmt/index.html">格式字符串{format string}</a>和一些 值 ;它与 Python 3 使用的格式非常相似。</p>
<p>另一个非常有用的宏是<code>assert_eq!</code>。 这是在 Rust 中进行测试的主力;您 <em>断言{assert}</em> 两件事必须相等，如果不是，就会 <em>panic{恐慌}</em>，相当于程序崩溃。</p>
<pre><pre class="playpen"><code class="language-rust">// let2.rs
fn main() {
    let answer = 42;
    assert_eq!(answer,42);
}
</code></pre></pre>
<p>本来是不会产生任何输出。但一旦改 42 为 40:</p>
<pre><code>thread 'main' panicked at
'assertion failed: `(left == right)` (left: `42`, right: `40`)',
let2.rs:4
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>这是我们在 rust 中的第一个 <em>运行时错误</em> 。</p>
<a class="header" href="#a循环和条件语句" id="a循环和条件语句"><h2>循环和条件语句</h2></a>
<p>任何有趣的事情都可以会做不止一次:</p>
<pre><pre class="playpen"><code class="language-rust">// for1.rs
fn main() {
    for i in 0..5 {
        println!(&quot;Hello {}&quot;, i);
    }
}
</code></pre></pre>
<p>这 <em>范围{range}</em> 并不包括 <strong>5</strong>，所以<code>i</code>的范围从<strong>0 到 4</strong>。这在将数组等内容从 0 开始进行 <em>索引{indexes}</em> 的语言中很方便。</p>
<p>有趣的事情也必须要 <em>有条件地{conditionally}</em> 做:</p>
<pre><pre class="playpen"><code class="language-rust">// for2.rs
fn main() {
    for i in 0..5 {
        if i % 2 == 0 {
            println!(&quot;even {}&quot;, i);
        } else {
            println!(&quot;odd {}&quot;, i);
        }
    }
}
</code></pre></pre>
<pre><code>even 0
odd 1
even 2
odd 3
even 4
</code></pre>
<p><code>i % 2</code>为 0，如果<code>i</code>能被 2 整除; Rust 使用 C 风格操作符。 条件周围没有括号，这就像 Go 语言。但是在条件后面必须要跟使用花括号的代码块。</p>
<p>同样的事情，更有趣的写法方式:</p>
<pre><pre class="playpen"><code class="language-rust">// for3.rs
fn main() {
    for i in 0..5 {
        let even_odd = if i % 2 == 0 {&quot;even&quot;} else {&quot;odd&quot;};
        println!(&quot;{} {}&quot;, even_odd, i);
    }
}
</code></pre></pre>
<p>传统上，编程语言有 <em>声明{statements}</em> (比如<code>if</code>) 和 <em>表达式{expressions}</em> (比如<code>1 + i</code>) 。 在 rust 里，几乎所有的东西都有一个值并且可以成为表达式。 不再需要超丑的 C ‘三元操作符’<code>i % 2 == 0?&quot;even&quot;: &quot;odd&quot;</code>.</p>
<p>⚠️ 请注意，这些代码块中没有任何分号(像<code>{&quot;even&quot;} else {&quot;odd&quot;}</code>这样的)。</p>
<a class="header" href="#a开始堆积木吧" id="a开始堆积木吧"><h2>开始堆积木吧</h2></a>
<p>计算机非常擅长算术。 这里第一次尝试添加从 0 到 4 的所有数字:</p>
<pre><pre class="playpen"><code class="language-rust">// add1.rs
fn main() {
    let sum = 0;
    for i in 0..5 {
        sum += i;
    }
    println!(&quot;sum is {}&quot;, sum);
}
</code></pre></pre>
<p>但它没有编译成功:</p>
<pre><code>error[E0384]: re-assignment of immutable variable `sum`
    --&gt; add1.rs:5:9
3 |     let sum = 0;
    |         --- first assignment to `sum`
4 |     for i in 0..5 {
5 |         sum += i;
    |         ^^^^^^^^ re-assignment of immutable variable
</code></pre>
<p><code>不可变{Immutable}</code>? 一个变量不能 <em>变{vary}</em>? 默认的，<code>let</code>声明时，变量只能赋值。添加魔法<code>mut</code> (<em>请</em> 让变量可变) 完成表演:</p>
<pre><pre class="playpen"><code class="language-rust">// add2.rs
fn main() {
    let mut sum = 0;
    for i in 0..5 {
        sum += i;
    }
    println!(&quot;sum is {}&quot;, sum);
}
</code></pre></pre>
<p>其他语言使用人员，可能会感到费解，因，在他们看来，默认情况下变量就可以被重写。 变量的产生是，在运行时被分配了一个计算值 - 这不是一个 <em>常数 constant}</em> 。 在数学中也有同样的说法，就像我们说’让 n 是 S 中最大的数’。</p>
<p>声明变量默认 <em>只读</em> ，是有原因的。 在更大的程序中，很难跟踪正在写入的代码。 所以 Rust 是为了能够明确地表现出，像可变性 (’能写入’) 的东西。 Rust 语言中有很多聪明之处，但它不会隐藏任何东西。</p>
<p>Rust 既是静态类型又是强类型的，它们通常是混淆的，但请考虑 C (静态但弱类型) 和 Python (动态但强类型)。 在静态类型中，类型在编译时是已知的，而动态类型仅在运行时知道。</p>
<p>然而，此刻，感觉 Rust 把这些类型 <em>藏{hiding}</em> 了起来。究竟<code>i</code>是什么类型? 编译器可以从 0 开始, <em>类型推断</em> 并提出<code>i32</code> (四字节有符号整数)。</p>
<p>让我们做一个改变<code>0</code>到<code>0.0</code>. 然后我们得到错误:</p>
<pre><code>error[E0277]: the trait bound `{float}: std::ops::AddAssign&lt;{integer}&gt;` is not satisfied
    --&gt; add3.rs:5:9
    |
5 |         sum += i;
    |         ^^^^^^^^ the trait `std::ops::AddAssign&lt;{integer}&gt;` is not implemented for `{float}`
    |
</code></pre>
<p>好了，蜜月结束了: 这意味着什么? 每个操作符 (像 <code>+=</code> ) 对应一个 <em>特性{trait}</em> ，而这是一个抽象的接口，必须为每种具体的类型实现。 稍后我们将详细地处理 trait，但是这里您需要知道的是，<code>附加赋值{AddAssign}</code>是实现<code>+=</code>运算符的 trait 名称，错误是说浮点数没有实现整数的<code>+=</code>运算符。 (运算符 trait 的完整列表<a href="https://doc.rust-lang.org/std/ops/index.html">在这里</a>)</p>
<p>同样，Rust 喜欢张扬, 它不会默默地把那个整数转换成浮点数。</p>
<p>我们必须显式地将该值类型 <em>转换</em> 为浮点数.</p>
<pre><pre class="playpen"><code class="language-rust">// add3.rs
fn main() {
    let mut sum = 0.0;
    for i in 0..5 {
        sum += i as f64;
    }
    println!(&quot;sum is {}&quot;, sum);
}
</code></pre></pre>
<a class="header" href="#a函数类型是明确的" id="a函数类型是明确的"><h2>函数类型是明确的</h2></a>
<p><em>函数{Functions}</em> 是一个，编译器不容有失的类型之处。</p>
<p>这实际上是一个深思熟虑的决定，因像 Haskell ，该语言拥有强大的类型推断，几乎没有显式的类型名称。这 Haskell 风格，确实是函数+显式类型签名的好方法。而这也是 rust 需要的。</p>
<p>这是一个简单的用户定义函数:</p>
<pre><pre class="playpen"><code class="language-rust">// fun1.rs

fn sqr(x: f64) -&gt; f64 {
    return x * x;
}

fn main() {
    let res = sqr(2.0);
    println!(&quot;square is {}&quot;, res);
}
</code></pre></pre>
<p>Rust 回到了一个传统的参数声明，其中类型跟在名称后面。如同在 Pascal 等 Algol 派生语言。</p>
<p>再次，若没有整数到浮点数的转换 - 如果你用’2’直接代替<code>2.0</code>，那么我们
会得到一个明确的错误：</p>
<pre><code>8 |     let res = sqr(2);
    |                   ^ expected f64, found integral variable
    |
</code></pre>
<p>你很少会看到函数使用<code>return</code>声明。 更多时候，它会像这样:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn sqr(x: f64) -&gt; f64 {
    x * x
}
#}</code></pre></pre>
<p>这是因为函数的主体（<code>{}</code>内部）具有 <em>最后值表达式</em> ，就像 if-as-an-expression.</p>
<p>由于分号是由人的手指半自动插入的，因此您可以添加它
在 <em>最后值表达式</em> ，并得到以下错误：</p>
<pre><code>    |
3 | fn sqr(x: f64) -&gt; f64 {
    |                       ^ expected f64, found ()
    |
    = note: expected type `f64`
    = note:    found type `()`
help: consider removing this semicolon:
    --&gt; fun2.rs:4:8
    |
4 |     x * x;
    |       ^
</code></pre>
<p>这<code>()</code>类型是空的类型，没有什么结果，<code>无效{void}</code>，0，空，什么都没有的意思。 Rust 的一切都有个值，但有时它就是为空。编译器察觉这是个常见的错误，并能实实在在地帮助到你，(每个在 C++编译器上花过时间的人都知道，这可是个 <em>要死要死的情况</em> )。</p>
<blockquote>
<p>也就是说, 如果你要返回, 就不能加 <code>分号{;}</code></p>
</blockquote>
<p>没 return 表达风格的几个例子:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// 返回，一个浮点数的绝对值函数
fn abs(x: f64) -&gt; f64 {
    if x &gt; 0.0 {
        x
    } else {
        -x
    }
}

// 确保，该数字，定然在给予的范围内
fn clamp(x: f64, x1: f64, x2: f64) -&gt; f64 {
    if x &lt; x1 {
        x1
    } else if x &gt; x2 {
        x2
    } else {
        x
    }
}
#}</code></pre></pre>
<p>使用<code>return</code>不是错误的，但没有它，代码就会更干净。 但是对于从一个函数 <em>提前回来</em> ， 你仍会用到<code>return</code>。</p>
<p>一些操作可以被优雅地表达 <em>递归</em>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn factorial(n: u64) -&gt; u64 {
    if n == 0 {
        1
    } else {
        n * factorial(n-1)
    }
}
#}</code></pre></pre>
<p>起初这可能有些奇怪，然后最好用铅笔和纸制作一些例子。然而，通常这样做不是最 <em>高效</em> 的方式。</p>
<p>值也可以通过 <em>引用</em> 方式传递。 一个引用是由<code>&amp;</code>创建，还有用<code>*</code> <em>解引用</em> 。</p>
<pre><pre class="playpen"><code class="language-rust">fn by_ref(x: &amp;i32) -&gt; i32{
    *x + 1
}

fn main() {
    let i = 10;
    let res1 = by_ref(&amp;i);
    let res2 = by_ref(&amp;41);
    println!(&quot;{} {}&quot;, res1,res2);
}
// 11 42
</code></pre></pre>
<p>如果你想要一个函数来修改它的一个参数呢? 那么请输入 <em>可变引用</em>:</p>
<pre><pre class="playpen"><code class="language-rust">// fun4.rs

fn modifies(x: &amp;mut f64) {
    *x = 1.0;
}

fn main() {
    let mut res = 0.0;
    modifies(&amp;mut res);
    println!(&quot;res is {}&quot;, res);
}
</code></pre></pre>
<p>这比 C ++ 更像 C ++ 。 你必须明确地传递参数 (加上<code>&amp;</code>) 和明确 用<code>*</code> <em>解引用</em> 。 然后键入<code>mut</code>, 因为它不是默认可变的。 (我一直觉得与 C 相比, C++ 引用太容易错过。 )</p>
<p>基本上, Rust 是引入一些 <em>摩擦{friction}</em> 这里。并不是那么巧妙地推动函数直接返回值。 幸运的是, rust 有强力的方式表达”操作成功,结果在这里”。 所以<code>mut</code>不需要那么频繁。 当我们有一个大对象并且不想复制它时，传递引用就很重要了。</p>
<p>变量后加上类型的样式，同样适用于<code>let</code>，当你真的想改变变量的类型:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let bigint: i64 = 0;
#}</code></pre></pre>
<a class="header" href="#a学习在哪里找到绳子" id="a学习在哪里找到绳子"><h2>学习在哪里找到绳子</h2></a>
<p>现在是开始使用文档的时候了。 这已安装在您的机器上，您可以使用<code>rustup doc --std</code>在浏览器中打开它。</p>
<p>注意顶部的 <em>搜索</em> ，因为这将是你的朋友;它完全离线运行。</p>
<p>假设我们想知道数学函数在哪里，所以搜索”cos”。 前两个，显示它为单精度和双精度浮点数字的定义。 它定义在 <em>值本身{value itself}</em> 之上，作为一种方法，像这样:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let pi: f64 = 3.1416;
let x = pi/2.0;
let cosine = x.cos();
#}</code></pre></pre>
<p>结果近乎于零; 我们显然需要一个更权威的’pi’!</p>
<p>(为什么我们需要一个明确的<code>f64</code>类型? 因为没有它，该<em>3.1416</em>常数可以是<code>f32</code>或<code>f64</code>类型，而这些都是非常不同的。)</p>
<p>让我引用一个<code>cos</code>例子，但写一个完整的程序(<code>assert_eq!</code>的表亲戚<code>assert!</code>;表达式必须正确)。</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 2.0 * std::f64::consts::PI;

    let abs_difference = (x.cos() - 1.0).abs();

    assert!(abs_difference &lt; 1e-10);
}
</code></pre></pre>
<p><code>std::f64::consts::PI</code>是一口饭! <code>::</code>与在 c++中有同样的意思，(通常使用”.”在其他语言) - 这是一个完全合格的名字。 在文档搜索“PI”后，我们在第二个提示中得到这个全名。</p>
<p>到目前为止，我们的小 Rust 项目一直抛开<code>import</code>和<code>exclude</code>这些，会使讨论”Hello World”程序慢下来的东西。让这个程序可读性更强的<code>use</code>声明:</p>
<pre><pre class="playpen"><code class="language-rust">use std::f64::consts;

fn main() {
    let x = 2.0 * consts::PI;

    let abs_difference = (x.cos() - 1.0).abs();

    assert!(abs_difference &lt; 1e-10);
}
</code></pre></pre>
<p>为什么我们现在不需要这样做？
这是因为 Rust 的<em>prelude</em>在起作用，使许多基本功能无需显式 <code>use</code>语句。</p>
<a class="header" href="#a数组和切片" id="a数组和切片"><h2>数组和切片</h2></a>
<p>所有静态类型的语言都有 <em>数组</em>，这在内存装有鼻子到尾巴的值。数组 <em>索引</em> 从零开始:</p>
<pre><pre class="playpen"><code class="language-rust">// array1.rs
fn main() {
    let arr = [10, 20, 30, 40];
    let first = arr[0];
    println!(&quot;first {}&quot;, first);

    for i in 0..4 {
        println!(&quot;[{}] = {}&quot;, i,arr[i]);
    }
    println!(&quot;length {}&quot;, arr.len());
}
</code></pre></pre>
<p>输出是:</p>
<pre><code>first 10
[0] = 10
[1] = 20
[2] = 30
[3] = 40
length 4
</code></pre>
<p>在这种情况下，Rust 知道数组 <em>究竟</em> 有多大，如果你尝试访问<code>arr[4]</code>，这将是一个 <em>编译错误</em> 。</p>
<p>学习一门新语言往往涉及到 <em>忘却</em> 来自旧语言的已知思维习惯; 如果你是一个 Pythonista，那么这些括号你想是<code>list</code>。快速产生思绪，这是 Rust 中的<code>list</code>等同物，但数组不是你正在想的那样; 他们是 <em>固定大小</em>。 他们也会是 <em>可变的</em> (如果我们问得好)，但你不能添加新的元素。</p>
<p>在 Rust 中不常使用数组，因为数组的类型包含他们大小。 示例中的数组的类型是<code>[i32;4]</code>; <code>[10,20]</code>类型将会<code>[i32;2]</code>等等: 他们有 <em>不同类型</em>。 所以他们作为函数参数是件麻烦事。</p>
<p>常用的 <em>是</em> <em>切片</em>。 你可以把它们看作是一个基本值数组的 <em>快照</em> 。 它们的行为很像一个数组， 且 <em>知道他们的尺寸</em> ，不像那些危险的 C 指针东东。</p>
<p>注意这里有两个重要的事情 - 如何写一个切片的类型，和你必须使用<code>&amp;</code>将其传递给函数.</p>
<pre><pre class="playpen"><code class="language-rust">// array2.rs
// 读作 as: i32切片
fn sum(values: &amp;[i32]) -&gt; i32 {
    let mut res = 0;
    for i in 0..values.len() {
        res += values[i]
    }
    res
}

fn main() {
    let arr = [10,20,30,40];
    // 看着这里的 &amp;
    let res = sum(&amp;arr);
    println!(&quot;sum {}&quot;, res);
}
</code></pre></pre>
<p>先忽略<code>sum</code>函数，看看<code>&amp;[i32]</code>。 rust 数组和切片之间的关系类似于 C 数组和指针 之间的关系，除了两个重要的区别: rust 的切片会跟踪它们的大小 (如果你 尝试访问这个大小之外 会 <em>panic</em>)，并且想把数组作为一个切片传递，你必须明确地使用<code>&amp;</code>操作符。</p>
<p>C 程序员读<code>&amp;</code>作为”取地址符”，rust 程序员则是 <em>借用{borrow}</em> 它。 这将是要学习的 rust 关键词。 借用是编程中常见模式的名称; 每当你通过引用传递 (几乎总是发生在动态语言中) 或 在 C 中传递指针时，原始所有者所拥有的任何东西被 <em>借用</em> 了。</p>
<a class="header" href="#a切和割" id="a切和割"><h2>切和割</h2></a>
<p>不能以通常的方式<code>{}</code>打印出一个数组，但你可以用<code>{:?}</code>做一个 <em>debug</em>性质的打印。</p>
<pre><pre class="playpen"><code class="language-rust">// array3.rs
fn main() {
    let ints = [1, 2, 3];
    let floats = [1.1, 2.1, 3.1];
    let strings = [&quot;hello&quot;, &quot;world&quot;];
    let ints_ints = [[1, 2], [10, 20]];
    println!(&quot;ints {:?}&quot;, ints);
    println!(&quot;floats {:?}&quot;, floats);
    println!(&quot;strings {:?}&quot;, strings);
    println!(&quot;ints_ints {:?}&quot;, ints_ints);
}
</code></pre></pre>
<p>这使:</p>
<pre><code>ints [1, 2, 3]
floats [1.1, 2.1, 3.1]
strings [&quot;hello&quot;, &quot;world&quot;]
ints_ints [[1, 2], [10, 20]]
</code></pre>
<p>所以，数组套数组是没问题,但重要的是，数组包括内容 <em>只能有一个类型</em>。 数组中的值
在内存中排列在一起，以便他们非常高效地访问。</p>
<p>如果你对这些变量实际的类型感到好奇，这有些能用的方法。就是用一个你知道会是错误的显式类型，来声明一个变量:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let var: () = [1.1, 1.2];
#}</code></pre></pre>
<p>这是信息错误:</p>
<pre><code>3 |     let var: () = [1.1, 1.2];
  |                   ^^^^^^^^^^ expected (), found array of 2 elements
  |
  = note: expected type `()`
  = note:    found type `[{float}; 2]`
</code></pre>
<p>(<code>{float}</code>意思是”一些不完全指定的浮点数类型)</p>
<p>切片会给你 <em>相同</em> 数组的不同 <em>视角</em> :</p>
<pre><pre class="playpen"><code class="language-rust">// slice1.rs
fn main() {
    let ints = [1, 2, 3, 4, 5];
    let slice1 = &amp;ints[0..2];
    let slice2 = &amp;ints[1..];  // 开放式范围!

    println!(&quot;ints {:?}&quot;, ints);
    println!(&quot;slice1 {:?}&quot;, slice1);
    println!(&quot;slice2 {:?}&quot;, slice2);
}
</code></pre></pre>
<pre><code>ints [1, 2, 3, 4, 5]
slice1 [1, 2]
slice2 [2, 3, 4, 5]
</code></pre>
<p>这是一个简洁的符号，类似于 Python 切片但是有很大区别: 从未有过任何数据的副本。 这些 <em>切片</em> 都是<code>借用{borrow}</code> 他们自己的数组数据。 与数组存有一个非常亲密的关系，且 Rust 花很多精力来确保这种关系不会被破坏。</p>
<a class="header" href="#a可选option值" id="a可选option值"><h2>可选（Option）值</h2></a>
<p>切片，就像数组一样，可以 <em>索引</em>。 Rust 在编译时知道数组的大小，但只有在运行时才知道分切片的大小。 所以<code>s[i]</code>在运行时会引起超出界限的错误和 <em>恐慌{panic}</em>。 这你不会想要，而一个安全启动中止 与 非常昂贵的切片 之间也有所不同。 <em>无一例外</em>。</p>
<p>冷静下，大招来了。 你不能在某些 try-block 中包装可怕的问题代码，用来”捕获错误” - 至少不是你每天都想使用的方式。 那么 Rust 如何保证安全?</p>
<p>有一种切片方法<code>get</code>，这并不恐慌{panic}。但是它返回了什么?</p>
<pre><pre class="playpen"><code class="language-rust">// slice2.rs
fn main() {
    let ints = [1, 2, 3, 4, 5];
    let slice = &amp;ints;
    let first = slice.get(0);
    let last = slice.get(5);

    println!(&quot;first {:?}&quot;, first);
    println!(&quot;last {:?}&quot;, last);
}
// first Some(1)
// last None
</code></pre></pre>
<p><code>last</code>失败 (我们忘记了基于零的索引)，但返回了一个叫做<code>None</code>的东西。 <code>first</code>很好，但是作为一个 值包装在<code>Some</code>中。 欢迎<code>Options</code>类型!它可能是<code>Some</code> <em>或者</em> <code>None</code>。</p>
<p>这<code>option w</code>类型有一些有用的方法:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    println!(&quot;first {} {}&quot;, first.is_some(), first.is_none());
    println!(&quot;last {} {}&quot;, last.is_some(), last.is_none());
    println!(&quot;first value {}&quot;, first.unwrap());

// first true false
// last false true
// first value 1
#}</code></pre></pre>
<p>如果你 <em>打开{unwrap}</em> <code>last</code>，你会得到一个恐慌{panic}。但至少你可以调用<code>is_some</code> - 如示例中，如果默认你有一个 没有值的变量:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let maybe_last = slice.get(5);
    let last = if maybe_last.is_some() {
        *maybe_last.unwrap()
    } else {
        -1
    };
#}</code></pre></pre>
<p>注意<code>*</code> - <code>Some</code>内部的精确类型是<code>&amp;i32</code>，这是一个引用。 我们需要解引用回到一个<code>i32</code>的值.</p>
<p>这繁琐，一个快捷方式是<code>unwrap_or</code>, 如果返回的值是<code>None</code>的<code>Option</code>类型。 - 类型要匹配，因<code>get</code>返回一个引用。所以你必须写成<code>&amp;i32</code>与<code>&amp;-1</code>。最后再次使用<code>*</code>获得<code>i32</code>类型值。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let last = *slice.get(5).unwrap_or(&amp;-1);
#}</code></pre></pre>
<p>很容易漏写<code>&amp;</code>，但你有编译器的帮助。 如果它是<code>-1</code>，<code>rustc</code> says ‘expected &amp;{integer}， found integral variable’，然后告诉你’help: try<code>&amp;-1</code>“。</p>
<p>你可以把<code>Option</code>想成一个可能包含一个值的 盒子，或者什么都没有 (<code>None</code>) (在 Haskell， 它被称为<code>Maybe</code>)。 可能包含 <em>任何</em> 值，就是它的 <em>类型规范</em> 。而在这种情况下，完整的类型是<code>Option&lt;&amp;i32&gt;</code>，使用 C ++ 风格的表示 <em>泛型{generics}</em>。 打开这个 盒子可能会引起爆炸，但不像薛定谔的猫，我们可以事先知道它是否包含一个值。</p>
<p>在 Rust 函数/方法中， 返回这些可能的盒子(<code>Option</code>)，是非常常见的，所以学习如何舒适地<a href="https://doc.rust-lang.org/std/option/enum.Option.html">使用它们</a>。</p>
<a class="header" href="#a向量" id="a向量"><h2>向量</h2></a>
<p>我们将再次回到切片方法，但首先看看：向量{Vec}。 这些是 <em>灵活大小</em> 的数组，其行为很像 Python 的<code>List</code>和 C++ 的<code>std::vector</code>。 事实上，rust 的<code>Vec</code>会有所不同，你可以将额外的值附加到一个向量上，当然注意，它必须声明为可变的。</p>
<pre><pre class="playpen"><code class="language-rust">// vec1.rs
fn main() {
    let mut v = Vec::new();
    v.push(10);
    v.push(20);
    v.push(30);

    let first = v[0];  // 同样，超出范围也会 panic
    let maybe_first = v.get(0);

    println!(&quot;v is {:?}&quot;, v);
    println!(&quot;first is {}&quot;, first);
    println!(&quot;maybe_first is {:?}&quot;, maybe_first);
}
// v is [10, 20, 30]
// first is 10
// maybe_first is Some(10)
</code></pre></pre>
<p>一个常见的初学者错误是忘记<code>mut</code>，那你会得到一个有用的错误信息:</p>
<pre><code>3 |     let v = Vec::new();
  |         - use `mut v` here to make mutable
4 |     v.push(10);
  |     ^ cannot borrow mutably
</code></pre>
<p>向量和切片之间有非常密切的关系:</p>
<pre><pre class="playpen"><code class="language-rust">// vec2.rs
fn dump(arr: &amp;[i32]) {
    println!(&quot;arr is {:?}&quot;, arr);
}

fn main() {
    let mut v = Vec::new();
    v.push(10);
    v.push(20);
    v.push(30);

    dump(&amp;v);

    let slice = &amp;v[1..]; // &lt;== 这个 &amp;
    println!(&quot;slice is {:?}&quot;, slice);
}
</code></pre></pre>
<p>那个小小的,很重要的借用符号<code>&amp;</code>是为了 <em>迫使</em> 向量进入切片。且它是完全说得通的，因为向量也在观察着一个有值的数组，不同的是该数组为 <em>动态地</em> 分配。</p>
<p>如果你来自一种动态的语言，那么现在是时候开始讨论下了。 在系统语言中，程序存储器有两种: 栈和堆。 在栈上分配数据非常简单，但是栈是有限的; 通常是 MB 为单位。 堆可以是 GB，但是分配成本相对昂贵，并且这样的内存必须是之后 <em>释放</em> 。在所谓的’管理’语言 (如 java，Go 和所谓的脚本语言) 这些细节都隐藏在’便利的市政工程’称 <em>垃圾收集器</em> 中。 一旦系统确定数据不再引用的其他数据，它就会回到可用内存池。</p>
<p>一般来说，这是一个值得付出的代价。 玩栈非常不安全，
因为如果你犯了一个错误，在当前函数中覆盖返回地址，那么你跪了。</p>
<p>我写的第一个 C 程序是在 DOS PC 上，
抛开电脑本身。Unix 系统总是表现得更好，且只有 伴随一个 <em>segfault</em> 的进程才会挂掉
。 为什么这比 Rust（或 Go）程序恐慌{panic}更糟？
因为 Rust 会当原始问题出现了，就会发生恐慌{panic}, 而不是像以前困惑程序怎么崩溃的，并吃掉你所有的功课。</p>
<p>恐慌{panic}就是 <em>内存安全</em> ，它们在任何非法访问内存之前发生。 这是一个 C 中常见的安全问题，因为所有内存访问都是不安全的，并且一个狡猾的攻击者
可以利用这个弱点。</p>
<p>恐慌{panic}本身听起来是绝望的，无计划性的，但 Rust 的恐慌{panic}是结构化的 - 栈的 <em>释放</em> 方式
与异常(抛出错误)情况发生时相同。 所有分配的对象都被删除，并且生成一个回溯。</p>
<p>垃圾收集的缺点？ 首先是它是浪费内存，
看看那些占有重要地位，越来越统治我们世界的小型嵌入式微芯片，
其次是它会在最糟糕的时候决定进行 <em>立即</em> 清理
。 （有个妈妈的比喻是，她想在，你与新的情人快乐玩耍时，进行房间的打扫
）。 这些嵌入式系统需要当事物发生时，对其做出响应
（’实时’），并且不能容忍计划外的
清洗举动。 Roberto Ierusalimschy，Lua 的首席设计师（最优雅的动态语言设计师之一）
说，他不想飞机，是
依靠垃圾收集软件在飞。</p>
<p>回到 vectors ：当一个 vectors 被修改或创建时，它由堆分配内存，并变成
该内存的 <em>拥有者</em> 。 切片从 vectors 的内存中借用。
当 vectors 死亡或 <em>drops</em> 时，切片也会跟随 vectors 的动作。</p>
<a class="header" href="#a迭代器" id="a迭代器"><h2>迭代器</h2></a>
<p>我们到目前为止，都没有提及的关键部分，也正是 rust 的难题 - 迭代器.</p>
<p>一个范围的 for 循环，是在使用迭代器(<code>0..n</code>，其实是类似于 Python 3 的<code>range</code>功能)。</p>
<p>迭代器很容易定义。 下面是一个”对象”，它使用<code>next</code>方法返回一个<code>Option</code>。只要这个值不是<code>None</code>，我们就一直<code>next</code>下去:</p>
<pre><pre class="playpen"><code class="language-rust">// iter1.rs
fn main() {
    let mut iter = 0..3;
    assert_eq!(iter.next(), Some(0));
    assert_eq!(iter.next(), Some(1));
    assert_eq!(iter.next(), Some(2));
    assert_eq!(iter.next(), None);
}
</code></pre></pre>
<p>而这正是<code>for var in iter {}</code>所做的。</p>
<p>这似乎是定义 for 循环的一种低效方式，但是<code>rustc</code>在发布模式中会进行变态的优化，相信它会和<code>while</code>循环一样快。</p>
<p>这是对数组进行迭代的第一次尝试:</p>
<pre><pre class="playpen"><code class="language-rust">// iter2.rs
fn main() {
    let arr = [10, 20, 30];
    for i in arr {
        println!(&quot;{}&quot;, i);
    }
}
</code></pre></pre>
<p>失败,但有帮助哟:</p>
<pre><code>4 |     for i in arr {
  |     ^ the trait `std::iter::Iterator` is not implemented for `[{integer}; 3]`
  |
  = note: `[{integer}; 3]` is not an iterator; maybe try calling
   `.iter()` or a similar method
  = note: required by `std::iter::IntoIterator::into_iter`
</code></pre>
<p>按照<code>rustc</code>的建议，下面的程序按预期工作.</p>
<pre><pre class="playpen"><code class="language-rust">// iter3.rs
fn main() {
    let arr = [10, 20, 30];
    for i in arr.iter() {
        println!(&quot;{}&quot;, i);
    }

    // 切片将隐式转换为迭代器...
    let slice = &amp;arr;
    for i in slice {
        println!(&quot;{}&quot;, i);
    }
}
</code></pre></pre>
<p>实际上，迭代数组或切片，用这种方式比<code>for i in 0..slice.len() {}</code>效率更高，因为 Rust 不必痴迷于检查每个索引操作。</p>
<p>我们之前有一个，一系列整数总和的例子。 它涉及一个<code>mut</code>变量和循环。以下是 <em>惯用的</em>， 总和方式:</p>
<pre><pre class="playpen"><code class="language-rust">// sum1.rs
fn main() {
    let sum: i32  = (0..5).sum();
    println!(&quot;sum was {}&quot;, sum);

    let sum: i64 = [10, 20, 30].iter().sum();
    println!(&quot;sum was {}&quot;, sum);
}
</code></pre></pre>
<p>请注意，这是其中一个需要明确说明的情况，就是该变量的 <em>类型</em> ，因为不这样做， Rust 就没有足够的信息。 这里我们用两个不同的整数做总和，没有问题。 (如果用尽所有的名字，那创建一个新的同名变量也是没有问题的。 )</p>
<p>为了扩展需要，这有更多的<a href="https://doc.rust-lang.org/std/primitive.slice.html">切片 方法</a>。 (另一个文档提示;在每个文档页的右边有一个’[-]，可单击该按钮以折叠方法列表。 然后你可以扩展任何看起来很有趣的细节。 那些看起来怪异的东西，现在就忽略它吧。</p>
<p>这个<code>windows</code>方法，提供了一个迭代器，层叠的值窗口。</p>
<pre><pre class="playpen"><code class="language-rust">// slice4.rs
fn main() {
    let ints = [1, 2, 3, 4, 5];
    let slice = &amp;ints;

    for s in slice.windows(2) {
        println!(&quot;window {:?}&quot;, s);
    }
}
// window [1, 2]
// window [2, 3]
// window [3, 4]
// window [4, 5]
</code></pre></pre>
<p>或<code>块{chunks}</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    for s in slice.chunks(2) {
        println!(&quot;chunks {:?}&quot;, s);
    }
// chunks [1, 2]
// chunks [3, 4]
// chunks [5]
#}</code></pre></pre>
<a class="header" href="#a更多关于向量" id="a更多关于向量"><h2>更多关于向量</h2></a>
<p>有一个有用的小宏<code>vec!</code>用于初始化向量。 注意你可以使用<code>pop</code> <em>去除{remove}</em> 向量结尾值，和 <em>扩展{extend}</em> 一个兼容迭代器的向量。</p>
<pre><pre class="playpen"><code class="language-rust">// vec3.rs
fn main() {
    let mut v1 = vec![10, 20, 30, 40];
    v1.pop();

    let mut v2 = Vec::new();
    v2.push(10);
    v2.push(20);
    v2.push(30);

    assert_eq!(v1, v2);

    v2.extend(0..2);
    assert_eq!(v2, &amp;[10, 20, 30, 0, 1]);
}
</code></pre></pre>
<p>验证向量，它们之间每个对应值都相互比较，切片为值。</p>
<p>可以将值插入到向量中的任意位置。 <code>插入{insert}</code>或者使用<code>去除{remove}</code>移除。
这不像 push 和 pop 一样高效
，这些值将不得不被移动以腾出空间，所以请小心这些操作
向量。</p>
<p>vec 具有大小和 <em>capacity{容量}</em>。 如果你清除了一个 vec ，它的大小就变成了零，
但它仍保留其旧容量。 所以用<code>push</code>等来填充，只会
当尺寸大于该容量时，才会重新分配容量。</p>
<p>vec 可以排序，然后可以删除重复的 - 这些操作就在 vec 上。 (如果你想先复制，可使用<code>clone</code>).</p>
<pre><pre class="playpen"><code class="language-rust">// vec4.rs
fn main() {
    let mut v1 = vec![1, 10, 5, 1, 2, 11, 2, 40];
    v1.sort();
    v1.dedup();
    assert_eq!(v1, &amp;[1, 2, 5, 10, 11, 40]);
}
</code></pre></pre>
<a class="header" href="#a字符串" id="a字符串"><h2>字符串</h2></a>
<p>Rust 中的字符串比其他语言中的字符串更复杂一些; <code>String</code>类型，
像<code>Vec</code>，动态分配并可调整大小。 （所以它就像 C ++ 的<code>std::string</code>
但不像 Java 和 Python 的不可变字符串。）但是一个程序可能包含很多
<em>string literals {字符串常量}</em>（如”hello”）和系统语言应该能够在执行时静态存储这些
。 若放在微型嵌入式来说，这可能意味着存在
于 廉价的 ROM 而不是 昂贵的 RAM（对低功耗设备来说，RAM 是
在功耗方面也很昂贵。）所以 <em>系统</em> 语言必须具有
两种字符串，分配的与静态的。</p>
<p>所以”hello”不是<code>String</code>类型。 它是<code>＆str</code>类型（发音为’string slice’）。
这就像 C ++ 中 <code>const char*</code>和 <code>std::string</code> 之间的区别，除了
<code>＆str</code>更智能。 实际上，<code>＆str</code>和<code>String</code>有一个很好的的相似关系
就是<code>&amp;[T]</code>到<code>Vec&lt;T&gt;</code>。</p>
<pre><pre class="playpen"><code class="language-rust">// string1.rs
fn dump(s: &amp;str) {
    println!(&quot;str '{}'&quot;, s);
}

fn main() {
    let text = &quot;hello dolly&quot;;  // string 切片
    let s = text.to_string();  // 现变成 已分配的 string

    dump(text);
    dump(&amp;s);
}
</code></pre></pre>
<p>再次, 借用符号 可以迫使<code>String</code>成为<code>&amp;str</code>, 就像<code>Vec&lt;T&gt;</code>能被迫使进<code>&amp;[T]</code>。</p>
<p>在引擎盖下，<code>String</code>基本上是一个<code>Vec&lt;u8&gt;</code>，和<code>&amp;str</code>是一个<code>&amp;[u8]</code>, 但是那些字节 <em>必须</em> 表示有效的 UTF-8 文本。</p>
<p>就像一个 Vec，你可以<code>push</code>一个字符，和<code>pop</code>出<code>String</code>结尾:</p>
<pre><pre class="playpen"><code class="language-rust">// string5.rs
fn main() {
    let mut s = String::new();
    // 初始化 空的!
    s.push('H');
    s.push_str(&quot;ello&quot;);
    s.push(' ');
    s += &quot;World!&quot;; //  `push_str`的简写
    // 移除最后的char
    s.pop();

    assert_eq!(s, &quot;Hello World&quot;);
}
</code></pre></pre>
<p><code>to_string</code>可以将许多类型转换为字符串。 (如果可以用”{}”打印它们，那么它们就可以被转换) . <code>format!</code>是像<code>println!</code>使用相同的格式字符串，但构建更复杂的字符串的一种非常有用的方法。</p>
<pre><pre class="playpen"><code class="language-rust">// string6.rs
fn array_to_str(arr: &amp;[i32]) -&gt; String {
    let mut res = '['.to_string();
    for v in arr {
        res += &amp;v.to_string();
        res.push(',');
    }
    res.pop();
    res.push(']');
    res
}

fn main() {
    let arr = array_to_str(&amp;[10, 20, 30]);
    let res = format!(&quot;hello {}&quot;, arr);

    assert_eq!(res, &quot;hello [10,20,30]&quot;);
}
</code></pre></pre>
<p>注意<code>&amp;</code>在前面的<code>v.to_string()</code>- <code>&amp;</code>符号表示一个字符串切片，不是<code>String</code>自身(<code>to_string</code>返回)，因此，它需要一点手法来匹配。</p>
<blockquote>
<p>小课堂：<code>v</code>本身是<code>&amp;i32</code>类型，通过<code>to_string</code>转为<code>String</code>,再通过<code>&amp;</code>符号转为<code>&amp;str</code>，让 res 的<code>+=</code>语法糖(也就是<code>add_assign</code>方法)操作可以成功。<a href="https://doc.rust-lang.org/std/string/struct.String.html#impl-AddAssign%3C%26%27a%20str%3E">官方文档</a></p>
</blockquote>
<p>用于切片的<code>..</code>也与字符串一起工作:</p>
<pre><pre class="playpen"><code class="language-rust">// string2.rs
fn main() {
    let text = &quot;static&quot;;
    let string = &quot;dynamic&quot;.to_string();

    let text_s = &amp;text[1..];
    let string_s = &amp;string[2..4];

    println!(&quot;slices {:?} {:?}&quot;, text_s, string_s);
}
// slices &quot;tatic&quot; &quot;na&quot;
</code></pre></pre>
<p>但是，你不能索引字符串! 这是因为它们使用的是 唯(一)真(正)编码 UTF-8，其中的”character”可能是一个字节数。</p>
<pre><pre class="playpen"><code class="language-rust">// string3.rs
fn main() {
    let multilingual = &quot;Hi! ¡Hola! привет!&quot;;
    for ch in multilingual.chars() {
        print!(&quot;'{}' &quot;, ch);
    }
    println!(&quot;&quot;);
    println!(&quot;len {}&quot;, multilingual.len());
    println!(&quot;count {}&quot;, multilingual.chars().count());

    let maybe = multilingual.find('п');
    if maybe.is_some() {
        let hi = &amp;multilingual[maybe.unwrap()..];
        println!(&quot;Russian hi {}&quot;, hi);
    }
}
// 'H' 'i' '!' ' ' '¡' 'H' 'o' 'l' 'a' '!' ' ' 'п' 'р' 'и' 'в' 'е' 'т' '!'
// len 25
// count 18
// Russian hi привет!
</code></pre></pre>
<p>⚠️ 现在,让我们思考下 - 有 25 个字节，但是只有 18 个字符! 但是,如果你使用类似<code>find</code>的方法，你会得到一个有效的索引(如果有的话)和任意切片也会没事。</p>
<p>( Rust 的<code>char</code>类型是一个 4 字节的 Unicode 代码点。所以字符串不是字符
的数组!)</p>
<p>字符串切片可能会像 Vec 索引一样爆炸，因为它使用字节偏移量。在这种情况下，
该字符串由两个字节组成，所以试图拉出第一个字节，可是一个 Unicode 错误。 所以，
注意只使用来自字符串方法的有效偏移来切分字符串。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let s = &quot;¡&quot;;
    println!(&quot;{}&quot;, &amp;s[0..1]); // &lt;-- 错, 这是多字节字符的第一个字节
#}</code></pre></pre>
<p>拆解字符串是一种常见和有用的方式。字符串的<code>split_whitespace</code>
方法返回会 <em>迭代器</em>，然后，我们就选择去如何处理它。一个主要做法是需要
创建拆分子串的 vec 。</p>
<p><code>collect</code>非常普遍，因此需要一些关于，处于 collect 的线索，也就是看其
显式的类型。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let text = &quot;the red fox and the lazy dog&quot;;
    let words: Vec&lt;&amp;str&gt; = text.split_whitespace().collect();
    // [&quot;the&quot;, &quot;red&quot;, &quot;fox&quot;, &quot;and&quot;, &quot;the&quot;, &quot;lazy&quot;, &quot;dog&quot;]
#}</code></pre></pre>
<p>你也可以这样说，传递迭代器到<code>扩展{extend}</code>方法:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let mut words = Vec::new();
    words.extend(text.split_whitespace());
#}</code></pre></pre>
<p>在大多数语言中，我们将不得不制作这些 <em>分离的，已分配 字符串</em>，
而在这里， Vec 中的每个片段，都是从原始字符串中借用的。
我们所分配的是持有切片的位置。</p>
<p>看看这个可爱的双线<code>| |</code>; 我们从<code>chars</code>得到了一个迭代器，
并只要那些不是 空格 的字符。 再次，<code>collect</code>需要
一个线索（我们可能想要一个 字符串向量=String):</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let stripped: String = text.chars()
        .filter(|ch| ! ch.is_whitespace()).collect();
    // theredfoxandthelazydog
#}</code></pre></pre>
<p>这<code>filter</code>方法接受一个 <em>闭包函数</em>，这是 Rust 的 lambdas/匿名函数。这里的参数类型从上下文中是清楚的，所以显式规则是放松了的。</p>
<p>就是这样，你可以这样搞定 chars 的显式循环，将返回的字符切片推送到一个可变的向量中，但是这个更短，读取性很好 ( <em>当</em> 你习惯了)，同样也很快。使用一个循环的方式不是一种 <em>错</em> ，然而，我会鼓励你，也写这个一串过的版本。</p>
<a class="header" href="#a插曲-获取命令行参数" id="a插曲-获取命令行参数"><h2>插曲: 获取命令行参数</h2></a>
<p>到目前为止，我们的节目都生活在对外界的无知之中;现在是时候给他们提供数据。</p>
<p><code>std::env::args</code>是你如何访问命令行参数法宝;它返回一个迭代器作为字符串的参数,包括程序名。</p>
<pre><pre class="playpen"><code class="language-rust">// args0.rs
fn main() {
    for arg in std::env::args() {
        println!(&quot;'{}'&quot;, arg);
    }
}
</code></pre></pre>
<pre><code>src$ rustc args0.rs
src$ ./args0 42 'hello dolly' frodo
'./args0'
'42'
'hello dolly'
'frodo'
</code></pre>
<p>返回一个<code>Vec</code>会更好吗? 这很容易，使用<code>collect</code>制作迭代器，使用该向量的<code>skip</code>方法跳过程序名。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let args: Vec&lt;String&gt; = std::env::args().skip(1).collect();
    if args.len() &gt; 0 { // we have args!
        ...
    }
#}</code></pre></pre>
<p>这还不错;几乎所有的语言都会这样做.</p>
<p>读取单个参数的 更 Rust-y 特色的方法(传递一个整数值):</p>
<pre><pre class="playpen"><code class="language-rust">// args1.rs
use std::env;

fn main() {
    let first = env::args().nth(1).expect(&quot;please supply an argument&quot;);
    let n: i32 = first.parse().expect(&quot;not an integer!&quot;);
    // do your magic
}
</code></pre></pre>
<p><code>nth(1)</code>为您提供迭代器的第二个值，以及<code>expect</code>方法就像一个<code>unwrap</code>但带有可读的信息。</p>
<p>将字符串转换为数字很简单，但您需要指定值的类型 - 还有什么是可以<code>parse</code>的，你知道吗?</p>
<p>这个程序可能会恐慌{panic}，不过对笨拙的测试程序来说还能用。但不要太习惯于这种方便的想法。</p>
<a class="header" href="#a匹配" id="a匹配"><h2>匹配</h2></a>
<p>我们提取俄罗斯问候语的<code>string3.rs</code>代码，并不是通常的写法。 进入 <em>match</em> 的世界吧：</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    match multilingual.find('п') {
        Some(idx) =&gt; {
            let hi = &amp;multilingual[idx..];
            println!(&quot;Russian hi {}&quot;, hi);
        },
        None =&gt; println!(&quot;couldn't find the greeting, Товарищ&quot;)
    };
#}</code></pre></pre>
<p><code>match</code>包括几个 <em>模式{patterns}</em> ，用一个匹配值和后跟 胖箭头,用逗号分隔。 它方便地，将<code>Options</code>中的值与<code>idx</code>束缚起来。 你 <em>必须</em> 指定所有的可能性，所以我们必须处理<code>None</code>。</p>
<p>一旦你习惯了 (我的意思是，打多几遍)，感觉比<code>is_some</code>检查更自然，因检查还需要一个额外的<code>Option</code>存储。</p>
<p>但是，如果你对这里的失败不感兴趣，那么<code>if let</code>会是你的朋友:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    if let Some(idx) = multilingual.find('п') {
        println!(&quot;Russian hi {}&quot;, &amp;multilingual[idx..]);
    }
#}</code></pre></pre>
<p>如果你想做一次匹配，且 <em>只</em> 对一个可能的结果感兴趣，那这无疑是个方便的写法。</p>
<p><code>匹配{match}</code>也会像一个 C 的<code>switch</code>声明，就像其他 Rust 构造一样可以返回一个值:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let text = match n {
        0 =&gt; &quot;zero&quot;,
        1 =&gt; &quot;one&quot;,
        2 =&gt; &quot;two&quot;,
        _ =&gt; &quot;many&quot;,
    };
#}</code></pre></pre>
<p>这个<code>_</code>就像 C 的<code>default</code>，是一个备用情况。如果你不提供一个默认, <code>rustc</code>会认为这是一个错误。(在 C++中，最好的期望是一个警告，会说很多关于各自的语言)。</p>
<p>Rust 的<code>匹配</code>语句也可以匹配范围。 请注意，这些范围是有
<em>three{三个}</em> 点 ，并且是全包含性的范围，所以第一个条件将匹配 3。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    let text = match n {
        0...3 =&gt; &quot;small&quot;,
        4...6 =&gt; &quot;medium&quot;,
        _ =&gt; &quot;large&quot;,
     };
#}</code></pre></pre>
<a class="header" href="#a读取文件" id="a读取文件"><h2>读取文件</h2></a>
<p>下一步是向世界展示的，是 <em>读取文件</em>。</p>
<p>回想一下，<code>expect</code>就像<code>unwrap</code>，但可自定义一个错误消息。
在这里我们会扔掉一些错误:</p>
<pre><pre class="playpen"><code class="language-rust">// file1.rs
use std::env;
use std::fs::File;
use std::io::Read;

fn main() {
    let first = env::args().nth(1).expect(&quot;please supply a filename&quot;);

    let mut file = File::open(&amp;first).expect(&quot;can't open the file&quot;);

    let mut text = String::new();
    file.read_to_string(&amp;mut text).expect(&quot;can't read the file&quot;);

    println!(&quot;file had {} bytes&quot;, text.len());

}
</code></pre></pre>
<pre><code>src$ file1 file1.rs
file had 366 bytes
src$ ./file1 frodo.txt
thread 'main' panicked at 'can't open the file: Error { repr: Os { code: 2, message: &quot;No such file or directory&quot; } }', ../src/libcore/result.rs:837
note: Run with `RUST_BACKTRACE=1` for a backtrace.
src$ file1 file1
thread 'main' panicked at 'can't read the file: Error { repr: Custom(Custom { kind: InvalidData, error: StringError(&quot;stream did not contain valid UTF-8&quot;) }) }', ../src/libcore/result.rs:837
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>所以，<code>open</code>会失败，因为该文件不存在或者我们不允许读它，然后，<code>read_to_string</code>也会失败，因为该文件不包含有效的 UTF-8。 (虽然这么说，但你可以使用<code>read_to_end</code>并将 其内容 用 一个字节 vec 替代。) 对于不太大的文件，一口一口地读取它们是有用的，且直接。</p>
<p>如果你知道其他语言的文件处理，你可能会想要知道，文件什么时候 <em>关闭{closed}</em>。如果我们正在写入该文件，那么不关闭它，可能导致数据丢失。 但是这里啊，当函数结束时，文件就会被关闭，应<code>file</code>变量被 <em>释放{dropped}</em> 了。</p>
<p>要知道”抛出错误(throw-catch)”的做法习惯是很糟糕的。你不会想将这些代码放入函数中，因为它知道，它可以很容易地使整个程序崩溃。 所以现在我们必须谈论，<code>File::open</code>到底返回什么。如果<code>Option</code>是一个值，其可能包含或不包含任何内容，那么<code>Result</code>就是一个可能包含某些内容或一个错误的值。 他们都明白<code>unwrap</code> (和它的表弟<code>expect</code>) ，但它们完全不同。 <code>Result</code>是由 <em>二种</em> 类型参数定义的，分别是<code>Ok</code>值和<code>Err</code>值。 <code>Result</code>‘盒子’ 有两个隔间，一个标签是<code>Ok</code>而另一个是<code>Err</code>.</p>
<pre><pre class="playpen"><code class="language-rust">fn good_or_bad(good: bool) -&gt; Result&lt;i32,String&gt; {
    if good {
        Ok(42)
    } else {
        Err(&quot;bad&quot;.to_string())
    }
}

fn main() {
    println!(&quot;{:?}&quot;,good_or_bad(true));
    //Ok(42)
    println!(&quot;{:?}&quot;,good_or_bad(false));
    //Err(&quot;bad&quot;)

    match good_or_bad(true) {
        Ok(n) =&gt; println!(&quot;Cool, I got {}&quot;,n),
        Err(e) =&gt; println!(&quot;Huh, I just got {}&quot;,e)
    }
    // Cool, I got 42

}
</code></pre></pre>
<p>(实际的”错误”类型是随意的，很多人使用字符串，直到人们对 Rust 错误类型产生兴趣)。 这是返回一个值 <em>或</em> 另一个值的方便方法。</p>
<p>这些文件读取函数版本是不会崩溃。 因它返回一个<code>Result</code>，当然还要 <em>呼叫者{caller}</em> 决定如何处理这个错误。</p>
<pre><pre class="playpen"><code class="language-rust">// file2.rs
use std::env;
use std::fs::File;
use std::io::Read;
use std::io;

fn read_to_string(filename: &amp;str) -&gt; Result&lt;String,io::Error&gt; {
    let mut file = match File::open(&amp;filename) {
        Ok(f) =&gt; f,
        Err(e) =&gt; return Err(e),
    };
    let mut text = String::new();
    match file.read_to_string(&amp;mut text) {
        Ok(_) =&gt; Ok(text),
        Err(e) =&gt; Err(e),
    }
}

fn main() {
    let file = env::args().nth(1).expect(&quot;please supply a filename&quot;);

    let text = read_to_string(&amp;file).expect(&quot;bad file man!&quot;);

    println!(&quot;file had {} bytes&quot;, text.len());
}
</code></pre></pre>
<p>第一次匹配 从<code>Ok</code>安全地提取值，这就成了该 match 的值。 如果它是<code>Err</code>，就返回错误，并重新包装为一个<code>Err</code>。</p>
<p>第二个匹配返回字符串，包装为<code>Ok</code>，否则返回
（再一次）错误。<code>Ok</code>中的实际值不重要，所以我们用<code>_</code>忽略
它。</p>
<p>当一个函数的大部分在处理错误时，会不太好看; 那么
‘快乐’就会迷失了。往往这个问题，伴有很多
明确的提前返回，或者是 <em>ignoring errors{忽视了错误}</em> 。（顺便说一下，
这可是在 Rust 世界中，最接近邪恶的东西。）</p>
<p>幸运的是,有一个捷径。</p>
<p><code>std::io</code>模块定义了一个别名，名为<code>io::Result&lt;T&gt;</code>类型，这与<code>Result&lt;T,io::Error&gt;</code>相同，但更容易的类型。</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn read_to_string(filename: &amp;str) -&gt; io::Result&lt;String&gt; {
    let mut file = File::open(&amp;filename)?; // &lt;== ?
    let mut text = String::new();
    file.read_to_string(&amp;mut text)?;
    Ok(text)
}
#}</code></pre></pre>
<p>这里的<code>?</code>, 也几乎完全匹配了<code>File::open</code>所做的；如果其结果是一个错误，那么它将立即返回错误。 否则,它将返回<code>Ok</code>结果。
最后，我们仍然需要把该字符串包成一个 <code>Result</code> 类型。</p>
<p>2017 年是一个 Rust 的好年，还有酷酷的<code>?</code>也变得稳定。你也能看到用于旧代码的<code>try!</code>宏:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn read_to_string(filename: &amp;str) -&gt; io::Result&lt;String&gt; {
    let mut file = try!(File::open(&amp;filename));
    let mut text = String::new();
    try!(file.read_to_string(&amp;mut text));
    Ok(text)
}
#}</code></pre></pre>
<p>总而言之，你可以编写完全安全，且不丑的 Rust 代码，不需要什么异常捕获。</p>

                </main>

                <nav class="nav-wrapper" aria-label="Page navigation">
                    <!-- Mobile navigation buttons -->
                    
                    <a rel="prev" href="readme.zh.html" class="mobile-nav-chapters previous" title="Previous chapter"
                        aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    

                    
                    <a rel="next" href="2-structs-enums-lifetimes.zh.html" class="mobile-nav-chapters next" title="Next chapter"
                        aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                    

                    <div style="clear: both"></div>
                </nav>
            </div>
        </div>

        <nav class="nav-wide-wrapper" aria-label="Page navigation">
            
            <a href="readme.zh.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter"
                aria-keyshortcuts="Left">
                <i class="fa fa-angle-left"></i>
            </a>
            

            
            <a href="2-structs-enums-lifetimes.zh.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter"
                aria-keyshortcuts="Right">
                <i class="fa fa-angle-right"></i>
            </a>
            
        </nav>

    </div>

    

    
    <!-- Google Analytics Tag -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-128555056-1"></script>
    
    <script type="text/javascript">
        var localAddrs = ["localhost", "127.0.0.1", ""];
        if (localAddrs.indexOf(document.location.hostname) === -1) {
            window.dataLayer = window.dataLayer || [];
            function gtag() { dataLayer.push(arguments); }
            gtag('js', new Date());

            gtag('config', 'UA-128555056-1');
        }
    </script>
    

    

    
    <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
    

    <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
    <script src="book.js" type="text/javascript" charset="utf-8"></script>

    <!-- Custom JS scripts -->
    

    

</body>

</html>