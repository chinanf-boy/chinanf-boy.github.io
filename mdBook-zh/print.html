<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>mdBook 中文文档</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="mdbook :) markdown生成记. 就像 Gitbook, 但专为 Rust 设计">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="README.zh.html">介绍</a></li><li class="chapter-item expanded affix "><li class="part-title">User Guide</li><li class="chapter-item expanded "><a href="guide/installation.zh.html"><strong aria-hidden="true">1.</strong> 安装</a></li><li class="chapter-item expanded "><a href="guide/reading.zh.html"><strong aria-hidden="true">2.</strong> 读读读</a></li><li class="chapter-item expanded "><a href="guide/creating.zh.html"><strong aria-hidden="true">3.</strong> 书的制作</a></li><li class="chapter-item expanded affix "><li class="part-title">Reference Guide</li><li class="chapter-item expanded "><a href="cli/README.zh.html"><strong aria-hidden="true">4.</strong> 命令行</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cli/init.zh.html"><strong aria-hidden="true">4.1.</strong> init</a></li><li class="chapter-item expanded "><a href="cli/build.zh.html"><strong aria-hidden="true">4.2.</strong> build</a></li><li class="chapter-item expanded "><a href="cli/watch.zh.html"><strong aria-hidden="true">4.3.</strong> watch</a></li><li class="chapter-item expanded "><a href="cli/serve.zh.html"><strong aria-hidden="true">4.4.</strong> serve</a></li><li class="chapter-item expanded "><a href="cli/test.zh.html"><strong aria-hidden="true">4.5.</strong> test</a></li><li class="chapter-item expanded "><a href="cli/clean.zh.html"><strong aria-hidden="true">4.6.</strong> clean</a></li><li class="chapter-item expanded "><a href="cli/completions.zh.html"><strong aria-hidden="true">4.7.</strong> completions</a></li></ol></li><li class="chapter-item expanded "><a href="format/README.zh.html"><strong aria-hidden="true">5.</strong> 规范化</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="format/summary.zh.html"><strong aria-hidden="true">5.1.</strong> SUMMARY.md</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.1.</strong> Draft chapter</div></li></ol></li><li class="chapter-item expanded "><a href="format/configuration/README.zh.html"><strong aria-hidden="true">5.2.</strong> 配置</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="format/configuration/general.zh.html"><strong aria-hidden="true">5.2.1.</strong> 通用</a></li><li class="chapter-item expanded "><a href="format/configuration/preprocessors.zh.html"><strong aria-hidden="true">5.2.2.</strong> 预处理器</a></li><li class="chapter-item expanded "><a href="format/configuration/renderers.zh.html"><strong aria-hidden="true">5.2.3.</strong> 渲染器</a></li><li class="chapter-item expanded "><a href="format/configuration/environment-variables.zh.html"><strong aria-hidden="true">5.2.4.</strong> 环境变量</a></li></ol></li><li class="chapter-item expanded "><a href="format/theme/README.zh.html"><strong aria-hidden="true">5.3.</strong> 主题</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="format/theme/index-hbs.zh.html"><strong aria-hidden="true">5.3.1.</strong> index.hbs</a></li><li class="chapter-item expanded "><a href="format/theme/syntax-highlighting.zh.html"><strong aria-hidden="true">5.3.2.</strong> Syntax highlighting</a></li><li class="chapter-item expanded "><a href="format/theme/editor.zh.html"><strong aria-hidden="true">5.3.3.</strong> Editor</a></li></ol></li><li class="chapter-item expanded "><a href="format/mathjax.zh.html"><strong aria-hidden="true">5.4.</strong> MathJax 支持</a></li><li class="chapter-item expanded "><a href="format/mdbook.zh.html"><strong aria-hidden="true">5.5.</strong> mdBook 特殊功能</a></li><li class="chapter-item expanded "><a href="format/markdown.zh.html"><strong aria-hidden="true">5.6.</strong> Markdown</a></li></ol></li><li class="chapter-item expanded "><a href="continuous-integration.zh.html"><strong aria-hidden="true">6.</strong> 集成服务器</a></li><li class="chapter-item expanded "><a href="for_developers/README.zh.html"><strong aria-hidden="true">7.</strong> For Developers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="for_developers/preprocessors.zh.html"><strong aria-hidden="true">7.1.</strong> 预处理器的大小事</a></li><li class="chapter-item expanded "><a href="for_developers/backends.zh.html"><strong aria-hidden="true">7.2.</strong> 备用的后端</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="misc/contributors.zh.html">Contributors</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">mdBook 中文文档</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/chinanf-boy/mdBook-zh" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="介绍"><a class="header" href="#介绍">介绍</a></h1>
<p><strong>mdBook</strong> 是一个命令行工具，可以将 Markdown 文档，变成 HTML 网站。
这样的工具，用在产品信息或是 API 文档, 教程, 课件资料等等场景。</p>
<ul>
<li><strong>轻量级：</strong> <a href="format/markdown.zh.html">Markdown</a> 语法</li>
<li><strong>搜索：</strong> 集成 <a href="guide/reading.zh.html#search">search</a> 功能</li>
<li><strong>语法高亮：</strong> <a href="format/theme/syntax-highlighting.zh.html">syntax highlighting</a> </li>
<li><strong>多个主题：</strong> <a href="format/theme/index.html">Theme</a> 自定义输出的格式</li>
<li><strong>预先处理器：</strong> <a href="format/configuration/preprocessors.zh.html">Preprocessors</a> 预处理的扩展，比如</li>
<li><strong>后端：</strong> <a href="format/configuration/renderers.zh.html">Backends</a> 选择输出的渲染格式</li>
<li>自然，还具有 <a href="https://www.rust-lang.org/">Rust</a> 加持，速度杠杠的。</li>
<li>甚至，<a href="cli/test.zh.html">Rust 代码</a> 的自动测试。 </li>
</ul>
<p>本指南，带你进入，快进快出的现代化文档工具。
mdBook 是 Rust 官方的项目, 还有 <a href="https://doc.rust-lang.org/book/">The Rust Programming Language</a> 也是使用 <strong>本工具</strong> 的</p>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<blockquote>
<p>译者：这就不翻译了，有心者事竟成。</p>
</blockquote>
<p>mdBook is free and open source. You can find the source code on
<a href="https://github.com/rust-lang/mdBook">GitHub</a> and issues and feature requests can be posted on
the <a href="https://github.com/rust-lang/mdBook/issues">GitHub issue tracker</a>. mdBook relies on the community to fix bugs and
add features: if you’d like to contribute, please read
the <a href="https://github.com/rust-lang/mdBook/blob/master/CONTRIBUTING.md">CONTRIBUTING</a> guide and consider opening
a <a href="https://github.com/rust-lang/mdBook/pulls">pull request</a>.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>mdBook,所有源代码,都是在<a href="https://www.mozilla.org/MPL/2.0/">Mozilla Public License
v2.0</a>下发布的.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>安装 mdBook CLI 工具有多种方法。选择下面最适合您需要的任何一种方法。如果要安装 mdBook，是为了自动部署，请查看 <a href="guide/../continuous-integration.zh.html">持续集成</a> 有关如何安装的更多示例。。</p>
<h2 id="pre-compiled-binaries"><a class="header" href="#pre-compiled-binaries">Pre-compiled binaries</a></h2>
<p>可执行二进制文件，可在<a href="https://github.com/rust-lang/mdBook/releases">GitHub Releases page</a>下载。选择适用于您的平台（Windows、macOS 或 Linux）的二进制文件，下载后解压缩存档。存档包含一个<code>mdbook</code>可执行文件，您可以运行它，来构建书籍。</p>
<p>为了便于运行，请将二进制文件的路径放入<code>PATH</code>.</p>
<h2 id="build-from-source-using-rust"><a class="header" href="#build-from-source-using-rust">Build from source using Rust</a></h2>
<p>可从源代码构建<code>mdbook</code>，您首先需要安装 Rust 和 Cargo。按照屏幕上的说明操作<a href="https://www.rust-lang.org/tools/install">Rust installation page</a>。mdBook 当前至少需要 Rust 1.46。</p>
<p>安装 Rust 后，可以使用以下命令，构建和安装 mdBook：</p>
<pre><code class="language-sh">cargo install mdbook
</code></pre>
<p>这将自动从<a href="https://crates.io/">crates.io</a>下载 mdBook，构建并安装在 Cargo 的全局二进制目录中(默认情况下，<code>~/.cargo/bin/</code>）。</p>
<h3 id="installing-the-latest-master-version"><a class="header" href="#installing-the-latest-master-version">Installing the latest master version</a></h3>
<p>发布到 crates.io 的箱子版本，稍微落后于 GitHub 上托管的版本。如果您需要最新版本，您可以自己构建 mdBook 的 git 版本。cargo 构建起来**<em>超级容易</em>**!</p>
<pre><code class="language-sh">cargo install --git https://github.com/rust-lang/mdBook.git mdbook
</code></pre>
<p>同样，确保将命令行 cargo 的目录添加到您的<code>PATH</code>.</p>
<p>如果您对修改 mdBook 本身感兴趣，请查看<a href="https://github.com/rust-lang/mdBook/blob/master/CONTRIBUTING.md">Contributing Guide</a>了解更多信息。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="读读读"><a class="header" href="#读读读">读读读</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="书的制作"><a class="header" href="#书的制作">书的制作</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line-tool"><a class="header" href="#command-line-tool">Command Line Tool</a></h1>
<p>mdBook既可以用作命令行工具,也可以用作<a href="https://crates.io/crates/mdbook">Rust
crate</a>。让我们首先关注命令行工具功能.</p>
<h2 id="二进制"><a class="header" href="#二进制">二进制</a></h2>
<p>在尽力而为的基础上,预先编译主要平台的二进制文件。访问<a href="https://github.com/rust-lang/mdBook/releases"> releases 页面</a>下载适合您平台的版本.</p>
<h2 id="源码安装"><a class="header" href="#源码安装">源码安装</a></h2>
<p>mdBook也可以从源代码安装</p>
<h3 id="pre-requisite"><a class="header" href="#pre-requisite">Pre-requisite</a></h3>
<p>mdBook是写的 <strong><a href="https://www.rust-lang.org/">Rust</a></strong> 因此需要<strong>Cargo</strong>编译。如果您还没有安装Rust，请现在就<a href="https://www.rust-lang.org/zh-CN/tools/install">官方安装</a>。</p>
<h3 id="安装-cratesio-的版本"><a class="header" href="#安装-cratesio-的版本">安装 Crates.io 的版本</a></h3>
<p>如果您已安装Rust和Cargo,则安装mdBook相当容易。您只需在终端中键入以下代码段:</p>
<pre><code class="language-bash">cargo install mdbook
</code></pre>
<p>这将在<a href="https://crates.io/">Crates.io</a>获取最新版本的源代码，并编译它。你需要添加Cargo的<code>bin</code>目录，到你的环境变量<code>PATH</code>.</p>
<p>在您的终端，运行<code>mdbook help</code>验证它是否有效。</p>
<p>恭喜你,你已经安装了mdBook!</p>
<h3 id="安装-git-版本"><a class="header" href="#安装-git-版本">安装 Git 版本</a></h3>
<p>该 <strong><a href="https://github.com/rust-lang/mdBook">git 版本</a></strong> 包含所有最新的错误修复和功能, 且是在下一个版本中才发布<strong>Crates.io</strong>, 如果你不能等到下一个版本。你可以自己构建git版本。打开终端，并导航到您选择的目录。我们需要克隆git存储库,然后使用Cargo构建它.</p>
<pre><code class="language-bash">git clone --depth=1 https://github.com/rust-lang/mdBook.git
cd mdBook
cargo build --release
</code></pre>
<p>可执行文件<code>mdbook</code>输出在<code>./target/release</code>文件夹,这应该添加到环境变量<code>PATH</code>中，方便使用。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="init-命令"><a class="header" href="#init-命令">init 命令</a></h1>
<p>每本新书都有一些最小的样板。为此目的,mdBook 支持<code>init</code>命令.</p>
<p><code>init</code>命令使用如下:</p>
<pre><code class="language-bash">mdbook init
</code></pre>
<p>第一次使用<code>init</code>命令,将为您设置几个文件:</p>
<pre><code class="language-bash">book-test/
├── book
└── src
    ├── chapter_1.md
    └── SUMMARY.md
</code></pre>
<ul>
<li>
<p><code>src</code>目录是你在写的 markdown 书。它包含所有源文件,配置文件等.</p>
</li>
<li>
<p><code>book</code>目录是您的书 html 页面输出的位置。所有输出都可以上传到服务器,供观众查看.</p>
</li>
<li>
<p><code>SUMMARY.md</code>文件是您图书的骨架,并将在<a href="cli/../format/summary.zh.html">其他章节</a>进行更详细的讨论</p>
</li>
</ul>
<h4 id="tip-根据-summarymd-生成"><a class="header" href="#tip-根据-summarymd-生成">Tip: 根据 SUMMARY.md 生成</a></h4>
<p>当一个<code>SUMMARY.md</code>文件已存在,<code>init</code>命令将首先解析它，并根据<code>SUMMARY.md</code>中，帮其补全丢失的文件路径。这允许您思考和创建书的整个结构,然后让 mdBook 为您生成它.</p>
<h4 id="指定目录"><a class="header" href="#指定目录">指定目录</a></h4>
<p><code>init</code>命令可以将目录作为参数，用作本书的根目录，而不是当前工作目录.</p>
<pre><code class="language-bash">mdbook init path/to/book
</code></pre>
<h4 id="theme"><a class="header" href="#theme">–theme</a></h4>
<p>当你使用<code>--theme</code>,默认主题将被复制到一个名为<code>theme</code>的目录.</p>
<blockquote>
<p>在您的源目录中,以便您可以修改它.</p>
</blockquote>
<p>主题会被选择性地覆盖,这意味着如果您不想覆盖,只需删除它,就会使用默认文件.</p>
<h4 id="title"><a class="header" href="#title">–title</a></h4>
<p>指定书的标题。没有的话，它会问你</p>
<pre><code class="language-bash">mdbook init --title=&quot;my amazing book&quot;
</code></pre>
<h4 id="ignore"><a class="header" href="#ignore">–ignore</a></h4>
<p>创建一个 <code>.gitignore</code>，忽略<a href="cli/build.zh.html">构建</a>的目录。
没有的话，它会问你</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-命令"><a class="header" href="#build-命令">build 命令</a></h1>
<p>构建命令,用于渲染您的 md,并输出静态 html:</p>
<pre><code class="language-bash">mdbook build
</code></pre>
<p>它会尝试解析你的<code>SUMMARY.md</code>文件，以了解您的图书的结构并获取相应的文件。
要注意的是，如果你写在<code>SUMMARY.md</code>里面的文件链接不存在，它会帮你创建文件。</p>
<p>为方便起见，渲染的输出将保持与源目录结构相同。因此，大型书籍在渲染时能保持结构化。</p>
<h4 id="指定目录-1"><a class="header" href="#指定目录-1">指定目录</a></h4>
<p><code>build</code>命令可以将目录作为参数，用作本书的根目录，而不是当前工作目录.</p>
<pre><code class="language-bash">mdbook build path/to/book
</code></pre>
<h4 id="open"><a class="header" href="#open">–open</a></h4>
<p>当你使用<code>--open</code>(<code>-o</code>)，mdbook 将在构建之后，在默认 Web 浏览器中打开网页书.</p>
<h4 id="dest-dir"><a class="header" href="#dest-dir">–dest-dir</a></h4>
<p><code>--dest-dir</code>(<code>-d</code>)选项允许您更改书籍的输出目录。为相对路径，（相对于书籍的根目录）。如果未指定，则默认为<code>book.toml</code>配置的<code>build.build-dir</code>字段， 或者<code>./book</code>目录.</p>
<hr />
<p><strong><em>注意:</em></strong> <em>build 命令会复制源目录的所有文件(除了<code>.md</code>后缀)，到构建目录</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="watch-命令"><a class="header" href="#watch-命令">watch 命令</a></h1>
<p>当您希望在每次更改文件，都生成图书时， <code>watch</code>命令会很有用。你当然可以在每次更改文件反复发出<code>mdbook build</code>。但，聪明的是使用<code>mdbook watch</code>，这样就能观察您的文件，并会在您修改文件时，自动触发构建。
其中包括，那么删除掉，但仍在<code>SUMMARY.md</code>里的文件。</p>
<h4 id="指定目录-2"><a class="header" href="#指定目录-2">指定目录</a></h4>
<p><code>watch</code>命令可以将目录作为参数，用作本书的根目录，而不是当前工作目录.</p>
<pre><code class="language-bash">mdbook watch path/to/book
</code></pre>
<h4 id="open-1"><a class="header" href="#open-1">–open</a></h4>
<p>当你使用<code>--open</code>(<code>-o</code>)选项，mdbook 将在您的默认 Web 浏览器中打开网页书.</p>
<h4 id="dest-dir-1"><a class="header" href="#dest-dir-1">–dest-dir</a></h4>
<p><code>--dest-dir</code>(<code>-d</code>)选项允许您更改书籍的输出目录。为相对路径，（相对于书籍的根目录）。如果未指定，则默认为<code>book.toml</code>配置的<code>build.build-dir</code>字段， 或者<code>./book</code>目录.</p>
<h4 id="指定排除的模式"><a class="header" href="#指定排除的模式">指定排除的模式</a></h4>
<p><code>watch</code> 对 <code>.gitignore</code> 里的文件，不会触发构建命令。<code>.gitignore</code> 是有匹配模式的文件 <a href="https://git-scm.com/docs/gitignore">gitignore
documentation</a>。忽略那些缓存文件就挺有用的。</p>
<p><em>注意: 只有项目的顶层<code>.gitignore</code>是工作的。 全局的
<code>$HOME/.gitignore</code> or 上级文件夹的<code>.gitignore</code> 都不起作用</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-serve-command"><a class="header" href="#the-serve-command">The serve command</a></h1>
<p>serve 命令用于通过 HTTP 服务来预览书籍，默认情况下<code>localhost:3000</code>。</p>
<pre><code class="language-bash">mdbook serve
</code></pre>
<p><code>serve</code> 观察 <code>src</code> 目录的变化，对每次变化，都会执行重建与刷新客户端;
还包括重新创建已删除，但仍在 <code>SUMMARY.md</code>里的文件! 一个 websocket 连接用于触发客户端刷新.</p>
<p><strong><em>注意:</em></strong> <em><code>serve</code>命令用于测试书籍的 HTML 输出,并不打算成为网站的完整 HTTP 服务器.</em></p>
<h4 id="指定目录-3"><a class="header" href="#指定目录-3">指定目录</a></h4>
<p><code>serve</code>命令可以将目录作为参数，用作本书的根目录，而不是当前工作目录.</p>
<pre><code class="language-bash">mdbook serve path/to/book
</code></pre>
<h4 id="server-选项"><a class="header" href="#server-选项">Server 选项</a></h4>
<p><code>serve</code> 默认端口：<code>localhost:3000</code>；或是通过下面命令改变：</p>
<pre><code class="language-bash">mdbook serve path/to/book -p 8000 -n 127.0.0.1 
</code></pre>
<h4 id="open-2"><a class="header" href="#open-2">–open</a></h4>
<p>当你使用<code>--open</code>(<code>-o</code>)标志,mdbook 将在启动服务器后,在您的默认 Web 浏览器中打开该书.</p>
<h4 id="dest-dir-2"><a class="header" href="#dest-dir-2">–dest-dir</a></h4>
<p><code>--dest-dir</code>(<code>-d</code>)选项允许您更改书籍的输出目录。为相对路径，（相对于书籍的根目录）。如果未指定,则默认为<code>book.toml</code>配置的<code>build.build-dir</code>字段, 或者<code>./book</code>目录.</p>
<h4 id="指定排除的模式-1"><a class="header" href="#指定排除的模式-1">指定排除的模式</a></h4>
<p><code>watch</code> 对 <code>.gitignore</code> 里的文件，不会触发构建命令。<code>.gitignore</code> 是有匹配模式的文件 <a href="https://git-scm.com/docs/gitignore">gitignore
documentation</a>。忽略那些缓存文件就挺有用的。</p>
<p><em>注意: 只有项目的顶层<code>.gitignore</code>是工作的。 全局的
<code>$HOME/.gitignore</code> or 上级文件夹的<code>.gitignore</code> 都不起作用</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="test-命令"><a class="header" href="#test-命令">test 命令</a></h1>
<p>写书时，有时需要一些自动化测试。例如，<a href="https://doc.rust-lang.org/stable/book/">The Rust Programming Book</a>使用了许多可能过时的代码示例。因此，能够自动测试这些代码示例对他们来说非常重要。</p>
<p>mdBook 支持<code>test</code>将运行，书中所有可用测试的命令。目前，只支持 rustdoc 测试，但未来可能会扩展。</p>
<h4 id="在一个代码块禁用测试"><a class="header" href="#在一个代码块禁用测试">在一个代码块，禁用测试</a></h4>
<p>rustdoc 不会测试，包含<code>ignore</code>属性的代码块:</p>
<pre><code class="language-rust ignore">fn main() {}
</code></pre>
<p>rustdoc 也不会测试，指定了除 Rust 之外的语言的代码块:</p>
<pre><code class="language-markdown">**Foo**: _bar_
</code></pre>
<p>rustdoc<em>不会</em>测试，没有指定语言的代码块:</p>
<pre><code>This is going to cause an error!
</code></pre>
<h4 id="指定目录-4"><a class="header" href="#指定目录-4">指定目录</a></h4>
<p><code>test</code>命令可以将目录作为参数，用作本书的根目录，而不是当前工作目录.</p>
<pre><code class="language-bash">mdbook test path/to/book
</code></pre>
<h4 id="library-path"><a class="header" href="#library-path">–library-path</a></h4>
<p><code>--library-path</code>(<code>-L</code>)选项允许您，当<code>rustdoc</code>构建和测试示例时，将目录添加到搜索路径。可以指定多个目录(<code>-L foo -L bar</code>)，或用逗号分隔的列表(<code>-L foo,bar</code>)。路径应该指向 Cargo
<a href="https://doc.rust-lang.org/cargo/guide/build-cache.html">build cache</a> <code>deps</code> 目录，在其中包含了项目的输出。例如：你的目录叫 <code>my-book</code>, 下面的测试命令就可以带上 crate 的 依赖:</p>
<pre><code class="language-shell">mdbook test my-book -L target/debug/deps/
</code></pre>
<p>See the <code>rustdoc</code> command-line <a href="https://doc.rust-lang.org/rustdoc/command-line-arguments.html#-l--library-path-where-to-look-for-dependencies">documentation</a>
for more information.</p>
<h4 id="dest-dir-3"><a class="header" href="#dest-dir-3">–dest-dir</a></h4>
<p><code>--dest-dir</code>(<code>-d</code>)选项允许您更改书籍的输出目录。为相对路径，（相对于书籍的根目录）。如果未指定,则默认为<code>book.toml</code>配置的<code>build.build-dir</code>字段, 或者<code>./book</code>目录.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clean-命令"><a class="header" href="#clean-命令">clean 命令</a></h1>
<p>clean 命令用于删除生成的书籍，和任何其他构建工件.</p>
<pre><code class="language-bash">mdbook clean
</code></pre>
<h4 id="指定目录-5"><a class="header" href="#指定目录-5">指定目录</a></h4>
<p><code>clean</code>命令可以将目录作为参数，用作本书的根目录，而不是当前工作目录.</p>
<pre><code class="language-bash">mdbook clean path/to/book
</code></pre>
<h4 id="dest-dir-4"><a class="header" href="#dest-dir-4">–dest-dir</a></h4>
<p><code>--dest-dir</code>(<code>-d</code>)选项允许您覆盖书籍的输出目录,该目录会删除。
为相对路径，（相对于书籍的根目录）。如果未指定,则默认为<code>book.toml</code>配置的<code>build.build-dir</code>字段, 或者<code>./book</code>目录.</p>
<pre><code class="language-bash">mdbook clean --dest-dir=path/to/book
</code></pre>
<p><code>path/to/book</code>可以是绝对的，或相对的.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-completions-command"><a class="header" href="#the-completions-command">The completions command</a></h1>
<p>completions 用于自动补全命令。
这意味着，当你在终端上，输入 <code>mdbook</code>, 你可以按下补全键 (通常是 Tab) ，就会补全你的命令。</p>
<p>当然，要先安装下：</p>
<pre><code class="language-bash">mdbook completions bash &gt; ~/.local/share/bash-completion/completions/mdbook
</code></pre>
<p>这个命令会打印补全脚本。
运行 <code>mdbook completions --help</code> 看看所支持的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="格式"><a class="header" href="#格式">格式</a></h1>
<p>在本节中,您将学习如何:</p>
<ul>
<li>正确构建您的书</li>
<li>格式化你的<code>SUMMARY.md</code>文件</li>
<li>使用<code>book.toml</code>配置您的图书</li>
<li>自定义主题</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="summarymd"><a class="header" href="#summarymd">SUMMARY.md</a></h1>
<p>mdBook 使用 Summary 文件，来了解要书的章节，应显示的顺序，层次结构以及源文件的位置。<strong>没有这个文件，就没有书.</strong></p>
<p>必须叫<code>SUMMARY.md</code>，它是一个 markdown 文件， 但格式是非常严格，以便于给 mdbook 解析。我们来看看你应该如何结构化你的<code>SUMMARY.md</code>文件.</p>
<h4 id="结构"><a class="header" href="#结构">结构</a></h4>
<ol>
<li>
<p><strong><em>Title</em></strong> 一般来说，通常以<code
class="language-markdown"># Summary</code>。标题开头是常见的做法，但它不是强制性的，解析器只是忽略它。如果你也是这样想，也忽略它。</p>
<pre><code class="language-markdown"># Summary
</code></pre>
</li>
<li>
<p><strong><em>开头章节</em></strong> 位于主编号章节前，您可以添加一些不编号的开头章节。这对<code>前言，介绍</code>等很有用。但是有一些限制。你不能嵌套开头章节，它们都应该在根级别。一旦添加了编号章节，就无法添加开头章节。</p>
</li>
</ol>
<pre><code class="language-markdown">[A Prefix Chapter](relative/path/to/markdown.md)

- [First Chapter](relative/path/to/markdown2.md)
</code></pre>
<ol start="3">
<li>
<p><strong><em>Part Title</em></strong> - 标题，对书进行逻辑分割。它们渲染成不能点击的。
它是可选的，然后编号章节可以放在它下面：</p>
<pre><code class="language-markdown"># My Part Title

- [First Chapter](relative/path/to/markdown.md)
</code></pre>
</li>
<li>
<p><strong><em>编号章节</em></strong> 是本书的主要内容，它们将被编号，并可以嵌套，从而产生一个很好的层次结构(章节，子章节等)</p>
<pre><code class="language-markdown"># Title of Part

- [First Chapter](relative/path/to/markdown.md)
- [Second Chapter](relative/path/to/markdown2.md)
- [Sub Chapter](relative/path/to/markdown3.md)

# Title of Another Part

- [Another Chapter](relative/path/to/markdown4.md)
</code></pre>
<p>你可以使用<code>-</code>或<code>*</code>表示编号的章节.</p>
</li>
<li>
<p><strong><em>结尾章节</em></strong> 位于在编号章节后，您可以添加几个未编号的章节.它们与开头章节相同，但是在编号章节之后，而不是之前.</p>
<pre><code class="language-markdown">- [Last Chapter](relative/path/to/markdown.md)

[Title of Suffix Chapter](relative/path/to/markdown2.md)
</code></pre>
</li>
<li>
<p><strong><em>Draft chapters</em></strong> - 草稿章节。
它的作用就是，给章节的 TODO 字符串。
这类章节会被渲染，但是一个禁用的链接。
写法如下：</p>
<pre><code class="language-markdown">- [Draft Chapter]()
</code></pre>
</li>
<li>
<p><strong><em>Separators</em></strong> - Separators 可以在任意其他元素，之前，之间，之后添加。  <code>---</code>.</p>
<pre><code class="language-markdown"># My Part Title

[A Prefix Chapter](relative/path/to/markdown.md)

---

- [First Chapter](relative/path/to/markdown2.md)
</code></pre>
</li>
</ol>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>下面是指南的 <code>SUMMARY.md</code>，渲染结果正是这本书左边的内容。</p>
<pre><code class="language-markdown"># Summary

[介绍](README.zh.md)

# User Guide

- [安装](guide/installation.zh.md)
- [读读读](guide/reading.zh.md)
- [书的制作](guide/creating.zh.md)

# Reference Guide

- [命令行](cli/README.zh.md)
  - [init](cli/init.zh.md)
  - [build](cli/build.zh.md)
  - [watch](cli/watch.zh.md)
  - [serve](cli/serve.zh.md)
  - [test](cli/test.zh.md)
  - [clean](cli/clean.zh.md)
  - [completions](cli/completions.zh.md)
- [规范化](format/README.zh.md)
  - [SUMMARY.md](format/summary.zh.md)
    - [Draft chapter]()
  - [配置](format/configuration/README.zh.md)
    - [通用](format/configuration/general.zh.md)
    - [预处理器](format/configuration/preprocessors.zh.md)
    - [渲染器](format/configuration/renderers.zh.md)
    - [环境变量](format/configuration/environment-variables.zh.md)
  - [主题](format/theme/README.zh.md)
    - [index.hbs](format/theme/index-hbs.zh.md)
    - [Syntax highlighting](format/theme/syntax-highlighting.zh.md)
    - [Editor](format/theme/editor.zh.md)
  - [MathJax 支持](format/mathjax.zh.md)
  - [mdBook 特殊功能](format/mdbook.zh.md)
  - [Markdown](format/markdown.zh.md)
- [集成服务器](continuous-integration.zh.md)
- [For Developers](for_developers/README.zh.md)
  - [预处理器的大小事](for_developers/preprocessors.zh.md)
  - [备用的后端](for_developers/backends.zh.md)

---

[Contributors](misc/contributors.zh.md)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p>本节详细介绍了**<em>book.toml</em>**中可用的配置选项:</p>
<ul>
<li><strong><a href="format/configuration/general.zh.html">General</a></strong>，<code>book</code>, <code>rust</code>, <code>build</code>部分的配置</li>
<li><strong><a href="format/configuration/preprocessors.zh.html">Preprocessor</a></strong>，默认和自定义 book 预处理器的配置</li>
<li><strong><a href="format/configuration/renderers.zh.html">Renderer</a></strong>，HTML、标记和自定义渲染器的配置</li>
<li><strong><a href="format/configuration/environment-variables.zh.html">Environment Variable</a></strong>，用于覆盖环境中的配置</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="配置"><a class="header" href="#配置">配置</a></h1>
<p>您可以在 <strong><em>book.toml</em></strong> 文件中配置图书的参数.</p>
<p>这是一个 <strong><em>book.toml</em></strong> 文件示例，如下所示:</p>
<pre><code class="language-toml">[book]
title = &quot;Example book&quot;
author = &quot;John Doe&quot;
description = &quot;The example book covers examples.&quot;

[build]
build-dir = &quot;my-example-book&quot;
create-missing = false

[preprocessor.index]

[preprocessor.links]

[output.html]
additional-css = [&quot;custom.css&quot;]

[output.html.search]
limit-results = 15
</code></pre>
<h2 id="支持的配置选项"><a class="header" href="#支持的配置选项">支持的配置选项</a></h2>
<p>重要的是要注意到，配置中指定的<strong>任何</strong>相对路径，都是相对于配置文件所在的书籍的根目录.</p>
<h3 id="通用元数据"><a class="header" href="#通用元数据">通用元数据</a></h3>
<p>这是有关您图书的一般</p>
<table><thead><tr><th>信息</th><th>描述</th></tr></thead><tbody>
<tr><td><strong>title</strong></td><td>这本书的标题</td></tr>
<tr><td><strong>author</strong></td><td>本书的作者</td></tr>
<tr><td><strong>description</strong></td><td>该书的描述,作为元信息,添加在每页 html 的<code>&lt;head&gt;</code></td></tr>
<tr><td><strong>src</strong></td><td>默认情况下,源目录位于名为<code>src</code>的目录中(在根文件夹)。但这<code>src</code>是可配置的，就在<code>book.toml</code>。</td></tr>
<tr><td><strong>language:</strong></td><td>国家语言, 例如用在网页的 <code>&lt;html lang=&quot;en&quot;&gt;</code> 属性。</td></tr>
</tbody></table>
<p><strong>book.toml</strong></p>
<pre><code class="language-toml">[book]
title = &quot;Example book&quot;
authors = [&quot;John Doe&quot;, &quot;Jane Doe&quot;]
description = &quot;The example book covers examples.&quot;
src = &quot;my-src&quot;  # 源文件夹，用 `root/my-src` 替代 `root/src`
language = &quot;zh-CN&quot;
</code></pre>
<h3 id="rust-options"><a class="header" href="#rust-options">Rust options</a></h3>
<p>Rust 语言的选项，与运行测试和集成相关。</p>
<pre><code class="language-toml">[rust]
edition = &quot;2015&quot;   # 默认版本
</code></pre>
<ul>
<li>
<p><strong>版本</strong>：默认情况下用于代码段的 Rust edition。默认值为<code>2015</code>。单个代码块可以通过<code>edition2015</code>, <code>edition2018</code>或<code>edition2021</code>注释，例如：</p>
<pre><code class="language-text">```rust,edition2015
// This only works in 2015.
let try = true;
```
</code></pre>
</li>
</ul>
<h3 id="build-选项"><a class="header" href="#build-选项">Build 选项</a></h3>
<p>这可以控制您图书的构建过程.</p>
<pre><code class="language-toml">[build]
build-dir = &quot;book&quot;                # the directory where the output is placed
create-missing = true             # whether or not to create missing pages
use-default-preprocessors = true  # use the default preprocessors
</code></pre>
<ul>
<li>
<p><strong>build-dir</strong> | 放置渲染图书的目录。默认情况下在根目录的<code>book/</code>:</p>
</li>
<li>
<p><strong>create-missing</strong> | 默认情况(<code>create-missing = true</code>)下，在书籍建成时，会创建<code>SUMMARY.md</code>中缺失的文件。如果是<code>false</code>，则有文件不存在,那么构建过程将以错误退出。</p>
</li>
<li>
<p><strong>use-default-preprocessors</strong> | 设为 <code>false</code>，会禁用(<code>links</code>&amp;<code>index</code>)的默认预处理器。</p>
<p>如果您通过配置文件声明了，相同的和/或其他预处理器,由它们主导.</p>
<ul>
<li>为清楚起见,没有预处理器配置,默认<code>links</code>和<code>index</code>运行.</li>
<li>设置<code>use-default-preprocessors = false</code>，将禁用这些默认预处理器运行.</li>
<li>若添加<code>[preprocessor.links]</code>，那无论如何,都能确保<code>use-default-preprocessors</code>运行<code>links</code>。</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="配置预处理器"><a class="header" href="#配置预处理器">配置，预处理器</a></h2>
<p>预处理器的作用是，在送进 renderer 之前，修改原始的 Markdown 文本。</p>
<p>内置的有：</p>
<ul>
<li><code>links</code>：扩展章节中<code>{{ #playground }}</code>和<code>{{ #include }}</code>，和 <code>{{ #rustdoc_include }}</code> 控制条，能帮助引入文件的内容。查看 <a href="format/configuration/../mdbook.zh.html#including-files">Including files</a> for more.</li>
<li><code>index</code>：将所有名为<code>README.md</code>的章节文件，转换<code>index.md</code>。也就是说，所有<code>README.md</code>将被渲染成<code>index.html</code>。</li>
</ul>
<p>内置的预处理器，可以通过<a href="format/configuration/general.zh.html#build-options"><code>build.use-default-preprocessors</code></a>禁用。</p>
<p>社区也开发了几个预处理器，可以看看这里<a href="https://github.com/rust-lang/mdBook/wiki/Third-party-plugins">Third Party Plugins</a></p>
<p>关于如何创建一个新的预处理器，可以看看<a href="format/configuration/../../for_developers/preprocessors.zh.html">Preprocessors for Developers</a> 章节。</p>
<h3 id="自定义预处理器配置"><a class="header" href="#自定义预处理器配置">自定义预处理器配置</a></h3>
<p>与渲染器一样，预处理器需要有自己的表格(例如<code>[preprocessor.mathjax]</code>)。在该部分中，您可以通过向特有表中，添加键值对来将额外配置传递给预处理器.</p>
<p>例如，如果你有个预处理器叫<code>mdbook-example</code>那么可以这样</p>
<pre><code class="language-toml">[preprocessor.example]
</code></pre>
<p>有了这个配置，mdBook 会执行，<code>mdbook-example</code> 的预处理器。</p>
<p>在这上面，还能添加 key-value 的配置。例如，需要额外的配置选项：</p>
<pre><code class="language-toml">[preprocessor.example]
some-extra-feature = true
</code></pre>
<h4 id="锁住一个预处理依赖给一个渲染器"><a class="header" href="#锁住一个预处理依赖给一个渲染器">锁住一个预处理依赖给一个渲染器</a></h4>
<p>您可以通过将两者绑定在一起，显式指定预处理器将运行的渲染器</p>
<pre><code class="language-toml">[preprocessor.example]
renderers = [&quot;html&quot;]  # example 只 HTML 渲染合作
</code></pre>
<h3 id="添加你的命令"><a class="header" href="#添加你的命令">添加你的命令</a></h3>
<p>默认情况下，添加<code>[preprocessor.foo]</code>到你的<code>book.toml</code>文件，<code>mdbook</code>将尝试调用<code>mdbook-foo</code>启动。如果你想使用不同的程序名 或传递一个命令行参数。这些都能通过<code>command</code>字段覆盖完成。</p>
<pre><code class="language-toml">[preprocessor.random]
command = &quot;python random.py&quot;
</code></pre>
<h2 id="顺序执行"><a class="header" href="#顺序执行">顺序执行</a></h2>
<p>执行的顺序可以通过， <code>before</code> 和 <code>after</code> 字段完成。
例如：假设你想 <code>{{#include}}</code> 之后，再执行<code>linenos</code>; 然后，你想在<code>links</code> 之后运行，<code>before</code> 或 <code>after</code> 就派上用场了:</p>
<pre><code class="language-toml">[preprocessor.linenos]
after = [ &quot;links&quot; ]
</code></pre>
<p>或</p>
<pre><code class="language-toml">[preprocessor.links]
before = [ &quot;linenos&quot; ]
</code></pre>
<p>虽然多余，但也可以在同一个配置文件中，指定上述两者。</p>
<p>具有相同优先级的预处理器通过 <code>before</code> 和 <code>after</code>，以名字排序。
将检测到任何无限循环并产生错误。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="配置渲染器"><a class="header" href="#配置渲染器">配置渲染器</a></h2>
<p>渲染器（也叫后端），职责是书的输出。</p>
<p>内置的渲染器有:</p>
<ul>
<li><a href="format/configuration/renderers.zh.html#html-renderer-options"><code>html</code></a> — HTML 的输出.
默认启动， 如果 <code>book.toml</code> 上的<code>[output]</code>，没有其他设置。</li>
<li><a href="format/configuration/renderers.zh.html#markdown-renderer"><code>markdown</code></a> — 运行 预处理器之后，输出 markdown。
调试专用。</li>
</ul>
<p>社区也有，可以看看 <a href="https://github.com/rust-lang/mdBook/wiki/Third-party-plugins">Third Party Plugins</a> 。</p>
<p>开发的话，看这里 <a href="format/configuration/../../for_developers/backends.zh.html">Backends for Developers</a> 。</p>
<h2 id="output-tables"><a class="header" href="#output-tables">Output tables</a></h2>
<p>Backends 通过 <code>book.toml</code> 的<code>output</code> 设置，记得带上名称。
比如：它叫做 <code>mdbook-wordcount</code>, 写入:</p>
<pre><code class="language-toml">[output.wordcount]
</code></pre>
<p>有了这个设置， mdBook 会执行 <code>mdbook-wordcount</code> 后端。</p>
<p>还能添加额外的配置参数，例如：
如果我们 wordcount 需要其他的配置选项：</p>
<pre><code class="language-toml">[output.wordcount]
ignores = [&quot;Example Chapter&quot;]
</code></pre>
<p>如果，定义了任意的 <code>[output]</code>，那么 <code>html</code> 就不会启动。
如果你想 <code>html</code> 在后台运行，请写入 <code>book.toml</code> 文件。
For example:</p>
<pre><code class="language-toml">[book]
title = &quot;My Awesome Book&quot;

[output.wordcount]

[output.html]
</code></pre>
<p>如果定义<code>output</code>，超过一个 ，那么这会，改变输出目录的布局。
如果只有一个后端，那么，输出目录就在 <code>book</code> 目录 (配置 <a href="format/configuration/general.zh.html#build-options"><code>build.build-dir</code></a>，覆盖位置)。
如果超过一个后端，那么，就会放在 <code>book</code>下，分开的目录。
例如：上面的命令就会有 <code>book/html</code> 和 <code>book/wordcount</code>。</p>
<h3 id="custom-backend-commands"><a class="header" href="#custom-backend-commands">Custom backend commands</a></h3>
<p>默认情况下，将 <code>[output.foo]</code> 添加到 <code>book.toml</code> 文件，
<code>mdbook</code> 会尝试调用 <code>mdbook-foo</code> 可执行文件。
如果，你使用了一个不同的程序名称，或传递命令行参数，这些行为都会被 <code>command</code> 覆盖。</p>
<pre><code class="language-toml">[output.random]
command = &quot;python random.py&quot;
</code></pre>
<h3 id="optional-backends"><a class="header" href="#optional-backends">Optional backends</a></h3>
<p>如果你的后端是没有安装的，那么默认的行为就是抛出一个错误。
这个错误的纠正，可以将后端设为可选：</p>
<pre><code class="language-toml">[output.wordcount]
optional = true
</code></pre>
<p>这会将 错误，变成警告。</p>
<h3 id="html-渲染器选项"><a class="header" href="#html-渲染器选项">HTML 渲染器选项</a></h3>
<p>HTML 渲染器也有几个选项，在 TOML 下指定渲染器的所有选项.</p>
<pre><code class="language-toml"># Example book.toml file with all output options.
[book]
title = &quot;Example book&quot;
authors = [&quot;John Doe&quot;, &quot;Jane Doe&quot;]
description = &quot;The example book covers examples.&quot;

[output.html]
theme = &quot;my-theme&quot;
default-theme = &quot;light&quot;
preferred-dark-theme = &quot;navy&quot;
curly-quotes = true
mathjax-support = false
copy-fonts = true
additional-css = [&quot;custom.css&quot;, &quot;custom2.css&quot;]
additional-js = [&quot;custom.js&quot;]
no-section-label = false
git-repository-url = &quot;https://github.com/rust-lang/mdBook&quot;
git-repository-icon = &quot;fa-github&quot;
edit-url-template = &quot;https://github.com/rust-lang/mdBook/edit/master/guide/{path}&quot;
site-url = &quot;/example-book/&quot;
cname = &quot;myproject.rs&quot;
input-404 = &quot;not-found.md&quot;
</code></pre>
<p>| <code>[output.html]</code>可以使用以下配置选项: | 描述                                                                                                                                                                                                                                                                                                                           |
| ———————————— | —————————————————————————————————————————————————————————————————————————————————————————————————————————— | — |
| <strong>theme</strong>                            | mdBook 附带一个默认主题，及其所需的所有资源文件.但是如果设置了此选项,mdBook 将选择性地使用，能在指定文件夹中找到的主题文件，覆盖主题文件。                                                                                                                                                                                     |
| <strong>default-theme</strong>                    | 默认情况下在“更改主题“下拉列表中，选择的主题颜色方案。默认为<code>light</code>。                                                                                                                                                                                                                                                          |
| <strong>preferred-dark-theme:</strong>            | 默认 dark 主题。如果要求 dark 主题，通过 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-color-scheme">‘prefers-color-scheme’</a> CSS 媒体查询，就是网站的 dark 版本 。 默认是 <code>navy</code>。                                                                                                                          |
| <strong>curly-quotes</strong>                     | 将直引号转换为反引号,除了代码块和代码 spans 中出现的引号。默认为<code>false</code>。                                                                                                                                                                                                                                                      |
| <strong>copy-fonts:</strong>                      | 复制 fonts.css 和 各自 font 文件到输出目录，和在默认主题使用它们。 默认为<code>true</code>。                                                                                                                                                                                                                                              |
| <strong>mathjax-support:</strong>                 | 增加对 <a href="format/configuration/mathjax.zh.html">MathJax</a> 的支持。 默认是<code>false</code>。                                                                                                                                                                                                                                                                       |
| <strong>google-analytics</strong>                 | 如果您使用 Google Analytics,则可以通过在配置文件中指定 ID 来启用此选项。                                                                                                                                                                                                                                                       |
| <strong>additional-css</strong>                   | 如果您需要稍微更改图书的外观，而不覆盖整个样式,则可以指定一组 css 样式表,这些样式表将在默认情况下加载,这样您就通过’外科手术’更改样式。                                                                                                                                                                                         |
| <strong>additional-js</strong>                    | 如果您需要在不删除当前行为的情况下，向书中添加某些行为,则可以指定一组，将与默认文件一起加载的 JavaScript 文件。                                                                                                                                                                                                                |
| <strong>no-section-label</strong>                 | 默认情况下,mdBook 在目录列中，添加章节标签编号。例如,“1.”,“2.1”。将此选项设置为 true 可禁用这些标签.默认为<code>false</code>。                                                                                                                                                                                                            |     |
| <strong>git-repository-url</strong>               | 这本书的 git 存储库的 URL。如果提供,将在书的菜单栏中，输出图标链接。                                                                                                                                                                                                                                                           |
| <strong>git-repository-icon</strong>              | 用于 git 存储库链接的 FontAwesome 图标类。默认为<code>fa-github</code>。看起来就像 <i class="fa fa-github"></i>。                                                                                                                                                                                                                         |
| <strong>edit-url-template:</strong>               | 编辑按钮, 提供 “编辑” 按钮 (看起来就像 <i class="fa fa-edit"></i>) ，方便定位到源代码的文档文件。例如：如果你是 Github 项目，设为 <code>https://github.com/&lt;owner&gt;/&lt;repo&gt;/edit/master/{path}</code> 或是 Bitbucket 项目，设为 <code>https://bitbucket.org/&lt;owner&gt;/&lt;repo&gt;/src/master/{path}?mode=edit</code> ，其中的 {path} 自然要修改成你的项目路径 |
| <strong>input-404:</strong>                       | 404 要展示的文件，文件后缀会换成 <code>html</code>。 默认为<code>404.md</code>。                                                                                                                                                                                                                                                                     |
| <strong>site-url:</strong>                        | 主页网址。确保网页的链接 和 script/css 为正确路径。默认为<code>/</code>。                                                                                                                                                                                                                                                                 |
| <strong>cname:</strong>                           | DNS 子域名 或是 apex 域名 。写入根目录下的 CNAME 文件中，就像 GitHub Pages 的 CNAME 一样 ( <a href="https://docs.github.com/en/github/working-with-github-pages/managing-a-custom-domain-for-your-github-pages-site"><em>管理你 GitHub Pages 的域名</em></a>).                                                                                                                                                                                     |</p>
<h3 id="outputhtmlprint"><a class="header" href="#outputhtmlprint"><code>[output.html.print]</code></a></h3>
<p><code>[output.html.print]</code> 定义打印式输出.
默认情况下，mdBook 给出打印按钮 (看起来就像 <i class="fa fa-print"></i>) ，将打印单页。</p>
<pre><code class="language-toml">[output.html.print]
enable = true    # 添加打印功能
</code></pre>
<ul>
<li><strong>enable:</strong> 启用打印。 默认为<code>true</code>。</li>
</ul>
<h3 id="outputhtmlfold"><a class="header" href="#outputhtmlfold"><code>[output.html.fold]</code></a></h3>
<p><code>[output.html.fold]</code> 能控制导航栏的折叠。</p>
<pre><code class="language-toml">[output.html.fold]
enable = false    # whether or not to enable section folding
level = 0         # the depth to start folding
</code></pre>
<ul>
<li><strong>enable:</strong> 默认是<code>false</code>。</li>
<li><strong>level:</strong> 开启折叠的层级。level 如果是 0, 全部折叠。默认为<code>0</code>。</li>
</ul>
<hr />
<h3 id="outputhtmlplayground"><a class="header" href="#outputhtmlplayground"><code>[output.html.playground]</code></a></h3>
<p><code>[output.html.playground]</code> 提供导入 Rust 代码，和与 <a href="https://play.rust-lang.org/">Rust Playground</a> 集成的功能。</p>
<pre><code class="language-toml">[output.html.playground]
editable = false         # allows editing the source code
copyable = true          # include the copy button for copying code snippets
copy-js = true           # includes the JavaScript for the code editor
line-numbers = false     # displays line numbers for editable code
</code></pre>
<table><thead><tr><th><code>[output.html.playground]</code>可用的配置选项表:</th><th>描述</th></tr></thead><tbody>
<tr><td><strong>editable</strong></td><td>允许编辑源代码。默认为<code>false</code>。</td></tr>
<tr><td><strong>copyable:</strong></td><td>复制按钮，默认为 <code>true</code>。</td></tr>
<tr><td><strong>copy-js</strong></td><td>将编辑器的 JavaScript 文件，复制到输出目录。默认为<code>true</code>。</td></tr>
<tr><td><strong>line-numbers</strong></td><td>显示行数，要求 <code>editable</code> 和 <code>copy-js</code> 都为 <code>true</code>。默认为 <code>false</code>。</td></tr>
</tbody></table>
<h3 id="outputhtmlsearch"><a class="header" href="#outputhtmlsearch"><code>[output.html.search]</code></a></h3>
<p><code>[output.html.search]</code> 控制 <a href="format/configuration/../../guide/reading.html#search">search</a> 的配置。
mdBook 需要 <code>search</code> 功能开启 (默认就有)。</p>
<pre><code class="language-toml">[output.html.search]
enable = true            # enables the search feature
limit-results = 30       # maximum number of search results
teaser-word-count = 30   # number of words used for a search result teaser
use-boolean-and = true   # multiple search terms must all match
boost-title = 2          # ranking boost factor for matches in headers
boost-hierarchy = 1      # ranking boost factor for matches in page names
boost-paragraph = 1      # ranking boost factor for matches in text
expand = true            # partial words will match longer terms
heading-split-level = 3  # link results to heading levels
copy-js = true           # include Javascript code for search
</code></pre>
<table><thead><tr><th><code>[output.html.search]</code>可用的配置选项表:</th><th>描述</th></tr></thead><tbody>
<tr><td><strong>enable</strong></td><td>启用搜索功能.默认为<code>true</code>。</td></tr>
<tr><td><strong>limit-results</strong></td><td>搜索结果的最大数量.默认为<code>30</code>。</td></tr>
<tr><td><strong>teaser-word-count</strong></td><td>搜索结果预告的单词数。默认为<code>30</code>。</td></tr>
<tr><td><strong>use-boolean-and</strong></td><td>定义多个搜索词之间的逻辑链接。如果为 true,则所有搜索词必须出现在每个结果中。默认为<code>true</code>。</td></tr>
<tr><td><strong>boost-title</strong></td><td>如果标题中出现搜索词,则提升搜索结果。默认为<code>2</code>。</td></tr>
<tr><td><strong>boost-hierarchy</strong></td><td>如果搜索结果出现在层次结构中,则提升搜索结果。层次结构包含父文档的所有标题，和所有父标题。默认为<code>1</code>。</td></tr>
<tr><td><strong>boost-paragraph</strong></td><td>如果搜索词出现在文本中,则提升搜索结果。默认为<code>1</code>。</td></tr>
<tr><td><strong>expand</strong></td><td>默认搜索匹配更长的结果。搜索<code>micro</code>应该匹配<code>microwave</code>。默认为<code>true</code>。</td></tr>
<tr><td><strong>heading-split-level</strong></td><td>搜索结果将链接到包含结果的文档部分。文档按此级别或更低级别划分为多个部分。默认为<code>3</code>.(<code>### This is a level 3 heading</code>)</td></tr>
<tr><td><strong>copy-js</strong></td><td>将搜索实现的 JavaScript 文件，复制到输出目录。默认为<code>true</code>。</td></tr>
</tbody></table>
<h3 id="outputhtmlredirect"><a class="header" href="#outputhtmlredirect"><code>[output.html.redirect]</code></a></h3>
<p><code>[output.html.redirect]</code> 添加跳转
用于你对一个页面的移动，重命名，移除，确保旧链接，跳转到新位置。</p>
<pre><code class="language-toml">[output.html.redirect]
&quot;/appendices/bibliography.html&quot; = &quot;https://rustc-dev-guide.rust-lang.org/appendix/bibliography.html&quot;
&quot;/other-installation-methods.html&quot; = &quot;../infra/other-installation-methods.html&quot;
</code></pre>
<p>key-value 格式，key 是需要跳转文件，来自构建目录的绝对路径。 (例如： <code>/appendices/bibliography.html</code>).
将要跳转到的位置 (例如：<code>https://rust-lang.org/</code>, <code>/overview.html</code>, or <code>../bibliography.html</code>).</p>
<p>生成跳转到新位置的 HTML 页面。
注意，是不支持 <code>#</code> 的网络链接定位的。</p>
<h3 id="markdown-渲染器"><a class="header" href="#markdown-渲染器">Markdown 渲染器</a></h3>
<p>Markdown 渲染器会运行预处理器，再输出结果的
Markdown。 最大的用途就是调试预处理器, 尤其是，可以结合 <code>mdbook test</code>看到，<code>mdbook</code> 传递给<code>rustdoc</code>的 Markdown 文本。</p>
<p>Markdown 渲染器 已包含在 <code>mdbook</code> ，但默认禁用。
启用方式，是在<code>book.toml</code>中，添加:</p>
<pre><code class="language-toml">[output.markdown]
</code></pre>
<p>现在还没有配置选项;
只能开和关</p>
<p>查看 <a href="format/configuration/renderers.zh.html#%E9%85%8D%E7%BD%AE,%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8">preprocessors 文档</a> ，关于如何指定哪个 preprocessors 应在 the Markdown renderer 之前运行。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="环境-变量"><a class="header" href="#环境-变量">环境 变量</a></h2>
<p>通过设置相应的环境变量，命令行的运行，覆盖到所有配置值。因为许多操作系统将环境变量限制为<code>_</code>字母数字字符，配置字段需要格式化成，正常情况的<code>foo.bar.baz</code>形式。</p>
<p>变量以<code>MDBOOK_</code>开头配置。通过删除<code>MDBOOK_</code>前缀，并将结果字符串转换为<code>kebab-case</code>。双下划线(<code>__</code>)变<code>.</code> ，而单个下划线(<code>_</code>)用短划线代替(<code>-</code>).</p>
<p>例如:</p>
<ul>
<li><code>MDBOOK_foo</code> -&gt; <code>foo</code></li>
<li><code>MDBOOK_FOO</code> -&gt; <code>foo</code></li>
<li><code>MDBOOK_FOO__BAR</code> -&gt; <code>foo.bar</code></li>
<li><code>MDBOOK_FOO_BAR</code> -&gt; <code>foo-bar</code></li>
<li><code>MDBOOK_FOO_bar__baz</code> -&gt; <code>foo-bar.baz</code></li>
</ul>
<p>所以通过设置<code>MDBOOK_BOOK__TITLE</code>环境变量，你可以覆盖书的标题，而无需修改你的<code>book.toml</code>.</p>
<blockquote>
<p><strong>注意</strong> 为了便于设置更复杂的配置项，首先将环境变量的值解析为 JSON，如果解析失败，则返回到字符串.</p>
<p>这意味着，如果您愿意，可以在构建书籍时覆盖所有书籍元数据</p>
<pre><code class="language-shell">$ export MDBOOK_BOOK=&quot;{'title': 'My Awesome Book', authors: ['Michael-F-Bryan']}&quot;
$ mdbook build
</code></pre>
</blockquote>
<p>后一种情况，在以下情况下可能有用，</p>
<ul>
<li>脚本或 CI 调用<code>mdbook</code>,</li>
<li>有时在构建前，无法更新<code>book.toml</code>。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="theme-1"><a class="header" href="#theme-1">Theme</a></h1>
<p>默认渲染器使用一个<a href="http://handlebarsjs.com/">handlebars</a>模板，用于渲染 markdown 文件,并 mdBook 二进制文件包含默认主题.</p>
<p>主题是完全可定制的,您可以通过在根目录<code>src</code>旁边，新建一个<code>theme</code>文件夹，在其中选择性地添加文件名称，覆盖主题的任意文件。</p>
<table><thead><tr><th>以下是您可以覆盖的文件:</th><th>描述</th></tr></thead><tbody>
<tr><td><strong>index.hbs</strong></td><td>hbs 模板.</td></tr>
<tr><td><strong><em>head.hbs</em></strong></td><td>HTML <code>&lt;head&gt;</code> 部分.</td></tr>
<tr><td><strong><em>header.hbs</em></strong></td><td>每个页面的头部</td></tr>
<tr><td>- <strong><em>css/</em></strong></td><td>样式文件</td></tr>
<tr><td>- <strong><em>css/chrome.css</em></strong></td><td>UI 元素</td></tr>
<tr><td>- <strong><em>css/general.css</em></strong></td><td>基础样式</td></tr>
<tr><td>- <strong><em>css/print.css</em></strong></td><td>打印输出的样式</td></tr>
<tr><td>- <strong><em>css/variables.css</em></strong></td><td>css 变量</td></tr>
<tr><td><strong>book.js</strong></td><td>主要用于添加客户端功能,如隐藏/取消隐藏侧边栏,更改主题,…</td></tr>
<tr><td><strong>highlight.js</strong></td><td>是用于突出显示代码片段的 JavaScript,您不需要修改它.</td></tr>
<tr><td><strong>highlight.css</strong></td><td>是用于代码突出显示的主题</td></tr>
<tr><td><strong>favicon.svg</strong></td><td>将使用的 favicon</td></tr>
</tbody></table>
<p>通常,当您想要调整主题时,您不需要覆盖所有文件。如果您只需要更改 css 样式表,那么覆盖所有其他文件是没有意义的。由于自定义文件优先于内置文件，那以后的新的修补程序/功能，你都更新不了。</p>
<p><strong>注意:</strong> 覆盖文件时,可能会破坏某些功能。因此,我建议使用默认主题中的文件作为模板,只添加/修改您需要的内容。您可以使用<code>mdbook init --theme</code>命令自动将默认主题自动复制到源目录中，只需删除您不想覆盖的文件。</p>
<p><code>mdbook init --theme</code> 不会创建上面所提到的文件。
比如 <code>head.hbs</code>文件，是没有同等（示例）文件。
所以，你需要自行完成创建。</p>
<p>如果你想完全替换内置主题，请在
<a href="format/theme/../configuration/renderers.zh.html#html-renderer-options"><code>output.html.preferred-dark-theme</code></a>设置，不然默认还是 <code>navy</code> 主题</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="indexhbs"><a class="header" href="#indexhbs">index.hbs</a></h1>
<p><code>index.hbs</code>是用于渲染书籍的 hbs 模板。markdown 文件被处理为 html,然后注入该模板.</p>
<p>如果您想更改图书的布局或样式,您可能需要稍微修改此模板。那下面是你需要知道的。</p>
<h2 id="data"><a class="header" href="#data">Data</a></h2>
<p>大量数据通过“上下文“暴露给 hbs 模板.在 hbs 模板中,您可以使用以下方式访问此信息</p>
<pre><code class="language-handlebars">{{name_of_property}}
</code></pre>
<p>以下是公开的属性列表:</p>
<ul>
<li><strong>language</strong> |&gt; 书的语言<code>en</code>。例如<code>&lt;code class=&quot;language-html&quot;&gt;\\&lt;html lang=&quot;{{ language }}&quot;&gt;&lt;/code&gt;</code>。</li>
<li><strong>title</strong> |&gt; 该书的标题，如<code>book.toml</code>中所述</li>
<li><strong>chapter_title</strong> |&gt; 当前章节的标题，格式是 <code>{{ chapter_title }} - {{ book_title }}</code>，除非 unless <code>book_title</code> 没有设置，这种情况下，默认为 <code>chapter_title</code>。</li>
<li><strong>path</strong> |&gt; 源目录中原始 markdown 文件的相对路径</li>
<li><strong>content</strong> |&gt; 这是渲染的 markdown.</li>
<li><strong>path_to_root</strong> |&gt; 这是一条完全包含<code>../</code>的路径，这会是从当前文件指向书的根。由于维护了原始目录结构，因此使用此前缀相对链接很有用.</li>
<li><strong>chapters</strong> |&gt; 是一个字典数组</li>
</ul>
<pre><code class="language-json">{
  &quot;section&quot;: &quot;1.2.1&quot;,
  &quot;name&quot;: &quot;name of this chapter&quot;,
  &quot;path&quot;: &quot;dir/markdown.md&quot;
}
</code></pre>
<p>包含本书的所有章节.它用于例如构建目录(侧边栏).</p>
<h2 id="handlebars-帮手"><a class="header" href="#handlebars-帮手">Handlebars 帮手</a></h2>
<p>除了您可以访问的属性外,您还可以使用一些 hbs 帮手.</p>
<h3 id="1-toc"><a class="header" href="#1-toc">1. toc</a></h3>
<pre><code>toc助手就像这样使用

```handlebars
{{#toc}}{{/toc}}
```

并输出看起来像这样的东西，这取决于你的书的结构

```html
&lt;ul class=&quot;chapter&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;link/to/file.html&quot;&gt;Some chapter&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;
        &lt;ul class=&quot;section&quot;&gt;
            &lt;li&gt;&lt;a href=&quot;link/to/other_file.html&quot;&gt;Some other Chapter&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/li&gt;
&lt;/ul&gt;
```

如果您想使用其他结构创建一个toc，则可以访问包含所有数据的chapters属性。
目前唯一的限制是您必须使用JavaScript,而不是使用hbs帮助程序。

```html
&lt;script&gt;
var chapters = {{chapters}};
// Processing here
&lt;/script&gt;
```
</code></pre>
<h3 id="2-previous--next"><a class="header" href="#2-previous--next">2. previous / next</a></h3>
<pre><code>上一个和下一个助手将`link`和`name`属性暴露给前一章和下一章。

就像这样使用

```handlebars
{{#previous}}
    &lt;a href=&quot;{{link}}&quot; class=&quot;nav-chapters previous&quot;&gt;
        &lt;i class=&quot;fa fa-angle-left&quot;&gt;&lt;/i&gt;
    &lt;/a&gt;
{{/previous}}
```

只有在前一个/下一个章节存在时,才会渲染内部html。
当然内部html可以根据自己的喜好进行更改。
</code></pre>
<hr />
<p><em>如果您希望其他属性或帮手,请<a href="https://github.com/rust-lang/mdBook/issues">create a new
issue</a></em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="语法高亮"><a class="header" href="#语法高亮">语法高亮</a></h1>
<p>mdBook 使用<a href="https://highlightjs.org">Highlight.js</a>自定义主题，完成语法高亮的功能。</p>
<p>自动语言检测已关闭，因此您可能希望指定您使用的编程语言</p>
<pre><code class="language-markdown">```rust
fn main() {
    // Some code
}
```
</code></pre>
<h2 id="supported-languages"><a class="header" href="#supported-languages">Supported languages</a></h2>
<p>这些是默认支持的语言，你还可以通过应用你的<code>highlight.js</code> 文件，达到添加的作用:</p>
<ul>
<li>apache</li>
<li>armasm</li>
<li>bash</li>
<li>c</li>
<li>coffeescript</li>
<li>cpp</li>
<li>csharp</li>
<li>css</li>
<li>d</li>
<li>diff</li>
<li>go</li>
<li>handlebars</li>
<li>haskell</li>
<li>http</li>
<li>ini</li>
<li>java</li>
<li>javascript</li>
<li>json</li>
<li>julia</li>
<li>kotlin</li>
<li>less</li>
<li>lua</li>
<li>makefile</li>
<li>markdown</li>
<li>nginx</li>
<li>objectivec</li>
<li>perl</li>
<li>php</li>
<li>plaintext</li>
<li>properties</li>
<li>python</li>
<li>r</li>
<li>ruby</li>
<li>rust</li>
<li>scala</li>
<li>scss</li>
<li>shell</li>
<li>sql</li>
<li>swift</li>
<li>typescript</li>
<li>x86asm</li>
<li>xml</li>
<li>yaml</li>
</ul>
<h2 id="自定义主题"><a class="header" href="#自定义主题">自定义主题</a></h2>
<p>与主题的其余部分一样,用于语法突出显示的 css，可以使用您自己的文件覆盖.</p>
<ul>
<li><strong><em>highlight.js</em></strong> 通常你不应该覆盖这个文件,除非你想使用更新的版本.</li>
<li><strong><em>highlight.css</em></strong> highlight.js 用于语法高亮的主题.</li>
</ul>
<p>如果你想使用<code>highlight.js</code>另一个主题,可从他们的网站下载,或自己制作,重命名为<code>highlight.css</code>，并把它放进去根目录下的<code>theme</code></p>
<p>现在将使用您的主题，而不是默认主题.</p>
<h2 id="隐藏代码行数"><a class="header" href="#隐藏代码行数">隐藏代码行数</a></h2>
<p>mdBook 中有一个功能,可以通过在代码行前加上来隐藏代码行<code>#</code>.</p>
<pre><code class="language-bash"># fn main() {
    let x = 5;
    let y = 6;

    println!(&quot;{}&quot;, x + y);
# }
</code></pre>
<p>将渲染为</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">fn main() {
</span>    let x = 5;
    let y = 7;

    println!(&quot;{}&quot;, x + y);
<span class="boring">}
</span></code></pre></pre>
<p><strong>目前,这仅适用于带注释的代码示例<code>rust</code>。因为它会与某些编程语言的语义冲突.在未来,我们希望通过这个，可在<code>book.toml</code>配置，这样每个人都可以从中受益.</strong></p>
<h2 id="加强默认主题"><a class="header" href="#加强默认主题">加强默认主题</a></h2>
<p>如果您认为默认主题看起来不适合特定语言,或者可以改进。随意地<a href="https://github.com/rust-lang/mdBook/issues">submit a new
issue</a>解释你的想法，我会看看它.</p>
<p>您还可以使用建议的改进创建拉取请求.</p>
<p>总的来说，主题应该是清淡和清醒，没有许多华丽的颜色.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="编辑器"><a class="header" href="#编辑器">编辑器</a></h1>
<p>除了提供可运行的代码 playgrounds 之外，mdBook 还可以选择进行编辑。为了启用可编辑的代码块，需要添加以下内容到**<em>book.toml</em>**:</p>
<pre><code class="language-toml">[output.html.playground]
editable = true
</code></pre>
<p>要使特定块可用于编辑，请使用该属性<code>editable</code>添加:</p>
<pre><code class="language-markdown">```rust,editable
fn main() {
    let number = 5;
    print!(&quot;{}&quot;, number);
}
```
</code></pre>
<p>注意新的<code>Undo Changes</code>的按钮会出现在可编辑的 playgrounds 中.</p>
<h2 id="定制编辑器"><a class="header" href="#定制编辑器">定制编辑器</a></h2>
<p>默认情况下，编辑器是<a href="https://ace.c9.io/">Ace</a>编辑器，但是，如果需要，可以通过提供不同的文件夹来覆盖功能:</p>
<pre><code class="language-toml">[output.html.playground]
editable = true
editor = &quot;/path/to/editor&quot;
</code></pre>
<p>请注意，要让编辑器更改正常运行，<code>book.js</code>里面的<code>theme</code>文件夹，你需要覆盖下，因为它与默认的 Ace 编辑器有一些耦合.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mathjax-支持"><a class="header" href="#mathjax-支持">MathJax 支持</a></h1>
<p>mdBook，可选的支持数学方程式<a href="https://www.mathjax.org/">MathJax</a>.</p>
<p>要启用 MathJax,您需要在<code>book.toml</code>中的<code>output.html</code>部分添加<code>mathjax-support</code>，.</p>
<pre><code class="language-toml">[output.html]
mathjax-support = true
</code></pre>
<blockquote>
<p><strong>注意:</strong> MathJax 使用的常用分隔符尚不支持.你目前无法使用<code>$$ ... $$</code>作为分隔符和<code>\[ ... \]</code>分隔符需要额外的反斜杠才能工作。希望这个限制很快就会解除.</p>
<p><strong>注意:</strong> 在 MathJax 块中使用双反斜杠时(例如在诸如<code>\begin{cases} \frac 1 2 \\ \frac 3 4 \end{cases}</code>之类的命令中)你需要添加<em>另外两个</em>反斜杠(例如,<code>\begin{cases} \frac 1 2 \\\\ \frac 3 4 \end{cases}</code>).</p>
</blockquote>
<h3 id="内联方程"><a class="header" href="#内联方程">内联方程</a></h3>
<p>内联方程由以下分隔<code>\\(</code>和<code>\\)</code>。例如,渲染以下内联方程\(\ int x dx = \ frac {x ^ 2} {2} + C.\)，你要写下面的内容:</p>
<pre><code>\\( \int x dx = \frac{x^2}{2} + C \\)
</code></pre>
<h3 id="块方程"><a class="header" href="#块方程">块方程</a></h3>
<p>块方程由以下分隔<code>\\[</code>和<code>\\]</code>.要渲染以下等式</p>
<p>\[\ mu = \ frac {1}{ }N\ _{ sum= }i _ 0\ xi]</p>
<p>你会写:</p>
<pre><code class="language-bash">\\[ \mu = \frac{1}{N} \sum_{i=0} x_i \\]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mdbook-特有-markdown"><a class="header" href="#mdbook-特有-markdown">mdBook 特有 markdown</a></h1>
<h2 id="隐藏代码行数-1"><a class="header" href="#隐藏代码行数-1">隐藏代码行数</a></h2>
<p>mdBook 中有一个功能，可以通过在代码行前加上<code>#</code>来隐藏代码行，<a href="https://doc.rust-lang.org/stable/rustdoc/documentation-tests.html#hiding-portions-of-the-example">像在 Rustdoc 一样</a>。目前只适用 Rust 代码。</p>
<pre><code class="language-bash"># fn main() {
    let x = 5;
    let y = 6;

    println!(&quot;{}&quot;, x + y);
# }
</code></pre>
<p>渲染为</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">fn main() {
</span>    let x = 5;
    let y = 6;

    println!(&quot;{}&quot;, x + y);
<span class="boring">}
</span></code></pre></pre>
<p>这个代码块会有一个眼睛的图标 (<i class="fa fa-eye"></i>) ，控制那些隐藏的代码行。</p>
<h2 id="rust-playground"><a class="header" href="#rust-playground">Rust Playground</a></h2>
<p>Rust language 会有一个 (<i class="fa fa-play"></i>) w 按钮，调用 API，执行 rust 代码。
具体是发送给 <a href="https://play.rust-lang.org/">Rust Playground</a>，从而获取结果。</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;Hello, World!&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>如果没有 <code>main</code> 函数，自动包裹进入。</p>
<p>不想有运行按钮，你要加上 <code>noplayground</code> ：</p>
<pre><code class="language-markdown">```rust,noplayground
let mut name = String::new();
std::io::stdin().read_line(&amp;mut name).expect(&quot;failed to read line&quot;);
println!(&quot;Hello {}!&quot;, name);
```
</code></pre>
<h2 id="rust-code-block-attributes"><a class="header" href="#rust-code-block-attributes">Rust code block attributes</a></h2>
<p>额外的选项，可以通过 逗号，空格，tab 分隔。例如：</p>
<pre><code class="language-markdown">```rust,ignore
# This example won't be tested.
panic!(&quot;oops!&quot;);
```
</code></pre>
<p>用<a href="format/../cli/test.zh.html"><code>mdbook test</code></a> 去测试 Rust 代码时，尤为重要。
会用到与 <a href="https://doc.rust-lang.org/rustdoc/documentation-tests.html#attributes">rustdoc attributes</a>相同的选项，如下：</p>
<ul>
<li><code>editable</code> — 启用 <a href="format/theme/editor.zh.html">editor</a>。</li>
<li><code>noplayground</code> — 移除运行按钮，但仍会测试。</li>
<li><code>mdbook-runnable</code> — 强制具备，运行按钮
主要是搭配<code>ignore</code> 使用。例如代码没有被测试, 但你又想运行它。</li>
<li><code>ignore</code> — 既不测试，也不能运行，只剩下语法高亮。</li>
<li><code>should_panic</code> — 应该给出一个 panic</li>
<li><code>no_run</code> — 测试时编译，但不运行。
运行按钮也不会出现。</li>
<li><code>compile_fail</code> — 代码应该编译失败。</li>
<li><code>edition2015</code>, <code>edition2018</code>, <code>edition2021</code> — 强制使用特定的版本。
可以用 <a href="format/configuration/general.zh.html#rust-options"><code>rust.edition</code></a> ，全局设置。</li>
</ul>
<h2 id="include包含文件内容"><a class="header" href="#include包含文件内容">include，包含文件内容</a></h2>
<p>使用以下语法，您可以将文件包含到您的书中:</p>
<pre><code class="language-hbs">{{#include file.rs}}
</code></pre>
<p>文件的路径必须是 <strong>当前</strong> 源文件的 <strong>相对</strong> 路径.</p>
<p>通常，此命令用于包含代码段和示例。在这种情况下， 可指定文件的包含部分，例如其中只包含示例的相关行.</p>
<p>mdBook 会将 include 文件 解释成 markdown。 自从 include 命令常用来插入代码片段和示例，你会习惯使用 <code>```</code> 包裹这些命令，显示（include）文件的内容，而不是去解释它们。</p>
<pre><code class="language-hbs">```
{{#include file.rs}} ```
</code></pre>
<h2 id="只-include-一个文件的部分内容"><a class="header" href="#只-include-一个文件的部分内容">只 Include 一个文件的部分内容</a></h2>
<p>常见要求是你只要文件的部分内容 e.g. 以行编号作为例子。我们对部分内容插入，支持了几种模式:</p>
<pre><code class="language-hbs">{{#include file.rs:2}}
{{#include file.rs::10}}
{{#include file.rs:2:}}
{{#include file.rs:2:10}}
</code></pre>
<p>我们支持四种不同的决定<code>file.rs</code>部分模式:</p>
<ul>
<li>第一个命令仅包含文件中的第二行.</li>
<li>第二个命令包含直到第 10 行的所有行。即，从 11 到文件末尾的行被省略.</li>
<li>第三个命令包含第 2 行的所有行，即省略第一行.</li>
<li>最后一个命令包含摘录<code>file.rs</code>由 2 到 10 行组成.</li>
</ul>
<p>为了防止文件的修改（行数的变化），导致图书呈现内容的变化， 你还可以使用锚点(anchor)，选择一个特定的部分，
行数就不再相关。
一个 anchor 是一对匹配的行。 匹配的内容正是正则式，如开头的行 anchor 必须匹配 <code>ANCHOR:\s*[\w_-]+</code> and similarly 结尾行则是 <code>ANCHOR_END:\s*[\w_-]+</code>。只要内容匹配了，注释的写法格式倒是没有限制。</p>
<p>考虑下面 要 include 的文件:</p>
<pre><code class="language-rs">/* ANCHOR: all */

// ANCHOR: component
struct Paddle {
    hello: f32,
}
// ANCHOR_END: component

////////// ANCHOR: system
impl System for MySystem { ... }
////////// ANCHOR_END: system

/* ANCHOR_END: all */
</code></pre>
<p>给个示例，你要做的:</p>
<pre><code class="language-hbs">Here is a component: ```rust,no_run,noplayground
{{#include file.rs:component}} ``` Here is a system:
```rust,no_run,noplayground
{{#include file.rs:system}} ``` This is the full file.
```rust,no_run,noplayground
{{#include file.rs:all}} ```
</code></pre>
<p>在已 include anchor 内的，若还包含 anchor 匹配模式，则会被忽略。</p>
<h2 id="including-a-file-but-initially-hiding-all-except-specified-lines"><a class="header" href="#including-a-file-but-initially-hiding-all-except-specified-lines">Including a file but initially hiding all except specified lines</a></h2>
<p><code>rustdoc_include</code> 带有行数，与锚点的属性，其他的就与 <code>include</code> 一样。</p>
<p>被过滤的行数，仍会被包含进去，只不过用<code>#</code>隐藏了而已。你完全可以显示，隐藏的代码，而 <code>mdbook test</code>依旧是执行完全的代码。</p>
<p>例如，<code>file.rs</code> 包含下面的 Rust 代码:</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
    let x = add_one(2);
    assert_eq!(x, 3);
}

fn add_one(num: i32) -&gt; i32 {
    num + 1
}
</code></pre></pre>
<p>只显示第二行:</p>
<pre><code class="language-hbs">To call the `add_one` function, we pass it an `i32` and bind the returned value
to `x`: ```rust
{{#rustdoc_include file.rs:2}} ```
</code></pre>
<p>用<code>#</code>完成相同的效果:</p>
<pre><code class="language-hbs">To call the `add_one` function, we pass it an `i32` and bind the returned value
to `x`: ```rust # fn main() { let x = add_one(2); # assert_eq!(x, 3); # } # # fn
add_one(num: i32) -&gt; i32 { # num + 1 # } ```
</code></pre>
<p>可以通过点击 ( “expand” 按钮看到剩下的文件):</p>
<pre><pre class="playground"><code class="language-rust edition2018"><span class="boring">fn main() {
</span>    let x = add_one(2);
<span class="boring">    assert_eq!(x, 3);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn add_one(num: i32) -&gt; i32 {
</span><span class="boring">    num + 1
</span><span class="boring">}
</span></code></pre></pre>
<h2 id="插入可运行的-rust-文件"><a class="header" href="#插入可运行的-rust-文件">插入可运行的 Rust 文件</a></h2>
<p>使用以下语法,您可以将可运行的 Rust 文件插入到您的书中:</p>
<pre><code class="language-hbs">{{#playground file.rs}}
</code></pre>
<p>Rust 文件的路径必须是当前源文件的相对路径.</p>
<p>点击播放后,代码段将被发送到<a href="https://play.rust-lang.org/">rust 的游乐场</a>编译和运行。结果被返回，并直接显示在代码下方.</p>
<p>以下是代码段的渲染的样子:</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
    println!(&quot;Hello World!&quot;);
<span class="boring">
</span><span class="boring">   // You can even hide lines! :D
</span><span class="boring">  println!(&quot;I am hidden! Expand the code snippet to see me&quot;);
</span>}
</code></pre></pre>
<blockquote>
<p>试试 点击 播放箭头</p>
</blockquote>
<h3 id="要可编辑请添加"><a class="header" href="#要可编辑请添加">要可编辑，请添加</a></h3>
<pre><code class="language-hbs">{{#playground example.rs editable no_run should_panic}}
</code></pre>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    println!(&quot;Hello World!&quot;);
<span class="boring">
</span><span class="boring">   // You can even hide lines! :D
</span><span class="boring">  println!(&quot;I am hidden! Expand the code snippet to see me&quot;);
</span>}
</code></pre></pre>
<p>额外属性的添加：<code>{{#playground example.rs editable}}</code> ，它会变成:</p>
<pre><code class="language-markdown">```rust,editable
# Contents of example.rs here.
```
</code></pre>
<p><code>editable</code> 会启用 <a href="format/theme/editor.zh.html">editor</a> ，就像<a href="format/mdbook.zh.html#rust-code-block-attributes">Rust code block attributes</a>所描述的。</p>
<h2 id="controlling-page-title"><a class="header" href="#controlling-page-title">Controlling page &lt;title&gt;</a></h2>
<p>可以用 &lt;title&gt; 改变边栏的标题：</p>
<pre><code class="language-hbs">{{#title My Title}}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="markdown"><a class="header" href="#markdown">Markdown</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="在持续集成服务器中运行-mdbook"><a class="header" href="#在持续集成服务器中运行-mdbook">在持续集成服务器中运行 <code>mdbook</code></a></h1>
<p>有几种集成服务器（CI），比如： <a href="https://docs.github.com/en/actions">GitHub Actions</a> or <a href="https://docs.gitlab.com/ee/ci/">GitLab CI/CD</a> ，它们的作用是自动测试和发布你的文档。</p>
<p>接下来，有几个方式配置这些服务器。
更多信息，可看 <a href="https://github.com/rust-lang/mdBook/wiki/Automated-Deployment">Automated Deployment</a> 。</p>
<h3 id="pre-compiled-binaries-1"><a class="header" href="#pre-compiled-binaries-1">Pre-compiled binaries</a></h3>
<p>最简单的方式，莫过于去 <a href="https://github.com/rust-lang/mdBook/releases">GitHub Releases page</a>，下载执行文件。
使用 <code>curl</code> 快速下载:</p>
<pre><code class="language-sh">mkdir bin
curl -sSL https://github.com/rust-lang/mdBook/releases/download/v0.4.15/mdbook-v0.4.15-x86_64-unknown-linux-gnu.tar.gz | tar -xz --directory=bin
bin/mdbook build
</code></pre>
<p>这个方法的几个特点:</p>
<ul>
<li>够快，没有什么缓存。</li>
<li>不用安装 Rust。</li>
<li>需要自己手动更新
当然，如果是要锁定某个版本的话，这是一个优势。
然而，自动更新，也是许多人想要的。</li>
<li>搭上 GitHub CDN。</li>
</ul>
<h3 id="building-from-source"><a class="header" href="#building-from-source">Building from source</a></h3>
<p>这个方式，要求安装了 Rust。
会有些服务器是安装的, 但如果没有，你需要加安装 Rust 的步骤。</p>
<p>一旦 Rust 安装上了, <code>cargo install</code> 下载和构建 mdBook。.
强烈建议使用 SemVer 版本语法，这样你就能得到一个 <strong>non-breaking</strong> 版本的 mdBook。
For example:</p>
<pre><code class="language-sh">cargo install mdbook --no-default-features --features search --vers &quot;^0.4&quot; --locked
</code></pre>
<p>其中，包含了几项建议:</p>
<ul>
<li>
<p><code>--no-default-features</code> — 禁掉默认功能，比如：<code>mdbook serve</code>命令需要的 HTTP server，这些在 CI 上都是不需要的。加速构建。</p>
</li>
<li>
<p><code>--features search</code> — 禁用了默认功能，意味着你要指定功能，比如，搜寻 <a href="guide/reading.zh.html#search">search</a> 就挺有用的。</p>
</li>
<li>
<p><code>--vers &quot;^0.4&quot;</code> — 会下载与 <code>0.4</code> 最为接近的版本。
但是，像 <code>0.5.0</code>之后的版本就不会安装。因为，它们有可能不兼容。
Cargo 会帮你自动升级。</p>
</li>
<li>
<p><code>--locked</code> — 锁定依赖的版本，要是没有 <code>--locked</code>, 所有的依赖就会用最新的版本。即可能是 bug 修复，也可能导致构建问题。</p>
</li>
</ul>
<p>最好看看，关于缓存的选项，能帮你的构建节省时间。</p>
<h2 id="running-tests"><a class="header" href="#running-tests">Running tests</a></h2>
<p><a href="cli/test.md.html"><code>mdbook test</code></a> 会测试你的 Rust 测试代码。也用来测试书内的代码示例。</p>
<p>这个方式，要求安装了 Rust。
会有些服务器是安装的, 但如果没有，你需要加安装 Rust 的步骤。</p>
<p>除了，恰当的 Rust 版本，和<code>mdbook test</code>，你已然不需要其他的了。</p>
<p>当然，若是你像运行其他测试，像 <a href="https://github.com/Michael-F-Bryan/mdbook-linkcheck#continuous-integration">mdbook-linkcheck</a> 检查，网络链接的完整.
或是 样式，拼写啊，杂七杂八的测试啊，都可以在 CI 上，搞定。</p>
<h2 id="deploying"><a class="header" href="#deploying">Deploying</a></h2>
<p>自动发布的功能，有些人希望每次改变就来一次；当然，也特殊 tag 再来一次，这些都可以做到。</p>
<p>或许，你还想了解下，如何推送新改变的。
例如, <a href="https://docs.github.com/en/pages">GitHub Pages</a> 仅仅像正常 push 下，就自动搞定。</p>
<p>下一步，自然是 <code>mdbook build</code>，生成内容，输出到目标目录 (默认是，当地的 <code>book</code> 目录) 。</p>
<p>更多请看 <a href="https://github.com/rust-lang/mdBook/wiki/Automated-Deployment">Automated Deployment</a> ，上面有多个不同示例。</p>
<h3 id="404-handling"><a class="header" href="#404-handling">404 handling</a></h3>
<p>错误链接就给 404 页面。默认名称就是 <code>404.html</code> 。
像 <a href="https://docs.github.com/en/pages">GitHub Pages</a> ，就会自动跳转。
其他，可能需要配置配置。</p>
<p>如果你的书，不是放置在顶层网址上，那么 <a href="format/configuration/renderers.zh.html#html-renderer-options"><code>output.html.site-url</code></a> 必不可少。
书用到的静态文件 (like CSS) ，都是需要正确获取的。
就好比，这本书 <a href="https://chinanf-boy.github.io/mdBook-zh/">https://chinanf-boy.github.io/mdBook-zh/</a>, 那么 <code>site-url</code> 就是：</p>
<pre><code class="language-toml"># book.toml
[output.html]
site-url = &quot;/mdBook-zh/&quot;
</code></pre>
<p>自定义 404 页面也是可以的，比如： <code>src/404.md</code>。
当然，对应要配置下<a href="format/configuration/renderers.zh.html#html-renderer-options"><code>output.html.input-404</code></a> 。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="致-developers"><a class="header" href="#致-developers">致 Developers</a></h1>
<p>虽然<code>mdbook</code>主要用作命令行工具, 但您也可以直接导入底层库，并使用它来管理书籍。它还具有相当灵活的插件机制，允许您创建自己的自定义工具和消费者(通常称为<em>后端</em>)，如果您需要对书籍进行一些分析，或以不同的格式渲染它.</p>
<p>该 <em>对于开发人员</em> 章节在这里向您展示<code>mdbook</code>更高级的用法.</p>
<p>开发人员可以通过以下两种方式，影响本书的构建过程,</p>
<ul>
<li><a href="for_developers/preprocessors.zh.html">Preprocessors-预处理器</a></li>
<li><a href="for_developers/backends.zh.html">Alternate Backends - 备用后端</a></li>
</ul>
<h2 id="构建过程"><a class="header" href="#构建过程">构建过程</a></h2>
<p>渲染图书项目的过程经历了几个步骤.</p>
<ol>
<li>加载书
<ul>
<li>解析<code>book.toml</code>。 如果其中不存在，使用<code>Config</code>默认值。</li>
<li>将书籍章节加载到内存中</li>
<li>了解应该使用哪些预处理器/后端</li>
</ul>
</li>
<li>对于每个后端：
<ol>
<li>运行所有的预处理器</li>
<li>调用后端，渲染处理过的结果</li>
</ol>
</li>
</ol>
<h2 id="mdbook作为库使用"><a class="header" href="#mdbook作为库使用"><code>mdbook</code>作为库使用</a></h2>
<p><code>mdbook</code>二进制只是一个<code>mdbook</code>箱的包装器，将其功能暴露出来，作为命令行程序。因此，很容易自制使用<code>mdbook</code>的程序，并添加自己的功能(例如自定义预处理器)或调整构建过程。</p>
<p>如何找到使用<code>mdbook</code>箱子最简单方法，答案就是<a href="https://docs.rs/mdbook/*/mdbook/">API 文档</a>。顶级 API 文档解释了如何使用<a href="https://docs.rs/mdbook/*/mdbook/book/struct.MDBook.html"><code>MDBook</code></a>类型，加载和构建一本书，而<a href="https://docs.rs/mdbook/*/mdbook/config/index.html">config</a>模块很好地解释了配置系统。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="preprocessors"><a class="header" href="#preprocessors">Preprocessors</a></h1>
<p>一个 <em>预处理器</em> 只是一些代码，运行在加载书之后，和渲染之前，允许您更新和改变本书。可能的用例是:</p>
<ul>
<li>创建自定义帮助程序<code>{{#include /path/to/file.md}}</code></li>
<li>用 latex 样式(<code>$$ \frac{1}{3} $$</code>)的表达式代替为 mathjax 的等价物</li>
</ul>
<p><a href="for_developers/../format/configuration/preprocessors.zh.html">配置 预处理器</a> 获取更多信息。</p>
<h2 id="勾住-mdbook"><a class="header" href="#勾住-mdbook">勾住 MDBook</a></h2>
<p>MDBook 使用一种相当简单的机制来发现第三方插件。<code>book.toml</code>添加了一个新表格(例如<code>preprocessor.foo</code>，给<code>foo</code>预处理器)，然后<code>mdbook</code>将尝试调用<code>mdbook-foo</code>程序，作为构建过程的一部分.</p>
<p>一旦预处理器定义了，和构建过程开始，mdBook 会执行<code>preprocessor.foo.command</code>命令两次。
第一次是，预处理器检测出是否支持所给予的渲染器。
mdBook 会传递两个参数: 第一个是 <code>supports</code> 和第二个参数是渲染器的名字。
支持的话，状态就是 0；不然退出代码为非零。</p>
<p>如果支持， 那么 mdbook 开启命令的第二次运行， 将 JSON 数据传递到 stdin。
The JSON 的组成是一个 <code>[context, book]</code> 数组 ( <code>context</code> 是序列化对象 <a href="https://docs.rs/mdbook/latest/mdbook/preprocess/struct.PreprocessorContext.html"><code>PreprocessorContext</code></a>) 和 <code>book</code> (是一个<a href="https://docs.rs/mdbook/latest/mdbook/book/struct.Book.html"><code>Book</code></a> 包含书的内容)。</p>
<p>预处理器应该返回 <a href="https://docs.rs/mdbook/latest/mdbook/book/struct.Book.html"><code>Book</code></a> 对象的 JSON 格式到 stdout，带有它对内容的修改。</p>
<p>最简单的入门方法是创建自己的实现<code>Preprocessor</code> trait(例如在<code>lib.rs</code>)，然后创建一个 shell 二进制文件，将输入转换为正确的<code>Preprocessor</code>方法。为方便起见，有个<a href="https://github.com/rust-lang/mdBook/blob/master/examples/nop-preprocessor.rs">无操作预处理器:示例</a>在<code>examples/</code>目录，可以很容易地适应其他预处理器.</p>
<details>
<summary>Example 无操作预处理器</summary>
<pre><pre class="playground"><code class="language-rust edition2018">// nop-preprocessors.rs

extern crate clap;
extern crate mdbook;
extern crate serde_json;

use clap::{App, Arg, ArgMatches, SubCommand};
use mdbook::book::Book;
use mdbook::errors::Error;
use mdbook::preprocess::{CmdPreprocessor, Preprocessor, PreprocessorContext};
use std::io;
use std::process;
use nop_lib::Nop;

pub fn make_app() -&gt; App&lt;'static, 'static&gt; {
    App::new(&quot;nop-preprocessor&quot;)
        .about(&quot;A mdbook preprocessor which does precisely nothing&quot;)
        .subcommand(
            SubCommand::with_name(&quot;supports&quot;)
                .arg(Arg::with_name(&quot;renderer&quot;).required(true))
                .about(&quot;Check whether a renderer is supported by this preprocessor&quot;))
}

fn main() {
    let matches = make_app().get_matches();

    // Users will want to construct their own preprocessor here
    let preprocessor = Nop::new();

    if let Some(sub_args) = matches.subcommand_matches(&quot;supports&quot;) {
        handle_supports(&amp;preprocessor, sub_args);
    } else {
        if let Err(e) = handle_preprocessing(&amp;preprocessor) {
            eprintln!(&quot;{}&quot;, e);
            process::exit(1);
        }
    }
}

fn handle_preprocessing(pre: &amp;dyn Preprocessor) -&gt; Result&lt;(), Error&gt; {
    let (ctx, book) = CmdPreprocessor::parse_input(io::stdin())?;

    if ctx.mdbook_version != mdbook::MDBOOK_VERSION {
        // We should probably use the `semver` crate to check compatibility
        // here...
        eprintln!(
            &quot;Warning: The {} plugin was built against version {} of mdbook, \
             but we're being called from version {}&quot;,
            pre.name(),
            mdbook::MDBOOK_VERSION,
            ctx.mdbook_version
        );
    }

    let processed_book = pre.run(&amp;ctx, book)?;
    serde_json::to_writer(io::stdout(), &amp;processed_book)?;

    Ok(())
}

fn handle_supports(pre: &amp;dyn Preprocessor, sub_args: &amp;ArgMatches) -&gt; ! {
    let renderer = sub_args.value_of(&quot;renderer&quot;).expect(&quot;Required argument&quot;);
    let supported = pre.supports_renderer(&amp;renderer);

    // Signal whether the renderer is supported by exiting with 1 or 0.
    if supported {
        process::exit(0);
    } else {
        process::exit(1);
    }
}

/// The actual implementation of the `Nop` preprocessor. This would usually go
/// in your main `lib.rs` file.
mod nop_lib {
    use super::*;

    /// A no-op preprocessor.
    pub struct Nop;

    impl Nop {
        pub fn new() -&gt; Nop {
            Nop
        }
    }

    impl Preprocessor for Nop {
        fn name(&amp;self) -&gt; &amp;str {
            &quot;nop-preprocessor&quot;
        }

        fn run(
            &amp;self,
            ctx: &amp;PreprocessorContext,
            book: Book,
        ) -&gt; Result&lt;Book, Error&gt; {
            // In testing we want to tell the preprocessor to blow up by setting a
            // particular config value
            if let Some(nop_cfg) = ctx.config.get_preprocessor(self.name()) {
                if nop_cfg.contains_key(&quot;blow-up&quot;) {
                    return Err(&quot;Boom!!1!&quot;.into());
                }
            }

            // we *are* a no-op preprocessor after all
            Ok(book)
        }

        fn supports_renderer(&amp;self, renderer: &amp;str) -&gt; bool {
            renderer != &quot;not-supported&quot;
        }
    }
}

</code></pre></pre>
</details>
<h2 id="实现一个预处理器的提示"><a class="header" href="#实现一个预处理器的提示">实现一个预处理器的提示</a></h2>
<p>通过拉取<code>mdbook</code>，作为一个库，预处理器可以访问现有的基础架构来处理书籍.</p>
<p>例如，自定义预处理器可以使用<a href="https://docs.rs/mdbook/latest/mdbook/preprocess/trait.Preprocessor.html#method.parse_input"><code>CmdPreprocessor::parse_input()</code></a>函数， 用于反序列化写入<code>stdin</code>的 JSON。然后是<code>Book</code>的每一章可以通过<a href="https://docs.rs/mdbook/latest/mdbook/book/struct.Book.html#method.for_each_mut"><code>Book::for_each_mut()</code></a>成为可变权限，然后随着<code>serde_json</code>箱写到<code>stdout</code>.</p>
<p>章节可以直接访问(通过递归迭代章节)或通过便利方法<code>Book::for_each_mut()</code>.</p>
<p><code>chapter.content</code>只是一个恰好是 markdown 的字符串。虽然完全可以使用正则表达式或进行手动查找和替换，但您可能希望将输入处理为更加计算机友好的内容。该<a href="https://crates.io/crates/pulldown-cmark"><code>pulldown-cmark</code></a>crate 实现了一个基于事件，生产质量的 Markdown 解析器，而<a href="https://crates.io/crates/pulldown-cmark-to-cmark"><code>pulldown-cmark-to-cmark</code></a>允许您将事件转换回 markdown 文本.</p>
<p>以下代码块，显示了如何从 markdown 中删除所有强调(粗体)，而不会意外地破坏文档.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn remove_emphasis(
    num_removed_items: &amp;mut usize,
    chapter: &amp;mut Chapter,
) -&gt; Result&lt;String&gt; {
    let mut buf = String::with_capacity(chapter.content.len());

    let events = Parser::new(&amp;chapter.content).filter(|e| {
        let should_keep = match *e {
            Event::Start(Tag::Emphasis)
            | Event::Start(Tag::Strong)
            | Event::End(Tag::Emphasis)
            | Event::End(Tag::Strong) =&gt; false,
            _ =&gt; true,
        };
        if !should_keep {
            *num_removed_items += 1;
        }
        should_keep
    });

    cmark(events, &amp;mut buf, None).map(|_| buf).map_err(|err| {
        Error::from(format!(&quot;Markdown serialization failed: {}&quot;, err))
    })
}
<span class="boring">}
</span></code></pre></pre>
<p>对于其他的一切，看<a href="https://github.com/rust-lang/mdBook/blob/master/examples/nop-preprocessor.rs">完整的例子</a>.</p>
<h2 id="implementing-a-preprocessor-with-a-different-language"><a class="header" href="#implementing-a-preprocessor-with-a-different-language">Implementing a preprocessor with a different language</a></h2>
<p>stdin 与 stdout 是预处理器的交流频道，这种方式让其他语言也能参与进来。比如 Python，下面是修改第一章内容的示例：
<code>preprocessor.foo.command</code> 指向的实际命令。</p>
<pre><code class="language-python">import json
import sys


if __name__ == '__main__':
    if len(sys.argv) &gt; 1: # we check if we received any argument
        if sys.argv[1] == &quot;supports&quot;:
            # then we are good to return an exit status code of 0, since the other argument will just be the renderer's name
            sys.exit(0)

    # load both the context and the book representations from stdin
    context, book = json.load(sys.stdin)
    # and now, we can just modify the content of the first chapter
    book['sections'][0]['Chapter']['content'] = '# Hello'
    # we are done with the book's modification, we can just print it to stdout,
    print(json.dumps(book))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="备用后端"><a class="header" href="#备用后端">备用后端</a></h1>
<p>“后端“只是一个，<code>mdbook</code>在书籍渲染过程中调用的程序。该程序会拿到传递到<code>stdin</code>的书籍和配置信息的 JSON 表达式。一旦后端收到这些信息,就可以自由地做任何想做的事情.</p>
<p><a href="for_developers/../format/configuration/renderers.zh.html">Configuring Renderers</a> 有更多信息。</p>
<p>社区也开发了几个后端 [Third Party Plugins]</p>
<h2 id="目录"><a class="header" href="#目录">目录</a></h2>
<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<ul>
<li><a href="for_developers/backends.zh.html#%E8%AE%BE%E7%BD%AE%E5%A5%BD">设置好</a></li>
<li><a href="for_developers/backends.zh.html#%E6%A3%80%E6%9F%A5-book">检查 Book</a></li>
<li><a href="for_developers/backends.zh.html#%E5%90%AF%E7%94%A8%E5%90%A7%E6%88%91%E7%9A%84-backend">启用吧，我的 Backend</a></li>
<li><a href="for_developers/backends.zh.html#%E9%85%8D%E7%BD%AE">配置</a></li>
<li><a href="for_developers/backends.zh.html#%E8%BE%93%E5%87%BA%E5%92%8C%E4%BF%A1%E5%8F%B7%E6%95%85%E9%9A%9C">输出和信号故障</a></li>
<li><a href="for_developers/backends.zh.html#%E5%8C%85%E6%B6%B5%E5%8C%85%E6%B6%B5">包涵包涵</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h2 id="设置好"><a class="header" href="#设置好">设置好</a></h2>
<p>此页面将引导您，创建自己的单词计数程序的简单形式的备用后端。虽然它将用 Rust 编写，但没有理由不能用 Python 或 Ruby 之类，来完成它。</p>
<p>首先，您需要创建一个新的二进制程序，并添加<code>mdbook</code>作为依赖.</p>
<pre><code class="language-shell">$ cargo new --bin mdbook-wordcount
$ cd mdbook-wordcount
$ cargo add mdbook
</code></pre>
<p>捋一捋，当我们的<code>mdbook-wordcount</code>插件被调用，<code>mdbook</code>将通过我们的插件的<code>stdin</code>，发送它<a href="https://docs.rs/mdbook/*/mdbook/renderer/struct.RenderContext.html"><code>RenderContext</code></a>的 JSON 版本。为方便起见，有一个<a href="https://docs.rs/mdbook/*/mdbook/renderer/struct.RenderContext.html#method.from_json"><code>RenderContext::from_json()</code></a>构造函数，加载一个<code>RenderContext</code>。</p>
<p>这是我们后端加载本书，所需的所有样板.</p>
<pre><pre class="playground"><code class="language-rust edition2018">// src/main.rs
extern crate mdbook;

use std::io;
use mdbook::renderer::RenderContext;

fn main() {
    let mut stdin = io::stdin();
    let ctx = RenderContext::from_json(&amp;mut stdin).unwrap();
}
</code></pre></pre>
<blockquote>
<p><strong>注意:</strong> <code>RenderContext</code>包含一个<code>version</code>字段。这使得后端在被调用时确定它们是否与<code>mdbook</code>版本兼容。这个<code>version</code>直接来自<code>mdbook</code>的<code>Cargo.toml</code>中的相应字段.</p>
</blockquote>
<p>建议后端使用<a href="https://crates.io/crates/semver"><code>semver</code></a>，如果可能存在兼容性问题,请检查此字段，并发出警告.</p>
<h2 id="检查-book"><a class="header" href="#检查-book">检查 Book</a></h2>
<p>现在我们的后端有一本书的副本,让我们计算每章中有多少单词!</p>
<p>因为<code>RenderContext</code>包含一个<a href="https://docs.rs/mdbook/*/mdbook/book/struct.Book.html"><code>Book</code></a>字段(<code>book</code>),和一个<code>Book</code>有<a href="https://docs.rs/mdbook/*/mdbook/book/struct.Book.html#method.iter"><code>Book::iter()</code></a>，用于迭代其<code>Book</code>中所有项的方法，这一步就和第一步一样简单.</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
    let mut stdin = io::stdin();
    let ctx = RenderContext::from_json(&amp;mut stdin).unwrap();

    for item in ctx.book.iter() {
        if let BookItem::Chapter(ref ch) = *item {
            let num_words = count_words(ch);
            println!(&quot;{}: {}&quot;, ch.name, num_words);
        }
    }
}

fn count_words(ch: &amp;Chapter) -&gt; usize {
    ch.content.split_whitespace().count()
}
</code></pre></pre>
<h2 id="启用吧我的-backend"><a class="header" href="#启用吧我的-backend">启用吧，我的 Backend</a></h2>
<p>现在我们的基本部分已经运行了，我们希望实际使用它。那首先,当然是安装程序.</p>
<pre><code>$ cargo install --path .
</code></pre>
<p>然后<code>cd</code>在特定的书目录中，若你想要数字计数，那更新它的<code>book.toml</code>文件.</p>
<pre><code class="language-diff">  [book]
  title = &quot;mdBook Documentation&quot;
  description = &quot;Create book from markdown files. Like Gitbook but implemented in Rust&quot;
  authors = [&quot;Mathieu David&quot;, &quot;Michael-F-Bryan&quot;]

+ [output.html]

+ [output.wordcount]
</code></pre>
<p>当<code>mdbook</code>将一本书加载到内存中时，它会尝试检查你的<code>book.toml</code>，并查找所有<code>output.*</code>表格来尝试找出要使用的后端。如果没有提供，它将回退到，使用默认的 HTML 渲染器.</p>
<p>值得注意的是，这表示如果你想添加自己的自定义后端，你还需要确保添加 HTML 后端，即使只是空表格。</p>
<p>现在你只需要像平常一样构建你的书，一切都应该 <em>可以工作</em>。</p>
<pre><code class="language-shell">$ mdbook build
...
2018-01-16 07:31:15 [INFO] (mdbook::renderer): Invoking the &quot;mdbook-wordcount&quot; renderer
mdBook: 126
Command Line Tool: 224
init: 283
build: 145
watch: 146
serve: 292
test: 139
Format: 30
SUMMARY.md: 259
Configuration: 784
Theme: 304
index.hbs: 447
Syntax highlighting: 314
MathJax Support: 153
Rust code specific features: 148
For Developers: 788
Alternative Backends: 710
Contributors: 85
</code></pre>
<p>我们之所以不需要指定我们<code>wordcount</code>后端的全名/路径，是因为<code>mdbook</code>会尽力的<em>推断</em>程序的名称，这些都是因为规范化，如下: 可执行文件<code>foo</code>后端通常被称为<code>mdbook-foo</code>，还有相关联的<code>[output.foo]</code>会进入<code>book.toml</code>。而要明确告诉<code>mdbook</code>要调用什么命令(可能需要命令行参数或是解释的脚本)， 你可以使用<code>command</code>字段。</p>
<pre><code class="language-diff">  [book]
  title = &quot;mdBook Documentation&quot;
  description = &quot;Create book from markdown files. Like Gitbook but implemented in Rust&quot;
  authors = [&quot;Mathieu David&quot;, &quot;Michael-F-Bryan&quot;]

  [output.html]

  [output.wordcount]
+ command = &quot;python /path/to/wordcount.py&quot;
</code></pre>
<h2 id="配置-1"><a class="header" href="#配置-1">配置</a></h2>
<p>现在假设您不想计算特定章节上的单词数(可能是生成的文本/代码等)。要做到这样的规范方法，是通过常规<code>book.toml</code>配置文件，添加个别项到您的<code>[output.foo]</code>表格。</p>
<p><code>Config</code>可以粗略地视为嵌套的<code>hashmap</code>，它允许您调用类似的方法<code>get()</code>使用访问配置的内容，也带<code>get_deserialized()</code>这一方便方法,用于检索值，并自动反序列化为某种任意类型<code>T</code>.</p>
<p>为实现这一点,我们将创建自己的可序列化<code>WordcountConfig</code>结构将封装此后端的所有配置.</p>
<p>首先添加<code>serde</code>和<code>serde_derive</code>到你的<code>Cargo.toml</code>,</p>
<pre><code>$ cargo add serde serde_derive
</code></pre>
<p>然后你可以创建配置结构,</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate serde;
#[macro_use]
extern crate serde_derive;

...

#[derive(Debug, Default, Serialize, Deserialize)]
#[serde(default, rename_all = &quot;kebab-case&quot;)]
pub struct WordcountConfig {
  pub ignores: Vec&lt;String&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>现在我们只需要我们的<code>RenderContext</code>，反序列化成<code>WordcountConfig</code>，然后添加一个检查，以确保我们跳过忽略的章节。</p>
<pre><code class="language-diff">  fn main() {
      let mut stdin = io::stdin();
      let ctx = RenderContext::from_json(&amp;mut stdin).unwrap();
+     let cfg: WordcountConfig = ctx.config
+         .get_deserialized(&quot;output.wordcount&quot;)
+         .unwrap_or_default();

      for item in ctx.book.iter() {
          if let BookItem::Chapter(ref ch) = *item {
+             if cfg.ignores.contains(&amp;ch.name) {
+                 continue;
+             }
+
              let num_words = count_words(ch);
              println!(&quot;{}: {}&quot;, ch.name, num_words);
          }
      }
  }
</code></pre>
<h2 id="输出和信号故障"><a class="header" href="#输出和信号故障">输出和信号故障</a></h2>
<p>虽然在构建书籍时，将字数计数打印到终端是很好的，但将它们输出到某个文件也可能是个好主意。<code>mdbook</code>能告诉后端，它应该根据<a href="https://docs.rs/mdbook/*/mdbook/renderer/struct.RenderContext.html"><code>RenderContext</code></a>的<code>destination</code>字段，放置输出的位置，.</p>
<pre><code class="language-diff">+ use std::fs::{self, File};
+ use std::io::{self, Write};
- use std::io;
  use mdbook::renderer::RenderContext;
  use mdbook::book::{BookItem, Chapter};

  fn main() {
    ...

+     let _ = fs::create_dir_all(&amp;ctx.destination);
+     let mut f = File::create(ctx.destination.join(&quot;wordcounts.txt&quot;)).unwrap();
+
      for item in ctx.book.iter() {
          if let BookItem::Chapter(ref ch) = *item {
              ...

              let num_words = count_words(ch);
              println!(&quot;{}: {}&quot;, ch.name, num_words);
+             writeln!(f, &quot;{}: {}&quot;, ch.name, num_words).unwrap();
          }
      }
  }
</code></pre>
<blockquote>
<p><strong>注意:</strong> 无法保证目标目录存在或为空(<code>mdbook</code>可能会留下以前的内容让后端进行缓存)，因此创建它<code>fs::create_dir_all()</code>总不会错。</p>
<p>如果目的地目录已存在, 不要假设它就一定是空的。
要知道，后端是有上一结果缓存的, <code>mdbook</code> 或许会留下
旧的内容在里面。</p>
</blockquote>
<p>处理书籍时，总会出现错误(只需查看全部我们已经写过了的<code>unwrap()</code>)吗，所以<code>mdbook</code>会渲染失败后，非零退出代码。</p>
<p>例如，如果我们想确保所有章节的单词，都有<em>偶数</em>数量， 而如果遇到奇数，则输出错误，那么你可以这样做:</p>
<pre><code class="language-diff">+ use std::process;
  ...

  fn main() {
      ...

      for item in ctx.book.iter() {
          if let BookItem::Chapter(ref ch) = *item {
              ...

              let num_words = count_words(ch);
              println!(&quot;{}: {}&quot;, ch.name, num_words);
              writeln!(f, &quot;{}: {}&quot;, ch.name, num_words).unwrap();

+             if cfg.deny_odds &amp;&amp; num_words % 2 == 1 {
+               eprintln!(&quot;{} has an odd number of words!&quot;, ch.name);
+               process::exit(1);
              }
          }
      }
  }

  #[derive(Debug, Default, Serialize, Deserialize)]
  #[serde(default, rename_all = &quot;kebab-case&quot;)]
  pub struct WordcountConfig {
      pub ignores: Vec&lt;String&gt;,
+     pub deny_odds: bool,
  }
</code></pre>
<p>现在，如果我们重新安装后端，并构建一本书,</p>
<pre><code class="language-shell">$ cargo install --path . --force
$ mdbook build /path/to/book
...
2018-01-16 21:21:39 [INFO] (mdbook::renderer): Invoking the &quot;wordcount&quot; renderer
mdBook: 126
Command Line Tool: 224
init: 283
init has an odd number of words!
2018-01-16 21:21:39 [ERROR] (mdbook::renderer): Renderer exited with non-zero return code.
2018-01-16 21:21:39 [ERROR] (mdbook::utils): Error: Rendering failed
2018-01-16 21:21:39 [ERROR] (mdbook::utils):    Caused By: The &quot;mdbook-wordcount&quot; renderer failed
</code></pre>
<p>您可能已经注意到，插件的子进程的输出会立即传递给用户。鼓励插件遵循“安静规则“，且仅在必要时生成输出(例如，生成错误或警告)。</p>
<p>所有环境变量都传递到后端，允许您使用常用的<code>RUST_LOG</code>，控制日志记录详细程度.</p>
<h2 id="包涵包涵"><a class="header" href="#包涵包涵">包涵包涵</a></h2>
<p>虽然有点做作，但希望这个例子足以说明，如何创建一个<code>mdbook</code>备用后端。如果你觉得它遗漏了什么，请不要犹豫，创造一个问题的<a href="https://github.com/rust-lang/mdBook/issues">issue tracker</a>，让我们可以一起改进用户指南。</p>
<p>在本章开头提到的现有后端，应该是现实生活中如何完成后端的很好例子，所以请随意浏览源代码，或提出问题.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributors"><a class="header" href="#contributors">Contributors</a></h1>
<p>Here is a list of the contributors who have helped improving mdBook. Big
shout-out to them!</p>
<ul>
<li><a href="https://github.com/mdinger">mdinger</a></li>
<li>Kevin (<a href="https://github.com/kbknapp">kbknapp</a>)</li>
<li>Steve Klabnik (<a href="https://github.com/steveklabnik">steveklabnik</a>)</li>
<li>Adam Solove (<a href="https://github.com/asolove">asolove</a>)</li>
<li>Wayne Nilsen (<a href="https://github.com/waynenilsen">waynenilsen</a>)</li>
<li><a href="https://github.com/funkill">funnkill</a></li>
<li>Fu Gangqiang (<a href="https://github.com/FuGangqiang">FuGangqiang</a>)</li>
<li><a href="https://github.com/Michael-F-Bryan">Michael-F-Bryan</a></li>
<li>Chris Spiegel (<a href="https://github.com/cspiegel">cspiegel</a>)</li>
<li><a href="https://github.com/projektir">projektir</a></li>
<li><a href="https://github.com/Phaiax">Phaiax</a></li>
<li>Matt Ickstadt (<a href="https://github.com/mattico">mattico</a>)</li>
<li>Weihang Lo (<a href="https://github.com/weihanglo">weihanglo</a>)</li>
<li>Avision Ho (<a href="https://github.com/avisionh">avisionh</a>)</li>
<li>Vivek Akupatni (<a href="https://github.com/apatniv">apatniv</a>)</li>
<li>Eric Huss (<a href="https://github.com/ehuss">ehuss</a>)</li>
<li>Josh Rotenberg (<a href="https://github.com/joshrotenberg">joshrotenberg</a>)</li>
</ul>
<p>If you feel you’re missing from this list, feel free to add yourself in a PR.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>

        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
