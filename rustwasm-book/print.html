<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust and WebAssembly</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="_FontAwesome/css/font-awesome.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="introduction.zh.html"><strong aria-hidden="true">1.</strong> 介绍</a></li><li><a href="background-and-concepts.zh.html"><strong aria-hidden="true">2.</strong> 背景和概念</a></li><li><a href="game-of-life/introduction.zh.html"><strong aria-hidden="true">3.</strong> 教程:康威的生命游戏</a></li><li><ol class="section"><li><a href="game-of-life/setup.zh.html"><strong aria-hidden="true">3.1.</strong> 安装</a></li><li><a href="game-of-life/hello-world.zh.html"><strong aria-hidden="true">3.2.</strong> Hello, World!</a></li><li><a href="game-of-life/rules.zh.html"><strong aria-hidden="true">3.3.</strong> 规则</a></li><li><a href="game-of-life/implementing.zh.html"><strong aria-hidden="true">3.4.</strong> 实现 生命</a></li><li><a href="game-of-life/debugging.zh.html"><strong aria-hidden="true">3.5.</strong> 调试</a></li><li><a href="game-of-life/interactivity.zh.html"><strong aria-hidden="true">3.6.</strong> 增加交互性</a></li><li><a href="game-of-life/time-profiling.zh.html"><strong aria-hidden="true">3.7.</strong> 时间分析</a></li><li><a href="game-of-life/code-size.zh.html"><strong aria-hidden="true">3.8.</strong> 收缩 .wasm 尺寸</a></li><li><a href="game-of-life/production.zh.html"><strong aria-hidden="true">3.9.</strong> 生产 与 发布</a></li><li class="spacer"></li></ol></li><li><a href="crates.zh.html"><strong aria-hidden="true">5.</strong> 你应该知道的Crates箱子</a></li><li><a href="tools.zh.html"><strong aria-hidden="true">6.</strong> 你应该知道的工具</a></li><li><a href="js-ffi.zh.html"><strong aria-hidden="true">7.</strong> JavaScript 互操作</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Rust and WebAssembly</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>这本小书描述了如何让 <a href="https://www.rust-lang.org">rust</a> 和 <a href="https://webassembly.org/">WebAssembly</a> 一起.</p>
<p><a href="https://github.com/rustwasm/book">这本书是开源的!找个拼写错误?我们忽略了什么吗?向我们发送拉动请求!</a></p>
<a class="header" href="print.html#a背景和概念" id="a背景和概念"><h1>背景和概念</h1></a>
<a class="header" href="print.html#webassembly" id="webassembly"><h2>WebAssembly</h2></a>
<p><code>WebAssembly</code> 是一个简单的机器模型和可执行格式<a href="https://%60WebAssembly%60.github.io/spec/">extensive
specification</a>广泛的定义.</p>
<p>虽然它目前在 JavaScript和Web社区 中受到关注, 但并没有限制它的运行环境. 因此,认为在不久的将来, <em>wasm</em>将成为在各种环境中, 使用的重要&quot;便携式可执行&quot;格式是有可能的 (我们将花一些时间仔细研究一下<em>wasm</em>便携性功能,待本书进一步说明).</p>
<p>来到<em>今天</em>,总得来说,<em>wasm</em>主要与JavaScript有关,它有很多种类 (包括浏览器和 <code>Node.js</code>) . 由于JS广泛且易于访问, 我们将主要关注使用这些平台来运行 Rust生成的<em>wasm</em>,但 其他语言的编译 可能会在不久的将来发布.</p>
<p>作为一种编程语言,<code>WebAssembly</code>由两种格式组成: 二进制格式和文本格式. 两者都代表了一种共同的结构, 尽管方式不同. 文本格式 (通常称为<code>wat</code>) 使用<a href="https://en.wikipedia.org/wiki/S-expression">S表达式-</a>,与 Clojure或Racket 等语言有一些相似之处. 二进制格式<code>wasm</code>是一种较低级别的格式,它本身就是由 解释器运 行的汇编代码.</p>
<p>作为参考,这里是一个<code>wat</code>格式的阶乘函数:</p>
<pre><code>(module
  (func $fac (param f64) (result f64)
    get_local 0
    f64.const 1
    f64.lt
    if (result f64)
      f64.const 1
    else
      get_local 0
      get_local 0
      f64.const 1
      f64.sub
      call $fac
      f64.mul
    end)
  (export &quot;fac&quot; (func $fac)))
</code></pre>
<p>如果你对<code>wasm</code>文件好奇,你可以使用<a href="https://cdn.rawgit.com/%60WebAssembly%60/wabt/aae5a4b7/demo/wat2wasm/">wat2wasm demo</a>看上面的代码.</p>
<p><code>WebAssembly</code>有一个非常简单的<a href="https://%60WebAssembly%60.github.io/spec/core/syntax/modules.html#syntax-mem">内存模型</a>. 目前,一个<code>wasm</code>模块可以访问单个&quot;线性内存&quot;,它本质上是一个固定数字类型的平面数组. 这个<a href="https://%60WebAssembly%60.github.io/spec/core/syntax/instructions.html#syntax-instr-memory">内存成长</a>是页面大小 (64K) 的倍数,并且不能缩小.</p>
<a class="header" href="print.html#a教程-康威的生命游戏" id="a教程-康威的生命游戏"><h1>教程: 康威的生命游戏</h1></a>
<p>这是一个用Rust和WebAssembly实现的教程<a href="https://zh.wikipedia.org/wiki/%E5%BA%B7%E5%A8%81%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F">康威的生命游戏</a>.</p>
<blockquote>
<p>谁是 康威-ConWay 我怎么知道 ❓</p>
</blockquote>
<a class="header" href="print.html#a本教程适合谁" id="a本教程适合谁"><h2>本教程适合谁?</h2></a>
<p>本教程适用于 已经具有基本 Rust和JavaScript经验 的任何人,并希望学习如何一起使用 Rust,WebAssembly和JavaScript.</p>
<p>阅读和编写基本的 Rust,JavaScript和HTML 应该会很舒服. 你绝对不需要成为专家才能懂.</p>
<a class="header" href="print.html#a我会学到什么" id="a我会学到什么"><h2>我会学到什么?</h2></a>
<ul>
<li>
<p>怎样设置Rust工具链, 且将其编译为 WebAssembly</p>
</li>
<li>
<p>用于由Rust, WebAssembly,
JavaScript, HTML, 和 CSS开发的多语言程序工作流程</p>
</li>
<li>
<p>怎样设计 让 Rust 和 WebAssembly 最优化的API, 当然还有JavaScript</p>
</li>
<li>
<p>怎样调试从Rust编译而来的WebAssembly模块</p>
</li>
<li>
<p>怎样对Rust和WebAssembly的程序进行时间分析, 让它变得更快</p>
</li>
<li>
<p>怎样对Rust和WebAssembly的程序进行大小分析, 让它变小和网络下载速度更快</p>
</li>
</ul>
<a class="header" href="print.html#a安装" id="a安装"><h1>安装</h1></a>
<p>这个章节讲述的是: 怎样设置将Rust编译成WebAssembly和糅合到JavaScript的工具链</p>
<a class="header" href="print.html#rust工具链" id="rust工具链"><h3>Rust工具链</h3></a>
<p>您将需要标准的 Rust工具链,包括<code>rustup</code>,<code>rustc</code>,和<code>cargo</code></p>
<p><a href="https://www.rust-lang.org/en-US/install.html">按照以下说明安装Rust工具链. </a></p>
<a class="header" href="print.html#wasm32-unknown-unknown目标" id="wasm32-unknown-unknown目标"><h2><code>wasm32-unknown-unknown</code>目标</h2></a>
<p>一旦安装了 Rust工具链 ,您就可以将 Rust程序 编译为 WebAssembly,而不是机器的本机代码. 您可以通过添加<code>wasm32-unknown-unknown</code>来启用此功能,使用以下命令进行目标:</p>
<pre><code>rustup update
rustup install nightly
rustup target add wasm32-unknown-unknown --toolchain nightly
</code></pre>
<a class="header" href="print.html#npm" id="npm"><h2><code>npm</code></h2></a>
<p><code>npm</code>是 JavaScript的包管理器. 我们将使用它来安装和运行 JavaScript捆绑器 和 开发服务器. 在本教程结束时,我们将发布我们编译的<code>.wasm</code>到了<code>npm</code>注册表中.</p>
<p><a href="https://www.npmjs.com/get-npm">请按照以下说明进行安装<code>npm</code>. </a></p>
<a class="header" href="print.html#wasm-bindgen" id="wasm-bindgen"><h2><code>wasm-bindgen</code></h2></a>
<p><a href="https://github.com/rustwasm/wasm-bindgen"><code>wasm-bindgen</code></a>为 Rust和WebAssembly 生成与 JavaScript 的双向绑定.</p>
<p>安装<code>wasm-bindgen</code>使用此命令:</p>
<pre><code>cargo +nightly install wasm-bindgen-cli
</code></pre>
<a class="header" href="print.html#a你好-世界" id="a你好-世界"><h2>你好, 世界!</h2></a>
<p>这个章节讲述的是如何构建与运行你的第一个 Rust 和 WebAssembly 程序: 可运行 <code>alert('Hello, World!')</code> 函数的网页</p>
<a class="header" href="print.html#a克隆项目模板" id="a克隆项目模板"><h2>克隆项目模板</h2></a>
<p>项目模板包含一个&quot;hello world&quot;程序. 它预先配置了默认的默认设置,因此您可以快速构建,集成和打包Web代码.</p>
<p>克隆此教程代码存储库,输入其目录,然后 checkout <code>chapter-zero</code> branch:</p>
<pre><code class="language-text">git clone https://github.com/rustwasm/wasm_game_of_life.git
cd ./wasm_game_of_life
git checkout -b chapter-zero origin/chapter-zero
</code></pre>
<a class="header" href="print.html#a里面有什么" id="a里面有什么"><h2>里面有什么</h2></a>
<p>让我们来看看我们项目的内容:</p>
<pre><code class="language-text">.
├── bootstrap.js
├── Cargo.lock
├── Cargo.toml
├── index.html
├── index.js
├── package.json
├── package-lock.json
├── src
│   └── lib.rs
└── webpack.config.js
</code></pre>
<p>其中大多数是配置文件,但我们应该突出显示一些文件.</p>
<a class="header" href="print.html#indexhtml" id="indexhtml"><h3><code>index.html</code></h3></a>
<p>这是网页的根HTML文件. 它除了加载<code>bootstrap.js</code>之外没有其他作用,这是一个非常薄的<code>index.js</code>包装.</p>
<pre><code class="language-html">&lt;html&gt;
    &lt;head&gt;
        &lt;meta content=&quot;text/html;charset=utf-8&quot; http-equiv=&quot;Content-Type&quot;/&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;script src='./bootstrap.js'&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<a class="header" href="print.html#indexjs" id="indexjs"><h3><code>index.js</code></h3></a>
<p>该<code>index.js</code>是我们网页的 JavaScript 的主要入口点. 它导入项目的WebAssembly模块,并调用模块<code>greet</code>函数.</p>
<pre><code class="language-js">import { greet } from &quot;./wasm_game_of_life&quot;;

greet(&quot;Rust and WebAssembly&quot;);
</code></pre>
<a class="header" href="print.html#srclibrs" id="srclibrs"><h3><code>src/lib.rs</code></h3></a>
<p>该<code>src/lib.rs</code>文件是我们正在编译到 WebAssembly的Rust包 的根. 它用<code>wasm_bindgen</code>与 JavaScript交互. 它导入了<code>window.alert</code> - JavaScript函数,并导出<code>greet</code>rust函数,函数需要一个<code>name</code>参数以便 传递给<code>alert</code>函数使用.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![feature(use_extern_macros)]

#fn main() {
extern crate wasm_bindgen;

use wasm_bindgen::prelude::*;

#[wasm_bindgen]
extern {
    fn alert(s: &amp;str);
}

#[wasm_bindgen]
pub fn greet(name: &amp;str) {
    alert(&amp;format!(&quot;Hello, {}!&quot;, name));
}
#}</code></pre></pre>
<a class="header" href="print.html#a构建与启动服务器" id="a构建与启动服务器"><h2>构建与启动服务器</h2></a>
<p>首先,确保为此项目安装了JavaScript构建依赖项:</p>
<pre><code class="language-text">npm install
</code></pre>
<p>此命令只需运行一次,并将安装<code>webpack</code> - JavaScript bundler及其开发服务器. 注意:使用<code>webpack</code>对 Rust和WebAssembly 来说不是必需的,它只是我们为方便起见而选择的捆绑器和开发服务器.</p>
<p>构建 Rust crate{📦} 为 WebAssembly 并生成<code>wasm_bindgen</code>胶水,运行此命令:</p>
<pre><code class="language-text">npm run build-debug
</code></pre>
<p>第一个构建可能需要一些时间,因为需要编译依赖项. 但不要担心: 后续构建,当依赖关系不需要重新编译时,将会快得多.</p>
<p>命令会创建 Rust crates的&quot;debug&quot;版本: 未优化应用的构建,并包含符号以便在浏览器的开发人员工具中进行更好的调试. 您还可以创建一个&quot;发布-release&quot;版本,该版本有优化应用的过程:</p>
<pre><code>npm run build-release
</code></pre>
<p>这是我们想要用来创建, 用于分析和部署到生产的<code>.wasm</code>二进制文件的命令.</p>
<p>接下来,为开发服务器打开一个新终端. 在新终端中运行服务器让我们让它在后台运行,并且不会阻止我们在此期间运行其他命令. 在新终端中,运行以下命令:</p>
<pre><code>npm run serve
</code></pre>
<p>浏览Web浏览器<a href="http://localhost:8080/">http://localhost:8080/)</a>你应该收到一条 <code>alert</code> 信息:</p>
<p><a href="./images/game-of-life/setup.png"><img src="./images/game-of-life/setup.png" alt="Screenshot of the &quot;Hello, Rust and WebAssembly!&quot; Web page alert" /></a></p>
<p>任何时候你做出改变,并希望它们反映到<a href="http://localhost:8080/">http://localhost:8080/)</a>,只是重新运行<code>npm run build-debug</code>命令.</p>
<a class="header" href="print.html#a练习" id="a练习"><h2>练习</h2></a>
<ul>
<li>修改<code>index.js</code>用你的名字而不是&quot;Rust和WebAssembly&quot;来 运行 <code>alert</code>函数. </li>
</ul>
<a class="header" href="print.html#a康威生命游戏规则" id="a康威生命游戏规则"><h1>康威生命游戏规则</h1></a>
<p><em>注意: 如果您已熟悉康威的生命游戏及其规则,请跳到下一部分!</em></p>
<p><a href="https://zh.wikipedia.org/wiki/%E5%BA%B7%E5%A8%81%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F">维基百科对 康威的生命游戏规则 进行了很好的描述: </a></p>
<blockquote>
<p>生命游戏的宇宙是方形单元的无限二维正交网格,每个方格单元处于两种可能状态之一,活着或死亡,或&quot;填充&quot;或&quot;未填充&quot;. 每个细胞与其八个邻居相互作用 - 这八个邻居是水平,垂直或对角相邻的细胞. 在每个步骤中,发生以下转换:</p>
<ol>
<li>当前细胞为存活状态时，当周围低于2个（不包含2个）存活细胞时， 该细胞变成死亡状态。（模拟生命数量稀少）</li>
<li>当前细胞为存活状态时，当周围有2个或3个存活细胞时， 该细胞保持原样。</li>
<li>当前细胞为存活状态时，当周围有3个以上的存活细胞时，该细胞变成死亡状态。（模拟生命数量过多）</li>
<li>当前细胞为死亡状态时，当周围有3个存活细胞时，该细胞变成存活状态。 （模拟繁殖）</li>
</ol>
</blockquote>
<blockquote>
<p>可以把最初的细胞结构定义为种子，当所有在种子中的细胞同时被以上规则处理后, 可以得到第一代细胞图。按规则继续处理当前的细胞图，可以得到下一代的细胞图，周而复始。</p>
</blockquote>
<p>考虑以下初始 Universe:</p>
<p><img src='./images/game-of-life/initial-universe.png' alt='Initial Universe' width="80" /></p>
<p>我们可以通过考虑每个单元来计算下一代. 左上角的单元格已经死了. 规则 (4) 是适用于死细胞的唯一转换规则. 但是,因为左上角的单元格没有正好三个活动邻居,所以转换规则不适用,并且它在下一代中仍然不存在. 对于 第一行 中的每个其他单元也是如此.</p>
<p>当我们考虑第二列,第三列中的活细胞时,事情变得有趣. 对于活细胞,前三个规则中的任何一个都可能适用. 在这个黑单元的情况下,它只有下面一个活的邻居,因此规则 (1) 适用: 这个单元将在下一代中死亡. 同样的命运也对应着最下面的活黑细胞.</p>
<p>中间活细胞有两个活的邻居: 顶部和底部活细胞. 这意味着规则 (2) 适用,并且它仍然存在于下一代.</p>
<p>最后有趣的案例是中间活细胞左侧和右侧的死细胞. 这三个活细胞都是这些细胞的邻居,这意味着规则 (4) 适用,并且这些细胞将在下一代中存活.</p>
<p>把它们放在一起,我们在下一个滴答之后得到这个宇宙:</p>
<p><img src='./images/game-of-life/next-universe.png' alt='Next Universe' width=80 /></p>
<p>从这些简单的,确定性的规则出现,奇怪和令人兴奋的行为出现了:</p>
<table><thead><tr><th> Gosper的滑翔机枪                                                                                        </th><th> 脉冲星                                                                                    </th><th> 太空飞船                                                                                                         </th></tr></thead><tbody>
<tr><td> <img src="https://upload.wikimedia.org/wikipedia/commons/e/e5/Gospers_glider_gun.gif" alt="Gosper's glider gun" /> </td><td> <img src="https://upload.wikimedia.org/wikipedia/commons/0/07/Game_of_life_pulsar.gif" alt="Pulsar" /> </td><td> <img src="https://upload.wikimedia.org/wikipedia/commons/3/37/Game_of_life_animated_LWSS.gif" alt="Lighweight space ship" /> </td></tr>
</tbody></table>
<p><center></p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/C2vgICfQawE?rel=0&amp;start=65" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>
</center>
<a class="header" href="print.html#a练习-1" id="a练习-1"><h2>练习</h2></a>
<ul>
<li>
<p>手动计算我们的示例 Universe的下一个滴答. 注意像什么?</p>
</li>
<li>
<p>你能找到一个稳定的初始宇宙吗? 也就是说,每一代人都是一样的宇宙.</p>
</li>
</ul>
<a class="header" href="print.html#a实施康威的生命游戏" id="a实施康威的生命游戏"><h1>实施康威的生命游戏</h1></a>
<a class="header" href="print.html#a设计" id="a设计"><h2>设计</h2></a>
<p>在我们深入之前,我们有一些设计选择需要考虑.</p>
<a class="header" href="print.html#a无限的宇宙" id="a无限的宇宙"><h3>无限的宇宙</h3></a>
<p>生命游戏是在无限的宇宙中进行的,但我们没有无限的记忆和计算能力. 解决这个相当恼人的限制通常有以下三种风格之一:</p>
<ol>
<li>
<p>跟踪宇宙的哪个子集发生了有趣的事情,并根据需要,扩展此区域. 在最坏的情况下,这种扩展是无限制的,实现将变得越来越慢,最终耗尽内存.</p>
</li>
<li>
<p>创建固定大小的 Universe，边缘上的单元格具有较少的邻居
比中间的细胞。 这种方法的缺点是无限
像滑翔机一样到达宇宙尽头的模式被扼杀了。</p>
</li>
<li>
<p>创建一个固定大小的周期性 Universe <code>移动</code>,其中边缘上的单元格具有环绕到 Universe 另一侧的邻居. 因为邻居环绕宇宙的边缘,滑翔机可以永远运行.</p>
</li>
</ol>
<p>我们将实施<code>第三种</code>选择.</p>
<a class="header" href="print.html#a连接-rust-和-javascript" id="a连接-rust-和-javascript"><h3>连接 Rust 和 JavaScript</h3></a>
<blockquote>
<p>⚡ 这是理解和从本教程中你获取的最重要的概念之一!</p>
</blockquote>
<p>JavaScript 的垃圾收集堆 - <code>Object</code>,<code>Array</code>和 DOM 节点 被分配 - 不同于 WebAssembly 的线性内存空间,我们的 Rust 值 存在于其中. WebAssembly 目前无法直接访问垃圾收集堆 (截至 2018 年 4 月,预计会随之改变<a href="https://github.com/WebAssembly/host-bindings/blob/master/proposals/host-bindings/Overview.md">&quot;主机绑定 host-bindings&quot;提案</a>) . 另一方面,JavaScript 可以读取和写入 WebAssembly 线性存储空间,但仅作为一个<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffer</code></a>标量值 (<code>u8</code>,<code>i32</code>,<code>f64</code>等等......) WebAssembly 函数也接受,并返回标量值. 这些是构成 WebAssembly 和 JavaScript 通信 的所有构建块.</p>
<p><code>wasm_bindgen</code>定义了如何在这个边界上,使用复合结构的共同理解. 它涉及装箱 Rust 结构,将指针包装在 JavaScript 类 中以实现可用性,或者 索引到 Rust 中的 JavaScript 对象表. <code>wasm_bindgen</code>非常方便,但它不需要考虑我们的数据表示,以及跨越这个边界传递什么值和结构. 相反,将其视为实现您选择的接口设计的工具.</p>
<p>在设计 WebAssembly 和 JavaScript 之间的接口时,我们希望针对以下属性进行优化:</p>
<ol>
<li>
<p>**最小化复制 WebAssembly 线性存储器的 进/出 .**不必要的副本会产生不必要的开销.</p>
</li>
<li>
<p>**最小化序列化和反序列化.**与副本类似,序列化和反序列化也会产生开销,并且通常也会进行复制. 如果我们可以将不透明控制传递给数据结构 - 而不是一侧序列化后,将其复制到 WebAssembly 线性存储器中的某个已知位置,并在另一侧进行反序列化 - 我们通常可以减少大量开销. <code>wasm_bindgen</code>帮助我们 定义和使用 JavaScript 的不透明控制<code>Object</code>或 盒装 Rust 结构.</p>
</li>
</ol>
<p>作为一般的经验法则,一个好的 JavaScript↔WebAssembly 接口设计通常是将大型,长寿命的数据结构实现为 生活在 WebAssembly 线性内存 中的 Rust 类型,并作为不透明控制暴露给 JavaScript. JavaScript 调用导出的 WebAssembly 函数,这些函数接受这些不透明的控制,转换数据,执行繁重的计算,查询数据,最终返回一个小的可复制结果. 通过仅返回计算的小结果,我们避免在 JavaScript 垃圾收集堆和 WebAssembly 线性存储器 之间,来回复制和序列化所有内容.</p>
<a class="header" href="print.html#a在我们的生命游戏中连接-rust-和-javascript" id="a在我们的生命游戏中连接-rust-和-javascript"><h3>在我们的生命游戏中连接 Rust 和 JavaScript</h3></a>
<p>让我们首先列举一些要避免的危险. 我们不希望在每个<code>tick</code>上将整个 Universe 复制到 WebAssembly 线性内存 中. 我们不希望为宇宙中的每个单元分配对象,也不想强加函数调用来读写每个单元.</p>
<p>这给我们留下了什么? 我们可以将 Universe 表示为位于 WebAssembly 线性内存中的平面数组,并且每个单元格都有一个字节. <code>0</code>是一个死细胞,<code>1</code>是一个活细胞.</p>
<p>以下是 4 x 4 宇宙在内存中的样子:</p>
<p><img src="./images/game-of-life/universe.png" alt="Screenshot of a 4 by 4 universe" /></p>
<p>要在 Universe 中的给定行和列中查找单元格的数组索引,我们可以使用以下公式:</p>
<pre><code class="language-text">index(row, column, universe) = row * width(universe) + column
</code></pre>
<p>我们有几种方法可以将 Universe 的单元格暴露给 JavaScript. 首先,我们添加实施<a href="https://doc.rust-lang.org/1.25.0/std/fmt/trait.Display.html"><code>std::fmt::Display</code></a>到<code>Universe</code>,我们可以用来展示 一个 Rust<code>String</code> 呈现为文本字符的单元格. 然后将此 Rust String 从 WebAssembly 线性内存 复制到 JavaScript 的垃圾回收堆中 的 JavaScript String 中,然后通过设置<code>HTML</code>显示<code>textContent</code>. 在本章的后面,我们将推演这个实现,以避免在堆之间复制 Universe 的单元格,再渲染<code>&lt;canvas&gt;</code>.</p>
<p><em>另一个可行的设计替代方案是 Rust 返回每个滴答后,更改状态的每个单元格的列表,而不是将整个 Universe 暴露给 JavaScript. 这样,JavaScript 在渲染时不需要遍历整个 Universe ,只需要相关的子集. 权衡的问题是这种 基于 delta 的设计实施起来稍微困难一些.</em></p>
<a class="header" href="print.html#rust-实现" id="rust-实现"><h2>Rust 实现</h2></a>
<p>在上一章中,我们克隆了一个初始项目模板. 我们现在将修改该项目模板.</p>
<p>让我们开始删除 <code>alert</code> import 和<code>greet</code> 函数 - <code>src/lib.rs</code>, 并用单元格的类型定义替换它们:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[repr(u8)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Cell {
    Dead = 0,
    Alive = 1,
}
#}</code></pre></pre>
<p>重要的是我们拥有<code>#[repr(u8)]</code>,以便每个单元格表示为单个字节. 同样重要的是<code>Dead</code>代表<code>0</code>,那个<code>Alive</code>是<code>1</code>,这样我们就可以轻松地计算一个细胞的活体邻居.</p>
<p>接下来,让我们定义宇宙. 宇宙具有宽度和高度,以及长度为单元格的向量<code>width * height</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
pub struct Universe {
    width: u32,
    height: u32,
    cells: Vec&lt;Cell&gt;,
}
#}</code></pre></pre>
<p>要访问给定行和列的单元格,我们将 行和列 转换为 单元格向量 的索引,如前所述:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Universe {
    fn get_index(&amp;self, row: u32, column: u32) -&gt; usize {
        (row * self.width + column) as usize
    }

    // ...
}
#}</code></pre></pre>
<p>为了计算单元格的下一个状态,我们需要计算 其邻居有多少 是活着的. 我们来写一个<code>live_neighbor_count</code>做到这一点的方法!</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Universe {
    // ...

    fn live_neighbor_count(&amp;self, row: u32, column: u32) -&gt; u8 {
        let mut count = 0;
        for delta_row in [self.height - 1, 0, 1].iter().cloned() {
            for delta_col in [self.width - 1, 0, 1].iter().cloned() {
                if delta_row == 0 &amp;&amp; delta_col == 0 {
                    continue;
                }

                let neighbor_row = (row + delta_row) % self.height;
                let neighbor_col = (column + delta_col) % self.width;
                let idx = self.get_index(neighbor_row, neighbor_col);
                count += self.cells[idx] as u8;
            }
        }
        count
    }
}
#}</code></pre></pre>
<p>该<code>live_neighbor_count</code>方法使用 增量和模数来 避免 宇宙的边缘情况. 当 delta 应用 <code>-1</code>,我们<em>添加</em>
<code>self.height - 1</code>让 模数 做它的事,而不是试图减去<code>1</code>. <code>row</code>和<code>column</code>可以为<code>0</code>,如果我们试图减去<code>1</code>, 从他们来看,会有一个 无符号整数 下溢.</p>
<p>现在我们拥有了从当前计算下一代所需的一切! 每个游戏的规则遵循 直接转换条件用<code>match</code>表达. 另外,因为我们希望 JavaScript 控制滴答时间,我们将把这个方法放在一个<code>#[wasm_bindgen]</code>注释下,以便它暴露给 JavaScript.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// Public methods, exported to JavaScript.
#[wasm_bindgen]
impl Universe {
    pub fn tick(&amp;mut self) {
        let mut next = self.cells.clone();

        for row in 0..self.height {
            for col in 0..self.width {
                let idx = self.get_index(row, col);
                let cell = self.cells[idx];
                let live_neighbors = self.live_neighbor_count(row, col);

                let next_cell = match (cell, live_neighbors) {
                    // Rule 1: Any live cell with fewer than two live neighbours
                    // dies, as if caused by underpopulation.
                    (Cell::Alive, x) if x &lt; 2 =&gt; Cell::Dead,
                    // Rule 2: Any live cell with two or three live neighbours
                    // lives on to the next generation.
                    (Cell::Alive, 2) | (Cell::Alive, 3) =&gt; Cell::Alive,
                    // Rule 3: Any live cell with more than three live
                    // neighbours dies, as if by overpopulation.
                    (Cell::Alive, x) if x &gt; 3 =&gt; Cell::Dead,
                    // Rule 4: Any dead cell with exactly three live neighbours
                    // becomes a live cell, as if by reproduction.
                    (Cell::Dead, 3) =&gt; Cell::Alive,
                    // All other cells remain in the same state.
                    (otherwise, _) =&gt; otherwise,
                };

                next[idx] = next_cell;
            }
        }

        self.cells = next;
    }

    // ...
}
#}</code></pre></pre>
<p>到目前为止,宇宙的状态被表示为 细胞 的载体. 为了使这个可读,让我们实现一个基本的文本渲染器. 我们的想法是逐行将 Universe 写成文本,对于每个活着的单元格,打印 Unicode 字符<code>◼️</code> (&quot;黑色方格&quot;) . 对于死细胞,我们将打印<code>◻️</code> (&quot;白色方格&quot;) .</p>
<p>通过实施<a href="https://doc.rust-lang.org/1.25.0/std/fmt/trait.Display.html"><code>Display</code></a>是来自 Rust 标准库 的特性,我们可以添加一种以 面向用户的方式 格式化结构的方法. 这也会自动给我们一个<a href="https://doc.rust-lang.org/1.25.0/std/string/trait.ToString.html"><code>to_string</code></a>方法.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fmt;

impl fmt::Display for Universe {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        for line in self.cells.as_slice().chunks(self.width as usize) {
            for &amp;cell in line {
                let symbol = if cell == Cell::Dead { &quot;◻️&quot; } else { &quot;◼️&quot; };
                write!(f, &quot;{}&quot;, symbol)?;
            }
            write!(f, &quot;\n&quot;)?;
        }

        Ok(())
    }
}
#}</code></pre></pre>
<p>最后,我们定义一个构造函数,用一个有趣的 活细胞和死细胞 模式来初始化宇宙,以及<code>render</code>方法:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// Public methods, exported to JavaScript.
#[wasm_bindgen]
impl Universe {
    // ...

    pub fn new() -&gt; Universe {
        let width = 64;
        let height = 64;

        let cells = (0..width * height)
            .map(|i| {
                if i % 2 == 0 || i % 7 == 0 {
                    Cell::Alive
                } else {
                    Cell::Dead
                }
            })
            .collect();

        Universe {
            width,
            height,
            cells,
        }
    }

    pub fn render(&amp;self) -&gt; String {
        self.to_string()
    }
}
#}</code></pre></pre>
<p>有了这个,我们的生命游戏 Rust 实现的一半就完成了!</p>
<a class="header" href="print.html#a使用-javascript-渲染" id="a使用-javascript-渲染"><h2>使用 JavaScript 渲染</h2></a>
<p>首先,让我们添加一个<code>&lt;pre&gt;</code>HTML 用于渲染:</p>
<pre><code class="language-html">&lt;body&gt;
    &lt;pre id=&quot;game-of-life-canvas&quot;&gt;&lt;/pre&gt;
    &lt;script src='./bootstrap.js'&gt;&lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>另外,我们想要的<code>&lt;pre&gt;</code>以网页中间为中心. 我们可以使用 CSS flex 来完成这项任务. 添加以下内容<code>&lt;style&gt;</code>在<code>index.html</code>的<code>&lt;head&gt;</code>里面:</p>
<pre><code class="language-html">&lt;style&gt;
    body {
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
    }
&lt;/style&gt;
</code></pre>
<p>在顶端<code>index.js</code>,让我们修复我们的导入来引入<code>Universe</code>而不是旧的<code>greet</code>功能:</p>
<pre><code class="language-js">import {Universe} from './wasm_game_of_life';
</code></pre>
<p>另外,让我们获取<code>&lt;pre&gt;</code>并实例化新 Universe 的元素:</p>
<pre><code class="language-js">const pre = document.getElementById('game-of-life-canvas');
const universe = Universe.new();
</code></pre>
<p>JavaScript 运行于<code>requestAnimationFrame</code>循环. 在每次迭代中,它将当前的 Universe 绘制到<code>&lt;pre&gt;</code>,然后运行<code>Universe::tick</code>.</p>
<pre><code class="language-js">const renderLoop = () =&gt; {
  pre.textContent = universe.render();
  universe.tick();

  requestAnimationFrame(renderLoop);
};
</code></pre>
<p>要开始渲染过程,我们所要做的就是为渲染循环的第一次迭代进行初始调用:</p>
<pre><code class="language-js">requestAnimationFrame(renderLoop);
</code></pre>
<p>这就是它现在的样子:</p>
<p><a href="./images/game-of-life/initial-game-of-life-pre.png"><img src="./images/game-of-life/initial-game-of-life-pre.png" alt="Screenshot of the Game of Life implementation with text rendering" /></a></p>
<a class="header" href="print.html#a直接从内存渲染到画布" id="a直接从内存渲染到画布"><h2>直接从内存渲染到画布</h2></a>
<p>在 Rust 中生成 (和分配) 一个<code>String</code>, 然后有<code>wasm-bindgen</code>将其转换为有效的 JavaScript 字符串 ,来会生成 Universe 单元格 的不必要副本. 其实在 JavaScript 代码 知道 Universe 的宽度和高度,并且可以直接从 JavaScript 中读取 WebAssembly 线性内存 中的单元格字节, 我们就可以修改<code>render</code>方法,用来返回 单元数组的开头指针.</p>
<p>还有,我们将切换到使用<a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API">Canvas API</a>. 而不是渲染 unicode 文本. 我们将在本教程的其余部分中使用此设计.</p>
<p>首先,让我们替换<code>pre</code>,换成了一个<code>&lt;canvas&gt;</code> (它也应该在<code>&lt;body&gt;</code>, <code>&lt;script&gt;</code>加载我们的 JavaScript 之前) :</p>
<pre><code class="language-html">&lt;body&gt;
    &lt;canvas id=&quot;game-of-life-canvas&quot;&gt;&lt;/canvas&gt;
    &lt;script src='./bootstrap.js'&gt;&lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>为了从 Rust 实现 中获取必要的信息,我们需要为 Universe 的宽度,高度和指向 其单元数组 的指针 添加一些更多的 <code>getter</code>函数. 所有这些都暴露在 JavaScript 中.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// Public methods, exported to JavaScript.
#[wasm_bindgen]
impl Universe {
    // ...

    pub fn width(&amp;self) -&gt; u32 {
        self.width
    }

    pub fn height(&amp;self) -&gt; u32 {
        self.height
    }

    pub fn cells(&amp;self) -&gt; *const Cell {
        self.cells.as_ptr()
    }
}
#}</code></pre></pre>
<p>接下来,让我们在<code>import</code>代码行下面定义 JavaScript 在渲染画布时将使用的一些常量:</p>
<pre><code class="language-js">import {Universe} from './wasm_game_of_life';

const CELL_SIZE = 5; // px
const GRID_COLOR = '#CCCCCC';
const DEAD_COLOR = '#FFFFFF';
const ALIVE_COLOR = '#000000';

// 这些必须匹配 `Cell::Alive` 和 `Cell::Dead` in `src/lib.rs`.
const DEAD = 0;
const ALIVE = 1;
</code></pre>
<p>现在,让我们重写当前的 JS 代码 (导入除外) ,不再写入<code>&lt;pre&gt;</code>而是专注在<code>&lt;canvas&gt;</code>:</p>
<pre><code class="language-js">// 构造 the universe, and get its width and height.
const universe = Universe.new();
const width = universe.width();
const height = universe.height();

// Give the canvas room for all of our cells and a 1px border
// around each of them.
const canvas = document.getElementById('game-of-life-canvas');
canvas.height = (CELL_SIZE + 1) * height + 1;
canvas.width = (CELL_SIZE + 1) * width + 1;

const ctx = canvas.getContext('2d');

const renderLoop = () =&gt; {
  universe.tick();

  drawGrid();
  drawCells();

  requestAnimationFrame(renderLoop);
};
</code></pre>
<p>为了在单元格之间绘制网格,我们绘制 一组等间隔 的 水平线 和 一组等间距 的 垂直线. 这些线 纵横交错 形成网格.</p>
<pre><code class="language-js">const drawGrid = () =&gt; {
  ctx.beginPath();
  ctx.lineWidth = 1 / window.devicePixelRatio;
  ctx.strokeStyle = GRID_COLOR;

  // Vertical lines.
  for (let i = 0; i &lt;= width; i++) {
    ctx.moveTo(i * (CELL_SIZE + 1) + 1, 0);
    ctx.lineTo(i * (CELL_SIZE + 1) + 1, (CELL_SIZE + 1) * height + 1);
  }

  // Horizontal lines.
  for (let j = 0; j &lt;= height; j++) {
    ctx.moveTo(0, j * (CELL_SIZE + 1) + 1);
    ctx.lineTo((CELL_SIZE + 1) * width + 1, j * (CELL_SIZE + 1) + 1);
  }

  ctx.stroke();
};
</code></pre>
<p>我们可以直接通过<code>memory</code>拿到 WebAssembly 的 线性内存, 而这个<code>memory</code>有原生 wasm 模块<code>wasm_game_of_life_bg</code>提供.为了绘制 细胞,我们从 <code>universe's cells</code> 拿到指针 ,构造一个覆盖细胞面积的<code>Uint8Array</code>缓冲区,迭代每个细胞,并分别根据 细胞是死还是活,绘制白色或黑色矩形. 通过使用 <code>idx</code> 和 覆盖,我们避免在每个<code>tick</code>上跨越边界复制单元格.</p>
<pre><code class="language-js">// Import the WebAssembly memory at the top of the file.
import {memory} from './wasm_game_of_life_bg';

// ...

const getIndex = (row, column) =&gt; {
  return row * width + column;
};

const drawCells = () =&gt; {
  const cellsPtr = universe.cells(); // &lt; universe's cells
  const cells = new Uint8Array(memory.buffer, cellsPtr, width * height);

  ctx.beginPath();

  for (let row = 0; row &lt; height; row++) {
    for (let col = 0; col &lt; width; col++) {
      const idx = getIndex(row, col);

      ctx.fillStyle = cells[idx] === DEAD ? DEAD_COLOR : ALIVE_COLOR;

      ctx.fillRect(
        col * (CELL_SIZE + 1) + 1,
        row * (CELL_SIZE + 1) + 1,
        CELL_SIZE,
        CELL_SIZE
      );
    }
  }

  ctx.stroke();
};
</code></pre>
<p>要开始渲染过程,我们将使用与 上部分相同的代码 来开始渲染循环的第一次迭代:</p>
<pre><code class="language-js">requestAnimationFrame(renderLoop);
</code></pre>
<a class="header" href="print.html#a它工作了" id="a它工作了"><h2>它工作了!</h2></a>
<p>重建 WebAssembly 和 绑定 :</p>
<pre><code>npm run build-debug
</code></pre>
<p>确保您的开发服务器仍在运行. 如果不是,请再次启动:</p>
<pre><code>npm run serve
</code></pre>
<p>如果你刷新<a href="http://localhost:8080/">http://localhost:8080/</a>,你应该受到令人兴奋的展示!</p>
<p><a href="./images/game-of-life/initial-game-of-life.png"><img src="./images/game-of-life/initial-game-of-life.png" alt="Screenshot of the Game of Life implementation" /></a></p>
<p>您可以 checkout <code>chapter-one</code> branch 找到完整代码.</p>
<p>还有一个非常巧妙的算法,来实现生命游戏<a href="https://en.wikipedia.org/wiki/Hashlife">hashlife</a>. 它使用积极的记忆,实际上可以获得<em>指数级更快</em>计算后代的时间越长! 鉴于此,您可能想知道为什么我们在本教程中没有实现<code>hashlife</code>. 因为它超出了本文的范围,我们专注于 Rust 和 WebAssembly 集成,但我们强烈建议您自己去了解<code>hashlife</code>!</p>
<a class="header" href="print.html#a练习-2" id="a练习-2"><h2>练习</h2></a>
<ul>
<li>
<p>使用单个太空飞船,初始化宇宙.</p>
</li>
<li>
<p>不是硬编码最初的宇宙,而是生成一个随机的,有五十五个细胞活着或死亡的机会.</p>
<p><em>提示: 使用<code>wasm_bindgen</code> import <code>Math.random</code> JavaScript 函数:</em></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
extern {
    #[wasm_bindgen(js_namespace = Math)]
    fn random() -&gt; f64;
}
#}</code></pre></pre>
</li>
<li>
<p>用 一个字节 表示 每个单元格 可以很容易地迭代单元格,但这是以浪费内存为代价的. 每个字节是 8 位,但我们只需要 一个位 来表示每个单元 是活还是死. 重构数据表示,以便每个单元,仅使用一个空格位.</p>
</li>
</ul>
<a class="header" href="print.html#a调试" id="a调试"><h1>调试</h1></a>
<p>在我们编写更多代码之前,我们需要在出现问题时使用一些调试工具.</p>
<a class="header" href="print.html#a使用调试符号构建" id="a使用调试符号构建"><h2>使用调试符号构建</h2></a>
<blockquote>
<p>⚡ 调试时,请务必确保使用调试符号构建!</p>
</blockquote>
<p>如果您没有启用调试符号,那么<code>&quot;name&quot;</code>部分将不会出现在<code>.wasm</code>二进制编译中和堆栈跟踪将具有类似的函数名称<code>wasm[42]</code>而不是<code>wasm_game_of_life::Universe::live_neighbor_count</code>.</p>
<p>使用&quot;debug&quot;版本时 (又称<code>npm run build-debug</code>) 默认情况下启用调试符号.</p>
<p>使用&quot;release&quot;构建时,默认情况下不启用调试符号. 要启用调试符号,请确保您<code>debug = true</code>在<code>Cargo.toml</code>的<code>[profile.release]</code>:</p>
<pre><code class="language-toml">[profile.release]
debug = true
</code></pre>
<p>默认情况下我们一直在使用的项目模板添加了这个<code>Cargo.toml</code>,为方便起见.</p>
<a class="header" href="print.html#a记录" id="a记录"><h2>记录</h2></a>
<p>记录是我们用来证明和反驳我们的程序错误原因的最有效工具之一. 在 web 上,<code>console.log</code> 是将消息记录到浏览器的开发人员工具控制台的方法. 我们可以用<code>wasm_bindgen</code>导入对它的引用,如下所示:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
extern {
    #[wasm_bindgen(js_namespace = console)]
    fn log(msg: &amp;str);
}

// A macro to 提供 `println!(..)`-style syntax 给 `console.log` logging.
macro_rules! log {
    ($($t:tt)*) =&gt; (log(&amp;format!($($t)*)))
}
#}</code></pre></pre>
<p>然后,我们可以通过在 Rust 代码中,插入<code>log</code>调用将消息记录到控制台. 例如,要记录每个单元的状态,活动邻居数和下一个状态,我们可以像这样修改我们的代码:</p>
<pre><code class="language-diff">diff --git a/src/lib.rs b/src/lib.rs
index f757641..a30e107 100755
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -63,6 +63,11 @@ impl Universe {
                 let cell = self.cells[idx];
                 let live_neighbors = self.live_neighbor_count(row, col);

+                log!(
+                    &quot;cell[{}, {}] is initially {:?} and has {} live neighbors&quot;,
+                    row, col, cell, live_neighbors
+                );
+
                 let next_cell = match (cell, live_neighbors) {
                     // Rule 1: Any live cell with fewer than two live neighbours
                     // dies, as if caused by underpopulation.
@@ -80,6 +85,8 @@ impl Universe {
                     (otherwise, _) =&gt; otherwise,
                 };

+                log!(&quot;    it becomes {:?}&quot;, next_cell);
+
                 next[idx] = next_cell;
             }
         }
</code></pre>
<p><code>console.log</code>或者<code>console.error</code>函数具有相同的接口<code>,但是,</code>console.error`在开发人员工具也倾向于在记录消息时捕获并显示堆栈跟踪用来.</p>
<a class="header" href="print.html#a参考" id="a参考"><h3>参考</h3></a>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Console">该<code>console</code>对象</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Tools/Web_Console">Firefox 开发人员工具 - Web 控制台</a></li>
<li><a href="https://docs.microsoft.com/en-us/microsoft-edge/devtools-guide/console">Microsoft Edge 开发人员工具 - 控制台</a></li>
<li><a href="https://developers.google.com/web/tools/chrome-devtools/console/get-started">开始使用 Chrome DevTools 控制台</a></li>
</ul>
<a class="header" href="print.html#a崩溃日志" id="a崩溃日志"><h2>崩溃日志</h2></a>
<p><a href="https://github.com/rustwasm/console_error_panic_hook">这 <code>console_error_panic_hook</code> 箱子 通过<code>console.error</code>为开发者记录了异常的崩溃</a> 而不是得到 怪异的,
难以调试的 <code>RuntimeError: unreachable executed</code> 错误信息, 它会给你格式化的崩溃信息.</p>
<p>做到这些, 你只需要在初始化函数中载入钩子或者适应下面的通用代码:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate console_error_panic_hook;

// Expose an `init` function to be called by JS after instantiating the wasm
// module which installs the `console.error` panic hook.
#[wasm_bindgen]
pub fn init() {
    use std::panic;
    panic::set_hook(Box::new(console_error_panic_hook::hook));
}

// OR

// Ensure the the panic hook is set on some common code path. Under the hood,
// this makes sure that it is only installed once.
console_error_panic_hook::set_once();
#}</code></pre></pre>
<a class="header" href="print.html#a使用调试器" id="a使用调试器"><h2>使用调试器</h2></a>
<p>不幸的是,WebAssembly 的调试仍然不成熟. 在大多数 Unix 系统上,<a href="http://dwarfstd.org/">DWARF</a>用于编码调试器提供正在运行的程序的源级检查的信息. 在 Windows 上有一种替代格式可以编码类似的信息. 目前, WebAssembly 没有等价物. 因此,调试器目前提供有限的实用程序,我们最终逐步执行编译器发出的原始 WebAssembly 指令,而不是我们编写的 Rust 源文本.</p>
<p>尽管如此,调试器仍然可用于检查 与 WebAssembly 交互的 JavaScript. 例如,我们可以使用调试器在我们的<code>renderLoop</code>函数每次迭代中暂停. 这为我们提供了一个方便的检查点,用于检查记录的消息,并将当前呈现的帧与前一帧进行比较.</p>
<p><a href="./images/game-of-life/debugging.png"><img src="./images/game-of-life/debugging.png" alt="Screenshot of debugging the Game of Life" /></a></p>
<a class="header" href="print.html#a参考-1" id="a参考-1"><h3>参考</h3></a>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Tools/Debugger">Firefox 开发者工具 - 调试器</a></li>
<li><a href="https://docs.microsoft.com/en-us/microsoft-edge/devtools-guide/debugger">Microsoft Edge 开发人员工具 - 调试器</a></li>
<li><a href="https://developers.google.com/web/tools/chrome-devtools/javascript/">开始在 Chrome DevTools 中调试 JavaScript</a></li>
</ul>
<a class="header" href="print.html#a首先避免调试-webassembly" id="a首先避免调试-webassembly"><h2>首先避免调试 WebAssembly</h2></a>
<p>虽然一些错误特定于 JavaScript 和 WebAssembly 的接口,但经验表明大多数错误都没有. 尝试将 bug 重现 通过正常的 Rust<code>#[test]</code>函数,您可以在调试时利用操作系统的成熟工具. 使用测试箱子<a href="https://crates.io/crates/quickcheck"><code>quickcheck</code></a>练习您向 JavaScript 公开的接口. 最终,如果您可以在不需要与 JavaScript 交互 的小测试用例中隔离它们,您将更容易找到并修复错误.</p>
<p>注意,为了运行<code>#[test]</code>没有编译器和链接器错误,你需要添加<code>#![wasm_bindgen]</code>注释和<code>crate-type = &quot;cdylib&quot;</code>.</p>
<a class="header" href="print.html#a练习-3" id="a练习-3"><h2>练习</h2></a>
<ul>
<li>
<p>添加日志记录到<code>tick</code>函数,记录每个单元格的行和列 - 状态从活动转换为死亡,反之亦然.</p>
</li>
<li>
<p>介绍一个<code>panic!()</code>在<code>Universe::new</code>方法里面. 在 Web 浏览器的 JavaScript 调试器 中检查恐慌的回溯. 禁用调试符号,重建并再次检查堆栈跟踪. 不是很有用,是吗?</p>
</li>
<li>
<p>checkout <code>chapter-one-with-bug</code> branch. 重建并重新加载网页. 现在很明显, 这个分支的实现包含一个<code>bug</code>, 每个单元格显然都是活着的. 这是您的作者在最初创建示例代码时, 所犯的真实世界 (tm) 错误. 找到错误并修复它. _不要看提交历史! 那是作弊 ;-) _</p>
</li>
</ul>
<a class="header" href="print.html#a增加交互性" id="a增加交互性"><h1>增加交互性</h1></a>
<p>我们将通过在 Game of Life 实现中, 添加一些交互功能来继续探索 JavaScript和WebAssembly接口. 我们将允许用户通过单击,来切换单元格是活着还是死亡,并允许暂停游戏,这使得绘制单元格模式更加容易.</p>
<a class="header" href="print.html#a暂停和恢复游戏" id="a暂停和恢复游戏"><h2>暂停和恢复游戏</h2></a>
<p>让我们添加一个按钮来切换游戏是正在播放还是暂停. 到<code>index.html</code>,在<code>&lt;canvas&gt;</code>上方添加按钮:</p>
<pre><code class="language-html">&lt;button id=&quot;play-pause&quot;&gt;&lt;/button&gt;
</code></pre>
<p>在 JavaScript 中,我们将进行以下更改:</p>
<ul>
<li>
<p>跟踪最新返回的标识符<code>requestAnimationFrame</code>,
以便我们可以通过调用<code>cancelAnimationFrame</code>取消那个标识符动画.</p>
</li>
<li>
<p>单击播放/暂停按钮时,检查我们是否具有排队动画帧的标识符.
1.点击时,游戏当前正在播放,取消动画帧<code>renderLoop</code>,有效地暂停游戏.
2.点击时,当前暂停,没有排队动画帧的标识符,我们想运行<code>requestAnimationFrame</code>恢复比赛.</p>
</li>
</ul>
<p>因为 JavaScript 正在驱动 Rust和WebAssembly,所以我们需要这样做,而且我们不需要更改 Rust源代码.</p>
<p>我们介绍一下<code>animationId</code>变量来跟踪返回的标识符<code>requestAnimationFrame</code>. 当没有排队的动画帧时,我们将此变量设置为<code>null</code>.</p>
<pre><code class="language-js">let animationId = null;

// This function is the same as before, except the
// result of `requestAnimationFrame` is assigned to
// `animationId`.
const renderLoop = () =&gt; {
  universe.tick();

  drawCells();
  drawGrid();

  animationId = requestAnimationFrame(renderLoop);
};
</code></pre>
<p>在任何时刻,我们都可以通过<code>animationId</code>检查游戏,来判断游戏是否暂停:</p>
<pre><code class="language-js">const isPaused = () =&gt; {
  return animationId === null;
};
</code></pre>
<p>现在,当点击 播放/暂停 按钮时,我们会检查游戏当前是暂停还是正在播放,要么继续播放<code>renderLoop</code>动画要么取消下一个动画帧.
此外,我们更新按钮的文本图标,以反映按钮在下次单击时将执行的操作.</p>
<pre><code class="language-js">const playPauseButton = document.getElementById(&quot;play-pause&quot;);

const play = () =&gt; {
  playPauseButton.textContent = &quot;⏸&quot;;
  renderLoop();
};

const pause = () =&gt; {
  playPauseButton.textContent = &quot;▶&quot;;
  cancelAnimationFrame(animationId);
  animationId = null;
};

playPauseButton.addEventListener(&quot;click&quot;, event =&gt; {
  if (isPaused()) {
    play();
  } else {
    pause();
  }
});
</code></pre>
<p>最后,我们直接调用<code>requestAnimationFrame(renderLoop)</code>用来启动之前的游戏及其动画,
但我们想用<code>play</code>替换它,以便按钮获得正确的初始文本图标.</p>
<pre><code class="language-diff">// This used to be `requestAnimationFrame(renderLoop)`.
play();
</code></pre>
<p>刷新<a href="http://localhost:8080/">http://localhost:8080/</a>现在你应该可以通过点击按钮来暂停和恢复游戏!</p>
<a class="header" href="print.html#a切换一个cell的状态click活动" id="a切换一个cell的状态click活动"><h2>切换一个Cell的状态<code>&quot;click&quot;</code>活动</h2></a>
<p>现在我们可以暂停游戏了,现在是时候添加通过点击它们来改变细胞的能力了.</p>
<p>切换单元格是将其状态从活动状态转换为死亡状态,或从死亡状态转换为活动状态:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Cell {
    fn toggle(&amp;mut self) {
        *self = match *self {
            Cell::Dead =&gt; Cell::Alive,
            Cell::Alive =&gt; Cell::Dead,
        };
    }
}
#}</code></pre></pre>
<p>要切换给定行和列的单元格状态,我们将行和列对转换为单元格向量的索引,并在该索引处的单元格上调用<code>toggle</code>方法:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// Public methods, exported to JavaScript.
#[wasm_bindgen]
impl Universe {
    // ...

    pub fn toggle_cell(&amp;mut self, row: u32, column: u32) {
        let idx = self.get_index(row, column);
        self.cells[idx].toggle();
    }
}
#}</code></pre></pre>
<p>这个方法是在<code>impl</code>带有注释的块<code>#[wasm_bindgen]</code>这样它就可以被 JavaScript 调用.</p>
<p>在 JavaScript 中,我们会监听 点击事件<code>&lt;canvas&gt;</code>元素,将 <code>click事件</code>的页面 相对坐标转换为画布相对坐标,
然后转换为行和列,调用<code>toggle_cell</code>方法,最后重绘场景.</p>
<pre><code class="language-js">canvas.addEventListener(&quot;click&quot;, event =&gt; {
  const boundingRect = canvas.getBoundingClientRect();

  const scaleX = canvas.width / boundingRect.width;
  const scaleY = canvas.height / boundingRect.height;

  const canvasLeft = (event.clientX - boundingRect.left) * scaleX;
  const canvasTop = (event.clientY - boundingRect.top) * scaleY;

  const row = Math.min(Math.floor(canvasTop / (CELL_SIZE + 1)), height - 1);
  const col = Math.min(Math.floor(canvasLeft / (CELL_SIZE + 1)), width - 1);

  universe.toggle_cell(row, col);

  drawCells();
  drawGrid();
});
</code></pre>
<p>刷新<a href="http://localhost:8080/">http://localhost:8080/</a>再次,您现在可以通过单击单元格并切换其状态来绘制自己的模式.</p>
<p>您可以在 checkout <code>chapter-two</code> branch , 找到此实现的完整源代码.</p>
<a class="header" href="print.html#a练习-4" id="a练习-4"><h2>练习</h2></a>
<ul>
<li>
<p>添加一个<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/range"><code>&lt;input type=&quot;range&quot;&gt;</code></a>用于控制每个动画帧出现多少<code>tick</code>的小部件.</p>
</li>
<li>
<p>添加一个将<code>Universe</code>重置为随机初始状态的按钮. 另一个按钮将宇宙重置为所有死细胞.</p>
</li>
<li>
<p><code>Ctrl + Click</code>,插入一个<a href="https://en.wikipedia.org/wiki/Glider_(Conway%27s_Life)">滑翔机</a>以目标细胞为中心. 上<code>Shift + Click</code>,插入一个脉冲星.</p>
</li>
</ul>
<a class="header" href="print.html#a时间分析" id="a时间分析"><h1>时间分析</h1></a>
<p>本章介绍如何使用 Rust 和 WebAssembly 来分析 Web 页面,其目标是提高吞吐量或降低延迟.</p>
<blockquote>
<p>⚡ 始终确保使用的是<code>--release</code>分析! 使用我们的项目模板,这意味着使用<code>npm run build-release</code>代替<code>npm run build-debug</code>.</p>
</blockquote>
<a class="header" href="print.html#a可用工具" id="a可用工具"><h2>可用工具</h2></a>
<a class="header" href="print.html#a该performancenow计时器" id="a该performancenow计时器"><h3>该<code>performance.now()</code>计时器</h3></a>
<p>该<a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/now"><code>performance.now()</code></a>函数返回,自加载网页以来以毫秒为单位测量的单调时间戳. 我们可以使用它来计算各种操作的时间,我们可以通过以下方式 从 Rust 访问它,通过<code>wasm_bindgen</code>导入申报:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
extern {
    #[wasm_bindgen(js_namespace = performance)]
    fn now() -&gt; f64;
}
#}</code></pre></pre>
<p>调用<code>performance.now</code>开销很小,因此我们可以从中创建简单的测量,而不会扭曲系统其他部分的性能.</p>
<p>例如,我们可以创建一个简单的 <code>FPS-帧数</code> 计数器,我们在每次迭代<code>renderLoop</code>时更新.</p>
<p>让我们开始在<code>index.js</code>添加一个<code>fps</code>对象</p>
<pre><code class="language-js">const fps = new class {
  constructor() {
    this.fps = document.getElementById('fps');
    this.frames = [];
    this.lastFrameTimeStamp = performance.now();
  }

  render() {
    // 时间计算.
    const now = performance.now();
    const delta = now - this.lastFrameTimeStamp;
    this.lastFrameTimeStamp = now;
    const fps = (1 / delta) * 1000;

    // Save only the latest 100 timings.
    this.frames.push(fps);
    if (this.frames.length &gt; 100) {
      this.frames.shift();
    }

    // 找出我们100个最新时间的最大值，最小值和平均值.
    let min = Infinity;
    let max = -Infinity;
    let sum = 0;
    for (let i = 0; i &lt; this.frames.length; i++) {
      sum += this.frames[i];
      min = Math.min(this.frames[i], min);
      max = Math.max(this.frames[i], max);
    }
    let mean = sum / this.frames.length;

    // Render the statistics.
    this.fps.textContent = `
Frames per Second:
         latest = ${Math.round(fps)}
avg of last 100 = ${Math.round(mean)}
min of last 100 = ${Math.round(min)}
max of last 100 = ${Math.round(max)}
`.trim();
  }
}();
</code></pre>
<p>接下来 我们运行 <code>fps</code> <code>render</code> 函数 ,在每次迭代<code>renderLoop</code>时更新:</p>
<pre><code class="language-js">const renderLoop = () =&gt; {
  fps.render(); //new

  universe.tick();
  drawCells();
  drawGrid();

  animationId = requestAnimationFrame(renderLoop);
};
</code></pre>
<p>最后, 不要忘记添加 <code>fps</code> 元素 到 <code>index.html</code>:</p>
<pre><code class="language-html">    &lt;div id=&quot;fps&quot;&gt;&lt;div&gt;
</code></pre>
<p>噢耶! 现在你有了一个 FPS 计数器!</p>
<a class="header" href="print.html#a开发人员工具-profilers" id="a开发人员工具-profilers"><h3>开发人员工具 Profilers</h3></a>
<p>所有 Web 浏览器 的内置开发人员工具都包含一个分析器. 这些分析器显示哪些函数花费最多时间的可视化,如调用树和火焰图. 如果你<a href="./game-of-life/debugging.html#building-with-debug-symbols">用调试符号构建</a>,然后这些分析器应该显示 Rust 函数名称 而不是像<code>wasm-function[123]</code>. 请注意这些分析器<em>惯于</em>显示内联函数,由于 Rust 和 LLVM 依赖于如此大量的内联,结果可能会有点令人困惑.</p>
<p><a href="./images/game-of-life/profiler-with-rust-names.png"><img src="./images/game-of-life/profiler-with-rust-names.png" alt="Screenshot of profiler with Rust symbols" /></a></p>
<a class="header" href="print.html#a资源" id="a资源"><h4>资源</h4></a>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Tools/Performance">Firefox 开发者工具 - 性能</a></li>
<li><a href="https://docs.microsoft.com/en-us/microsoft-edge/devtools-guide/performance">Microsoft Edge 开发人员工具 - 性能</a></li>
<li><a href="https://developers.google.com/web/tools/chrome-devtools/rendering-tools/js-execution">Chrome DevTools JavaScript Profiler</a></li>
</ul>
<a class="header" href="print.html#consoletime和consoletimeend功能" id="consoletime和consoletimeend功能"><h3><code>console.time</code>和<code>console.timeEnd</code>功能</h3></a>
<p><code>console.time</code>和<code>console.timeEnd</code>函数允许您将命名操作的时间记录到浏览器的开发人员工具控制台.</p>
<p>你可以用它将它们导入 Rust<code>wasm-bindgen</code> 声明中:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
extern {
    #[wasm_bindgen(js_namespace = console)]
    fn time(name: &amp;str);

    #[wasm_bindgen(js_namespace = console)]
    fn timeEnd(name: &amp;str);
}
#}</code></pre></pre>
<p>因为<code>console.timeEnd</code>有对应的<code>console.time</code>调用,将它们包装在 RAII 类型中很方便:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Timer&lt;'a&gt; {
    name: &amp;'a str,
}

impl&lt;'a&gt; Timer&lt;'a&gt; {
    pub fn new(name: &amp;'a str) -&gt; Timer&lt;'a&gt; {
        time(name);
        Timer { name }
    }
}

impl&lt;'a&gt; Drop for Timer&lt;'a&gt; {
    fn drop(&amp;mut self) {
        timeEnd(self.name);
    }
}
#}</code></pre></pre>
<p>然后,我们可以计算每个时间<code>Universe::tick</code>,将此代码段添加到方法的顶部:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let _timer = Timer::new(&quot;Universe::tick&quot;);
#}</code></pre></pre>
<p>现在每次运行的时间<code>Universe::tick</code>都会记录了:</p>
<p><a href="./images/game-of-life/console-time.png"><img src="./images/game-of-life/console-time.png" alt="Screenshot of console.time logs" /></a></p>
<p>另外,<code>console.time</code>和<code>console.timeEnd</code>对将显示在,浏览器的分析器的&quot;timeline&quot;或&quot;waterfall&quot;视图中:</p>
<p><a href="./images/game-of-life/console-time-in-profiler.png"><img src="./images/game-of-life/console-time-in-profiler.png" alt="Screenshot of console.time logs" /></a></p>
<a class="header" href="print.html#a运用bench与本地代码" id="a运用bench与本地代码"><h3>运用<code>#[bench]</code>与本地代码</h3></a>
<p>我们通常也可以通过编写,来利用我们操作系统的本机代码调试工具<code>#[test]</code>而不是在 Web 上调试,我们也可以通过编写<code>#[bench]</code>功能.</p>
<p>然而!在为本机代码分析投入大量精力之前,请确保您知道瓶颈在 WebAssembly 中! 使用浏览器的分析器确认这一点,否则您可能会浪费时间来优化不热的代码.</p>
<a class="header" href="print.html#a发展我们的生命博弈宇宙" id="a发展我们的生命博弈宇宙"><h2>发展我们的生命博弈宇宙</h2></a>
<p>如果我们让我们的生命游戏世界更大,会发生什么? 使用 128 x 128 宇宙替换 64 x 64 宇宙导致 FPS 从 平滑的 60 下降到 40-ish.</p>
<p>如果我们记录一个配置文件并查看瀑布视图,我们会看到每个动画帧花费超过 20 毫秒. 回想一下,每秒 60 帧,每帧大概 16 毫秒. 16 毫秒内不仅仅是有我们的 JavaScript 和 WebAssembly ,还有浏览器正在做的其他事情,比如绘制页面.</p>
<p><a href="./images/game-of-life/drawCells-before-waterfall.png"><img src="./images/game-of-life/drawCells-before-waterfall.png" alt="Screenshot of a waterfall view of rendering a frame" /></a></p>
<p>如果我们看一下单个动画帧中发生的事情,我们就会看到<code>CanvasRenderingContext2D.fillStyle</code> 很长!</p>
<p><a href="./images/game-of-life/drawCells-before-flamegraph.png"><img src="./images/game-of-life/drawCells-before-flamegraph.png" alt="Screenshot of a flamegraph view of rendering a frame" /></a></p>
<p>我们可以通过查看调用树的多个帧的聚合来确认这不是异常:</p>
<p><a href="./images/game-of-life/drawCells-before-calltree.png"><img src="./images/game-of-life/drawCells-before-calltree.png" alt="Screenshot of a flamegraph view of rendering a frame" /></a></p>
<p>我们将近 40%的时间都花在了这个函数身上!</p>
<blockquote>
<p>⚡ 我们可能对此有所期待<code>tick</code>方法是性能瓶颈,但事实并非如此. 让分析引导您的注意力,而不是把时间花在您想当然的地方.</p>
</blockquote>
<p>在<code>drawCells</code>函数,在每个动画帧上,<code>fillStyle</code>为宇宙中的每个单元格设置一次:</p>
<pre><code class="language-js">for (let row = 0; row &lt; height; row++) {
  for (let col = 0; col &lt; width; col++) {
    const idx = getIndex(row, col);

    ctx.fillStyle = cells[idx] === DEAD ? DEAD_COLOR : ALIVE_COLOR;

    ctx.fillRect(
      col * (CELL_SIZE + 1) + 1,
      row * (CELL_SIZE + 1) + 1,
      CELL_SIZE,
      CELL_SIZE
    );
  }
}
</code></pre>
<p>现在我们已经发现了这个<code>fillStyle</code>是如此昂贵,我们可以做些什么来避免经常设置它? 改变<code>fillStyle</code>取决于细胞是活着还是死亡. 如果我们设定<code>fillStyle = ALIVE_COLOR</code>, 然后在一次总绘制每个活细胞,然后设置<code>fillStyle = DEAD_COLOR</code>,并在另一次总绘制每个死细胞,那么我们只设置<code>fillStyle</code>两次,而不是每个细胞一次.</p>
<pre><code class="language-js">// Alive cells.
ctx.fillStyle = ALIVE_COLOR;
for (let row = 0; row &lt; height; row++) {
  for (let col = 0; col &lt; width; col++) {
    const idx = getIndex(row, col);
    if (cells[idx] !== ALIVE) {
      continue;
    }

    ctx.fillRect(
      col * (CELL_SIZE + 1) + 1,
      row * (CELL_SIZE + 1) + 1,
      CELL_SIZE,
      CELL_SIZE
    );
  }
}

// Dead cells.
ctx.fillStyle = DEAD_COLOR;
for (let row = 0; row &lt; height; row++) {
  for (let col = 0; col &lt; width; col++) {
    const idx = getIndex(row, col);
    if (cells[idx] !== DEAD) {
      continue;
    }

    ctx.fillRect(
      col * (CELL_SIZE + 1) + 1,
      row * (CELL_SIZE + 1) + 1,
      CELL_SIZE,
      CELL_SIZE
    );
  }
}
</code></pre>
<p>保存这些更改并刷新后<a href="http://localhost:8080/">http://localhost:8080/</a>,渲染回到平滑每秒 60 帧.</p>
<p>如果我们采用另一个配置文件,我们可以看到现在每个动画帧只花费大约 10 毫秒.</p>
<p><a href="./images/game-of-life/drawCells-after-waterfall.png"><img src="./images/game-of-life/drawCells-after-waterfall.png" alt="Screenshot of a waterfall view of rendering a frame after the drawCells changes" /></a></p>
<p>打破了超时帧,我们看到了<code>fillStyle</code>昂贵的成本消失了,我们的大部分时间花在了内部<code>fillRect</code>,绘制每个单元格的矩形.</p>
<p><a href="./images/game-of-life/drawCells-after-flamegraph.png"><img src="./images/game-of-life/drawCells-after-flamegraph.png" alt="Screenshot of a flamegraph view of rendering a frame after the drawCells changes" /></a></p>
<a class="header" href="print.html#a让时间更快" id="a让时间更快"><h2>让时间更快</h2></a>
<p>有些人不喜欢等待,认为每个动画帧是 9 个 <code>tick</code>. 我们可以修改<code>renderLoop</code>函数,这很容易做到这一点:</p>
<pre><code class="language-js">for (let i = 0; i &lt; 9; i++) {
  universe.tick();
}
</code></pre>
<p>在我的机器上,这使我们恢复到每秒 35 帧. 不好. 我们想要那个美丽的 <code>60!</code></p>
<p>现在我们知道时间花在了<code>Universe::tick</code>,让我们添加一些<code>Timer</code>,用它来包装,给予<code>console.time</code>和<code>console.timeEnd</code>运行,引导我们. 我的假设是,分配一个新的细胞载体,并在每个滴答上释放旧的是昂贵的成本,占用了我们时间预算的很大一部分.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn tick(&amp;mut self) {
    let _timer = Timer::new(&quot;Universe::tick&quot;);

    let mut next = {
        let _timer = Timer::new(&quot;allocate next cells&quot;);
        self.cells.clone()
    };

    {
        let _timer = Timer::new(&quot;new generation&quot;);
        for row in 0..self.height {
            for col in 0..self.width {
                let idx = self.get_index(row, col);
                let cell = self.cells[idx];
                let live_neighbors = self.live_neighbor_count(row, col);

                let next_cell = match (cell, live_neighbors) {
                    // Rule 1: Any live cell with fewer than two live neighbours
                    // dies, as if caused by underpopulation.
                    (Cell::Alive, x) if x &lt; 2 =&gt; Cell::Dead,
                    // Rule 2: Any live cell with two or three live neighbours
                    // lives on to the next generation.
                    (Cell::Alive, 2) | (Cell::Alive, 3) =&gt; Cell::Alive,
                    // Rule 3: Any live cell with more than three live
                    // neighbours dies, as if by overpopulation.
                    (Cell::Alive, x) if x &gt; 3 =&gt; Cell::Dead,
                    // Rule 4: Any dead cell with exactly three live neighbours
                    // becomes a live cell, as if by reproduction.
                    (Cell::Dead, 3) =&gt; Cell::Alive,
                    // All other cells remain in the same state.
                    (otherwise, _) =&gt; otherwise,
                };

                next[idx] = next_cell;
            }
        }
    }

    let _timer = Timer::new(&quot;free old cells&quot;);
    self.cells = next;
}
#}</code></pre></pre>
<p>看看时间,很明显我的假设是不正确的: 实际上绝大部分时间花在,计算下一代细胞上. 令人惊讶的是,在每个单元上分配和释放载体似乎具有可忽略的成本. 再一次告诉指导我们的分析工作!</p>
<p><a href="./images/game-of-life/console-time-in-universe-tick.png"><img src="./images/game-of-life/console-time-in-universe-tick.png" alt="Screenshot of a Universe::tick timer results" /></a></p>
<p>我们可以写一个本机代码<code>#[bench]</code>来做同样的事情 - 我们的 WebAssembly 正在做的, 但我们可以使用更成熟的分析工具. 这就是新的<code>benches/bench.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![feature(test)]

#fn main() {
extern crate test;
extern crate wasm_game_of_life;

#[bench]
fn universe_ticks(b: &amp;mut test::Bencher) {
    let mut universe = wasm_game_of_life::Universe::new();

    b.iter(|| {
        universe.tick();
    });
}
#}</code></pre></pre>
<p>我们还要给上所有的<code>#[wasm_bindgen]</code>注释和<code>&quot;cdylib&quot;</code> - 来自<code>Cargo.toml</code>, 否则构建本机代码将失败并出现链接错误.</p>
<p>有了这一切,我们就可以运行了<code>cargo bench</code>编译并运行我们的基准测试!</p>
<pre><code>$ cargo bench
    Finished release [optimized + debuginfo] target(s) in 0.0 secs
     Running target/release/deps/wasm_game_of_life-91574dfbe2b5a124

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/release/deps/bench-8474091a05cfa2d9

running 1 test
test universe_ticks ... bench:     664,421 ns/iter (+/- 51,926)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured; 0 filtered out
</code></pre>
<p>这也告诉我们二进制文件的位置,我们可以再次运行基准测试,但这次是在我们的操作系统的分析器下. 就我而言,我运行在 Linux,所以<a href="https://perf.wiki.kernel.org/index.php/Main_Page"><code>perf</code></a>是我将使用的探查器:</p>
<pre><code>$ perf record -g target/release/deps/bench-8474091a05cfa2d9 --bench
running 1 test
test universe_ticks ... bench:     635,061 ns/iter (+/- 38,764)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured; 0 filtered out

[ perf record: Woken up 1 times to write data ]
[ perf record: Captured and wrote 0.178 MB perf.data (2349 samples) ]
</code></pre>
<p>使用<code>perf report</code>加载配置文件后,表明我们所有的时间都花在了<code>Universe::tick</code>,如预期的那样:</p>
<p><a href="./images/game-of-life/bench-perf-report.png"><img src="./images/game-of-life/bench-perf-report.png" alt="Screenshot of perf report" /></a></p>
<p><code>perf</code>注释说明函数的时间,通过指令<code>a</code>:</p>
<p><a href="./images/game-of-life/bench-perf-annotate.png"><img src="./images/game-of-life/bench-perf-annotate.png" alt="Screenshot of perf's instruction annotation" /></a></p>
<p>这告诉我们 <code>26.67%</code> 的时间用于求和相邻单元格的值,<code>23.41%</code> 的时间用于获取邻居的列索引,另外 <code>15.42%</code> 的时间用于获取邻居的行索引. 在这三个最昂贵的指令中,第二个和第三个指令都很昂贵之于<code>div 说明</code>. <code>div</code>实现模数索引逻辑在<code>Universe::live_neighbor_count</code>.</p>
<p>回想一下<code>live_neighbor_count</code>定义:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn live_neighbor_count(&amp;self, row: u32, column: u32) -&gt; u8 {
    let mut count = 0;
    for delta_row in [self.height - 1, 0, 1].iter().cloned() {
        for delta_col in [self.width - 1, 0, 1].iter().cloned() {
            if delta_row == 0 &amp;&amp; delta_col == 0 {
                continue;
            }

            let neighbor_row = (row + delta_row) % self.height;
            let neighbor_col = (column + delta_col) % self.width;
            let idx = self.get_index(neighbor_row, neighbor_col);
            count += self.cells[idx] as u8;
        }
    }
    count
}
#}</code></pre></pre>
<p>我们使用 多条件 的原因是为了避免使代码混乱, 通过使用<code>if</code>,第一行或最后一行或列边缘情况的条件. 但我们付出的代价是<code>div</code>, 也就是最常见的情况,既不是<code>row</code>也不是<code>column</code>,而是在宇宙的边缘,他们不需要模数包裹处理. 相反,如果我们使用多个<code>if</code>为边缘情况,并展开此循环,CPU 的分支预测器<em>应该</em>可以很好地预测它.</p>
<p>我们改写<code>live_neighbor_count</code>,像这样这个:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn live_neighbor_count(&amp;self, row: u32, column: u32) -&gt; u8 {
    let mut count = 0;

    let north = if row == 0 {
        self.height - 1
    } else {
        row - 1
    };

    let south = if row == self.height - 1 {
        0
    } else {
        row + 1
    };

    let west = if column == 0 {
        self.width - 1
    } else {
        column - 1
    };

    let east = if column == self.width - 1 {
        0
    } else {
        column + 1
    };

    let nw = self.get_index(north, west);
    count += self.cells[nw] as u8;

    let n = self.get_index(north, column);
    count += self.cells[n] as u8;

    let ne = self.get_index(north, east);
    count += self.cells[ne] as u8;

    let w = self.get_index(row, west);
    count += self.cells[w] as u8;

    let e = self.get_index(row, east);
    count += self.cells[e] as u8;

    let sw = self.get_index(south, west);
    count += self.cells[sw] as u8;

    let s = self.get_index(south, column);
    count += self.cells[s] as u8;

    let se = self.get_index(south, east);
    count += self.cells[se] as u8;

    count
}
#}</code></pre></pre>
<p>现在让我们再次运行基准测试!</p>
<pre><code>$ cargo bench
   Compiling wasm_game_of_life v0.1.0 (file:///home/fitzgen/wasm_game_of_life)
    Finished release [optimized + debuginfo] target(s) in 0.82 secs
     Running target/release/deps/wasm_game_of_life-91574dfbe2b5a124

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/release/deps/bench-8474091a05cfa2d9

running 1 test
test universe_ticks ... bench:      87,258 ns/iter (+/- 14,632)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured; 0 filtered out
</code></pre>
<p>看起来好多了! 我们可以看到它有多好,通过<a href="https://github.com/BurntSushi/cargo-benchcmp"><code>cargo benchcmp</code></a>工具:</p>
<pre><code>$ cargo benchcmp before.txt after.txt
 name            before.txt ns/iter  after.txt ns/iter  diff ns/iter   diff %  speedup
 universe_ticks  664,421             87,258                 -577,163  -86.87%   x 7.61
</code></pre>
<p>哇! 7.61 倍加速!</p>
<p>WebAssembly 映射到常见的硬件架构,但我们确实需要为这个本机代码加速.</p>
<p>让我们恢复所有<code>#[wasm_bindgen]</code>注释,重建<code>.wasm</code>同<code>npm run build-release</code>,并刷新<a href="http://localhost:8080/">http://localhost:8080/</a>. 在我的机器上,页面再次以每秒 60 帧的速度运行,并且使用浏览器的分析器记录,另一个配置文件显示每个动画帧大约需要 10 毫秒.</p>
<p>成功!</p>
<p><a href="./images/game-of-life/waterfall-after-branches-and-unrolling.png"><img src="./images/game-of-life/waterfall-after-branches-and-unrolling.png" alt="Screenshot of a waterfall view of rendering a frame after replacing modulos with branches" /></a></p>
<a class="header" href="print.html#a练习-5" id="a练习-5"><h2>练习</h2></a>
<ul>
<li>
<p>在这一点上,下一个加速<code>Universe::tick</code>是删除分配和免费. 实现细胞的双缓冲,其中<code>Universe</code>维护两个向量,并且不释放它们中的任何一个,那么就永远不会分配新的缓冲区<code>tick</code>.</p>
</li>
<li>
<p>从&quot;实现生命&quot;一章的实现是 基于 delta 的设计,其中 Rust 代码 返回 将状态更改为 JavaScript 的单元格列表. 这会使渲染<code>&lt;canvas&gt;</code>更快? 你可以实现这个设计, 而不必在每个滴答上分配一个新的增量列表吗 ?</p>
</li>
<li>
<p>正如我们的分析向我们展示的那样,2D<code>&lt;canvas&gt;</code>渲染速度不是特别快. 用 <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API">WebGL</a> 渲染器替换 2 canvas 渲染器. WebGL 版本的速度有多快 ? 在 WebGL 渲染成为瓶颈之前,你能创造多大的宇宙 ?</p>
</li>
</ul>
<a class="header" href="print.html#a收缩wasm尺寸" id="a收缩wasm尺寸"><h1>收缩<code>.wasm</code>尺寸</h1></a>
<p>本章将教你如何优化你的<code>.wasm</code>大小,以及如何改变Rust源代码以缩小<code>.wasm</code>代码.</p>
<a class="header" href="print.html#a优化代码大小的构建" id="a优化代码大小的构建"><h2>优化代码大小的构建</h2></a>
<p>我们可以使用<code>rustc</code>很多配置选项变小<code>.wasm</code>二进制文件. 在某些情况下,我们的编译时间较长,<code>.wasm</code>更小. 在其他情况下,我们以较小的代码大小交换WebAssembly 的运行时速度. 我们应该认识到每个选项的权衡,并且在我们交换代码大小,概况和度量的运行时速度, 以便做出关于交易是否值得的明智决策.</p>
<a class="header" href="print.html#a禁用调试符号" id="a禁用调试符号"><h3>禁用调试符号</h3></a>
<p>包含用于调试的函数名字符串的部分, 占用的空间比您想象的要多. 如果您没有调试或分析, 并希望生成一个小的<code>.wasm</code>二进制,需要禁用这些名称.</p>
<p>在<code>Cargo.toml</code>设置:</p>
<pre><code class="language-toml">[profile.release]
debug = false
</code></pre>
<a class="header" href="print.html#a使用链接时间优化-lto-进行编译" id="a使用链接时间优化-lto-进行编译"><h3>使用链接时间优化 (LTO) 进行编译</h3></a>
<p>在<code>Cargo.toml</code>,添加<code>lto = true</code>在<code>[profile.release]</code>部分:</p>
<pre><code class="language-toml">[profile.release]
lto = true
</code></pre>
<p>这为 LLVM 提供了更多内联和修剪功能的机会. 它不仅会成功<code>.wasm</code>更小,但它也会在运行时更快! 缺点是编译需要更长时间.</p>
<a class="header" href="print.html#a告诉-llvm-优化大小而不是速度" id="a告诉-llvm-优化大小而不是速度"><h3>告诉 LLVM 优化大小而不是速度</h3></a>
<p>默认情况下,调整LLVM的优化过程是提高速度,而不是大小. 我们可以通过修改目标, 来将目标更改为代码大小</p>
<p><code>[profile.release]</code>部分:</p>
<pre><code class="language-toml">[profile.release]
opt-level = 's'
</code></pre>
<p>或者,更进一步优化尺寸,以更大的速度成本:</p>
<pre><code class="language-toml">[profile.release]
opt-level = 'z'
</code></pre>
<p>请注意,令人惊讶的是,<code>opt-level = &quot;s&quot;</code>,有时会导致 比 <code>opt-level = &quot;z&quot;</code> 更小. 总是要对比看看!</p>
<a class="header" href="print.html#a使用wasm-opt工具" id="a使用wasm-opt工具"><h3>使用<code>wasm-opt</code>工具</h3></a>
<p>该<a href="https://github.com/WebAssembly/binaryen">Binaryen</a>toolkit 是特定于 WebAssembly的编译器工具的集合. 它比LLVM 的WebAssembly后端 更进一步.</p>
<p>使用<code>wasm-opt</code>后,处理 LLVM 生成的<code>.wasm</code>二进制文件通常可以节省15-20%的代码大小. 它通常还能帮运行时加速!</p>
<pre><code class="language-bash"># Optimize for size.
wasm-opt -Os -o output.wasm input.wasm

# Optimize aggressively for size.
wasm-opt -Oz -o output.wasm input.wasm

# Optimize for speed.
wasm-opt -O -o output.wasm input.wasm

# Optimize aggressively for speed.
wasm-opt -O3 -o output.wasm input.wasm
</code></pre>
<a class="header" href="print.html#a这些构建配置让我们的生命游戏wasm二进制有多小" id="a这些构建配置让我们的生命游戏wasm二进制有多小"><h3>这些构建配置让我们的生命游戏<code>.wasm</code>二进制有多小?</h3></a>
<p>使用默认版本构建配置 (没有调试符号) ,我们的WebAssembly二进制文件为240,605字节:</p>
<pre><code>$ wc -c wasm_game_of_life_bg.wasm
240605 wasm_game_of_life_bg.wasm
</code></pre>
<p>启用 LTO 后,进行设置<code>opt-level = &quot;z&quot;</code>,并运行<code>wasm-opt -Oz</code>, 所结果的<code>.wasm</code>二进制缩小到只有37,424字节!</p>
<pre><code>$ wc -c wasm_game_of_life_bg.wasm
37424 wasm_game_of_life_bg.wasm
</code></pre>
<a class="header" href="print.html#a大小分析" id="a大小分析"><h2>大小分析</h2></a>
<p>如果调整构建配置以优化代码大小后,不会导致足够小<code>.wasm</code>二进制,是时候进行一些分析,以查看剩余代码大小的来源.</p>
<blockquote>
<p>⚡就像我们如何让时间分析指导我们的加速工作一样,我们希望让大小分析指导我们的代码大小缩小工作量. 不这样做,你可能会浪费自己的时间!</p>
</blockquote>
<a class="header" href="print.html#a该twiggy代码大小分析器" id="a该twiggy代码大小分析器"><h3>该<code>twiggy</code>代码大小分析器</h3></a>
<p><a href="https://github.com/rustwasm/twiggy"><code>twiggy</code>是一个代码大小分析器</a>支持 WebAssembly 作为输入. 它分析二进制的调用图来回答如下问题:</p>
<ul>
<li>
<p>为什么这个函数首先包含在二进制文件中?</p>
</li>
<li>
<p>这个函数<em>保留大小</em>多少? 即如果删除它, 以及删除后所有死代码的函数,将节省多少空间?</p>
</li>
</ul>
<style>
/* For whatever reason, the defautl mdbook fonts fonts break with the
   following box-drawing characters, hence the manual style. */
pre, code {
  font-family: "SFMono-Regular",Consolas,"Liberation Mono",Menlo,Courier,monospace;
}
</style>
<pre><code class="language-text">$ twiggy top -n 20 wasm_game_of_life_bg.wasm
 Shallow Bytes │ Shallow % │ Item
───────────────┼───────────┼────────────────────────────────────────────────────────────────────────────────────────
          9158 ┊    19.65% ┊ &quot;function names&quot; subsection
          3251 ┊     6.98% ┊ dlmalloc::dlmalloc::Dlmalloc::malloc::h632d10c184fef6e8
          2510 ┊     5.39% ┊ &lt;str as core::fmt::Debug&gt;::fmt::he0d87479d1c208ea
          1737 ┊     3.73% ┊ data[0]
          1574 ┊     3.38% ┊ data[3]
          1524 ┊     3.27% ┊ core::fmt::Formatter::pad::h6825605b326ea2c5
          1413 ┊     3.03% ┊ std::panicking::rust_panic_with_hook::h1d3660f2e339513d
          1200 ┊     2.57% ┊ core::fmt::Formatter::pad_integral::h06996c5859a57ced
          1131 ┊     2.43% ┊ core::str::slice_error_fail::h6da90c14857ae01b
          1051 ┊     2.26% ┊ core::fmt::write::h03ff8c7a2f3a9605
           931 ┊     2.00% ┊ data[4]
           864 ┊     1.85% ┊ dlmalloc::dlmalloc::Dlmalloc::free::h27b781e3b06bdb05
           841 ┊     1.80% ┊ &lt;char as core::fmt::Debug&gt;::fmt::h07742d9f4a8c56f2
           813 ┊     1.74% ┊ __rust_realloc
           708 ┊     1.52% ┊ core::slice::memchr::memchr::h6243a1b2885fdb85
           678 ┊     1.45% ┊ &lt;core::fmt::builders::PadAdapter&lt;'a&gt; as core::fmt::Write&gt;::write_str::h96b72fb7457d3062
           631 ┊     1.35% ┊ universe_tick
           631 ┊     1.35% ┊ dlmalloc::dlmalloc::Dlmalloc::dispose_chunk::hae6c5c8634e575b8
           514 ┊     1.10% ┊ std::panicking::default_hook::{{closure}}::hfae0c204085471d5
           503 ┊     1.08% ┊ &lt;&amp;'a T as core::fmt::Debug&gt;::fmt::hba207e4f7abaece6
</code></pre>
<a class="header" href="print.html#a手动检查-llvm-ir" id="a手动检查-llvm-ir"><h3>手动检查 LLVM-IR</h3></a>
<p>LLVM-IR 是 LLVM 生成 WebAssembly之前编译器工具链中的最终中间表示. 因此,它与最终发出的 WebAssembly 非常相似. 更多LLVM-IR 通常意味着更多<code>.wasm</code>大小,如果一个函数占 LLVM-IR的25%,那么它通常会占25%<code>.wasm</code>. 虽然这些数字一般只保留. LLVM-IR 具有关键信息,而这些信息并不存在<code>.wasm</code>中 (因为 WebAssembly 缺少像 DWAR F这样的调试格式) : 哪些子程序被内联到 给定的函数中.</p>
<p>您可以使用此方法生成 LLVM-IR:</p>
<pre><code>cargo rustc --release -- --emit llvm-ir
</code></pre>
<p>然后,你可以使用<code>find</code>找到<code>.ll</code>包含 LLVM-IR 的文件:</p>
<pre><code>find target/release -type f -name '*.ll'
</code></pre>
<a class="header" href="print.html#a参考-2" id="a参考-2"><h4>参考</h4></a>
<ul>
<li><a href="https://llvm.org/docs/LangRef.html">LLVM语言参考手册</a></li>
</ul>
<a class="header" href="print.html#a更具侵入性的工具和技术" id="a更具侵入性的工具和技术"><h2>更具侵入性的工具和技术</h2></a>
<p>调整构建配置,以缩小<code>.wasm</code>二进制文件非常适合. 但是,当您需要加倍努力时,您准备使用更具侵入性的技术,例如重写源代码以避免膨胀. 接下来是一系列可以应用于获取较小代码的自适应技巧.</p>
<a class="header" href="print.html#a避免使用字符串格式" id="a避免使用字符串格式"><h3>避免使用字符串格式</h3></a>
<p><code>format!</code>,<code>to_string</code>等等...可以带来很多代码臃肿. 如果可能,仅在调试模式下进行字符串格式化,在发布模式下使用静态字符串.</p>
<a class="header" href="print.html#a避免恐慌" id="a避免恐慌"><h3>避免恐慌</h3></a>
<p>这说起来容易做起来难,但工具就像<code>twiggy</code>并手动检查LLVM-IR可以帮助您找出哪些功能令人恐慌.</p>
<p>恐慌并不总是表现为<code>panic!()</code>宏调用. 它们隐含地来自许多结构,例如:</p>
<ul>
<li>
<p>对超出范围索引的切片进行索引: <code>my_slice[i]</code></p>
</li>
<li>
<p>如果除数为零,则 分得数 会惊慌失措: <code>dividend / divisor</code></p>
</li>
<li>
<p>打开一个<code>Option</code>或者<code>Result</code>: <code>opt.unwrap()</code>或者<code>res.unwrap()</code></p>
</li>
</ul>
<p>前两个可以体现为第三个. 索引可以用<code>my_slice.get(i)</code>操作. 分得数 可以<code>checked_div</code>调用. 现在我们只有一个案例可以应对.</p>
<p>打开一个<code>Option</code>或者<code>Result</code>没有恐慌有两种风格: 安全和不安全.</p>
<p>安全的方法是<code>abort</code>代替恐慌,当得出一个<code>None</code>或一个<code>Error</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[inline]
pub fn unwrap_abort&lt;T&gt;(o: Option&lt;T&gt;) -&gt; T {
    use std::process;
    match o {
        Some(t) =&gt; t,
        None =&gt; process::abort(),
    }
}
#}</code></pre></pre>
<p>最终,无论如何在<code>wasm32-unknown-unknown</code>恐慌都会转化为 aborts ,所以这给你相同的行为,但没有代码膨胀.</p>
<p>或者,<a href="https://crates.io/crates/unreachable"><code>unreachable</code>箱</a>提供不安全的<a href="https://docs.rs/unreachable/1.0.0/unreachable/trait.UncheckedOptionExt.html#tymethod.unchecked_unwrap"><code>unchecked_unwrap</code>扩展方法</a>对于<code>Option</code>和<code>Result</code>, 它告诉Rust编译器<em>承担</em>那个<code>Option</code>是<code>Some</code>或者<code>Result</code>是<code>Ok</code>. 它是未定义如果该假设不成立,会发生什么. 你真的只能当你110%确定时,使用这种不安全的方法,而且编译器只是不够聪明看到它. 即使你沿着这条路走下去,你也应该有一个仍然进行检查的调试构建配置,并且只在发布版本中使用未经检查的操作.</p>
<a class="header" href="print.html#a避免分配或切换到wee_alloc" id="a避免分配或切换到wee_alloc"><h3>避免分配或切换到<code>wee_alloc</code></h3></a>
<p>Rust对WebAssembly的默认分配器,是<code>dlmalloc</code>的一部分. 它的重量大约在10千字节左右. 如果你可以完全避免动态分配,那么你应该能够减少这十个千字节.</p>
<p>完全避免动态分配可能非常困难. 但是从热代码路径中删除分配通常要容易得多 (并且通常也有助于使这些热代码路径更快) . 在这些情况下,<a href="https://github.com/rustwasm/wee_alloc">用,替换默认的全局分配器<code>wee_alloc</code></a>应该节省你最多 (但不是全部) 的十千字节. <code>wee_alloc</code>是一个为您需要<em>一些</em>类型情况时设计,但不需要特别快的分配器,并将愉快地交换分配速度较小的代码大小的分配器.</p>
<a class="header" href="print.html#a使用特征对象而不是通用类型参数" id="a使用特征对象而不是通用类型参数"><h3>使用特征对象而不是通用类型参数</h3></a>
<p>当您创建使用类型参数的泛型函数时,如下所示:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn whatever&lt;T: MyTrait&gt;(t: T) { ... }
#}</code></pre></pre>
<p>然后<code>rustc</code>和 LLVM 将为每个创建一个新的函数副本 - <code>T</code>类型函数. 这为基于特定的<code>T</code>每个副本都在使用的编译器的优化提供了许多机会,但这些副本在代码大小方面快速增加.</p>
<p>如果您使用特征对象而不是类型参数,如下所示:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn whatever(t: Box&lt;MyTrait&gt;) { ... }
// or
fn whatever(t: &amp;MyTrait) { ... }
// etc...
#}</code></pre></pre>
<p>然后使用通过虚拟调用的动态调度,并且仅在该函数中发出单个版本的函数<code>.wasm</code>. 缺点是失去了编译器优化机会,以及间接动态调度函数调用的额外成本.</p>
<a class="header" href="print.html#a使用wasm-snip工具" id="a使用wasm-snip工具"><h3>使用<code>wasm-snip</code>工具</h3></a>
<p><a href="https://github.com/fitzgen/wasm-snip"><code>wasm-snip</code>用一个替换WebAssembly函数的主体的<code>unreachable</code>指令. </a>这是一个相当沉重,钝的锤子,如果你足够眯眼,那些看起来像指甲的函数.</p>
<p>也许您知道某些函数永远不会在运行时调用,但编译器无法在编译时证明这一点? 剪断它! 然后,跑<code>wasm-opt</code>带着<code>--dce</code>,以及<code>snipping 函数</code>传递调用的所有函数 (也可能永远不会在运行时调用) 也将被删除.</p>
<p>这个工具对于消除恐慌特别有用,因为恐慌最终会转化为陷阱.</p>
<a class="header" href="print.html#a练习-6" id="a练习-6"><h2>练习</h2></a>
<ul>
<li>
<p>使用<code>wasm-snip</code>从我们的生命游戏中删除恐慌基础函数,<code>.wasm</code>二进制文件节省了多少字节?</p>
</li>
<li>
<p>将我们的生命游戏箱改为使用<code>wee_alloc</code>作为分配者. 剃掉了<code>.wasm</code>二进制多少尺寸?</p>
</li>
<li>
<p>我们只实例化一个单一的<code>Universe</code>,因此我们可以导出<code>static mut</code>全局实例的操作,而不是提供构造函数. 如果这个全局实例也使用前面章节中讨论的双缓冲技术,我们也可以使这些缓冲区成为全局<code>static mut</code>. 这将从我们的生命游戏实现中删除所有动态分配,我们可以将其作为一个不包含分配器的<code>#![no_std]</code>箱子. 从中移除了多少尺寸<code>.wasm</code>通过完全删除分配器依赖?</p>
</li>
</ul>
<a class="header" href="print.html#a生产和部署" id="a生产和部署"><h1>生产和部署</h1></a>
<p>当我们对项目感到满意时,下一步是将其部署到生产服务器,而不是我们的开发服务器.</p>
<p>第一步是运行:</p>
<pre><code>npm run bundle
</code></pre>
<p>这将创建我们的Rust代码的发布版本,会使用webpack将它与我们的JavaScript和HTML捆绑在一起,并一起输出到<code>dist</code>目录.</p>
<p>要从服务器使用我们的应用程序,必须正确配置<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types">MIME类型</a>-<code>application/wasm</code>,以正确的方式提供wasm文件.</p>
<blockquote>
<p><strong>注意</strong>: 服务器配置因操作系统而异,建议您查找特定操作系统和Web服务器的教程. 这些示例假设使用 Debian/Ubuntu 或 CentOS/Red Hat/Fedora等环境.</p>
</blockquote>
<p>例如,使用nginx,<a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#types">添加<code>application/wasm wasm;</code>到<code>/etc/nginx/mime.types</code></a>. 然后重新加载<code>sudo nginx -s reload</code>,nginx配置更改.</p>
<p>对于Apache<a href="https://httpd.apache.org/docs/2.4/mod/mod_mime.html#addtype">添加<code>AddType application/wasm .wasm</code>到你的apache配置的根目录</a>,可能位于<code>/etc/apache2/apache2.conf</code>要么<code>/etc/httpd.d/conf/httpd.conf</code>. Apache重新加载<code>sudo apachectl -k graceful</code>.</p>
<p>最后,我们可以上传<code>dist</code>生成服务器的目录,例如通过使用SCP或SFTP客户端. 将文件复制到Web根目录 (通常是<code>/var/www/html</code>要么<code>/var/www</code>) , 现在任何人都看到最终产品了.</p>
<a class="header" href="print.html#a您应该知道的箱子" id="a您应该知道的箱子"><h1>您应该知道的箱子</h1></a>
<p>这是一个精选的箱子列表,关于Rust和WebAssembly开发.</p>
<p><a href="https://crates.io/categories/wasm">您还可以浏览WebAssembly类别中,发布到crates.io的所有包. </a></p>
<a class="header" href="print.html#a与javascript和dom交互" id="a与javascript和dom交互"><h2>与JavaScript和DOM交互</h2></a>
<a class="header" href="print.html#wasm-bindgena-hrefhttpscratesiocrateswasm-bindgencratesioaa-hrefhttpsgithubcomrustwasmwasm-bindgengithuba" id="wasm-bindgena-hrefhttpscratesiocrateswasm-bindgencratesioaa-hrefhttpsgithubcomrustwasmwasm-bindgengithuba"><h3><code>wasm-bindgen</code>|<a href="https://crates.io/crates/wasm-bindgen">crates.io</a>|<a href="https://github.com/rustwasm/wasm-bindgen">github</a></h3></a>
<p><code>wasm-bindgen</code>促进Rust和JavaScript之间的高级交互. 它允许人们将JavaScript内容导入Rust和Rust内容导出到JavaScript.</p>
<a class="header" href="print.html#js-sysa-hrefhttpscratesiocratesjs-syscratesioaa-hrefhttpsgithubcomrustwasmwasm-bindgentreemastercratesjs-sysgithuba" id="js-sysa-hrefhttpscratesiocratesjs-syscratesioaa-hrefhttpsgithubcomrustwasmwasm-bindgentreemastercratesjs-sysgithuba"><h3><code>js-sys</code>|<a href="https://crates.io/crates/js-sys">crates.io</a>|<a href="https://github.com/rustwasm/wasm-bindgen/tree/master/crates/js-sys">github</a></h3></a>
<p>原生<code>wasm-bindgen</code>导入所有JavaScript全局类型和方法,例如<code>Object</code>,<code>Function</code>,<code>eval</code>等. 这些API可以在所有标准 ECMAScript环境 中移植,而不仅仅是Web,例如Node.js.</p>
<a class="header" href="print.html#a错误报告" id="a错误报告"><h2>错误报告</h2></a>
<a class="header" href="print.html#console_error_panic_hooka-hrefhttpscratesiocratesconsole_error_panic_hookcratesioaa-hrefhttpsgithubcomrustwasmconsole_error_panic_hookgithuba" id="console_error_panic_hooka-hrefhttpscratesiocratesconsole_error_panic_hookcratesioaa-hrefhttpsgithubcomrustwasmconsole_error_panic_hookgithuba"><h3><code>console_error_panic_hook</code>|<a href="https://crates.io/crates/console_error_panic_hook">crates.io</a>|<a href="https://github.com/rustwasm/console_error_panic_hook">github</a></h3></a>
<p>这个箱子让你调试<code>wasm32-unknown-unknown</code>的panics,通过提供一个恐慌钩子, 来将恐慌消息转发到<code>console.error</code>.</p>
<a class="header" href="print.html#a动态分配" id="a动态分配"><h2>动态分配</h2></a>
<a class="header" href="print.html#wee_alloca-hrefhttpscratesiocrateswee_alloccratesioaa-hrefhttpsgithubcomrustwasmwee_allocgithuba" id="wee_alloca-hrefhttpscratesiocrateswee_alloccratesioaa-hrefhttpsgithubcomrustwasmwee_allocgithuba"><h3><code>wee_alloc</code>|<a href="https://crates.io/crates/wee_alloc">crates.io</a>|<a href="https://github.com/rustwasm/wee_alloc">github</a></h3></a>
<p>该 <strong>W</strong>asm-<strong>E</strong>nabled, <strong>E</strong>lfin分配器. 一个小的 (~1K未压缩<code>.wasm</code>)分配器实现,特点是代码大小比分配性能更受关注,.</p>
<a class="header" href="print.html#a解析和生成wasm二进制" id="a解析和生成wasm二进制"><h2>解析和生成<code>.wasm</code>二进制</h2></a>
<a class="header" href="print.html#parity-wasma-hrefhttpscratesiocratesparity-wasmcratesioaa-hrefhttpsgithubcomparitytechparity-wasmgithuba" id="parity-wasma-hrefhttpscratesiocratesparity-wasmcratesioaa-hrefhttpsgithubcomparitytechparity-wasmgithuba"><h3><code>parity-wasm</code>|<a href="https://crates.io/crates/parity-wasm">crates.io</a>|<a href="https://github.com/paritytech/parity-wasm">github</a></h3></a>
<p>用于序列化,反序列化和构建的低级WebAssembly格式库 - <code>.wasm</code>二进制文件. 对已知的自定义部分具有良好支持,例如&quot;names&quot;部分和&quot;reloc.WHATEVER&quot;部分.</p>
<a class="header" href="print.html#wasmparsera-hrefhttpscratesiocrateswasmparsercratesioaa-hrefhttpsgithubcomyurydelendikwasmparserrsgithuba" id="wasmparsera-hrefhttpscratesiocrateswasmparsercratesioaa-hrefhttpsgithubcomyurydelendikwasmparserrsgithuba"><h3><code>wasmparser</code>|<a href="https://crates.io/crates/wasmparser">crates.io</a>|<a href="https://github.com/yurydelendik/wasmparser.rs">github</a></h3></a>
<p>一个简单的事件驱动库,用于解析WebAssembly二进制文件. 例如,提供每个解析事物的字节偏移量,这在解释reloc时是必需的.</p>
<a class="header" href="print.html#a解释和编译webassembly" id="a解释和编译webassembly"><h2>解释和编译WebAssembly</h2></a>
<a class="header" href="print.html#wasmia-hrefhttpscratesiocrateswasmicratesioaa-hrefhttpsgithubcomparitytechwasmigithuba" id="wasmia-hrefhttpscratesiocrateswasmicratesioaa-hrefhttpsgithubcomparitytechwasmigithuba"><h3><code>wasmi</code>|<a href="https://crates.io/crates/wasmi">crates.io</a>|<a href="https://github.com/paritytech/wasmi">github</a></h3></a>
<p>来自Parity的可嵌入WebAssembly解释器.</p>
<a class="header" href="print.html#cranelift-wasma-hrefhttpscratesiocratescranelift-wasmcratesioaa-hrefhttpsgithubcomcranestationcraneliftgithuba" id="cranelift-wasma-hrefhttpscratesiocratescranelift-wasmcratesioaa-hrefhttpsgithubcomcranestationcraneliftgithuba"><h3><code>cranelift-wasm</code>|<a href="https://crates.io/crates/cranelift-wasm">crates.io</a>|<a href="https://github.com/CraneStation/cranelift">github</a></h3></a>
<p>将WebAssembly编译为本机主机的机器代码. Cranelift (néCretonne) 代码生成器项目的一部分.</p>
<a class="header" href="print.html#a你应该知道的工具" id="a你应该知道的工具"><h1>你应该知道的工具</h1></a>
<p>这是在执行Rust和WebAssembly开发时,应该了解的精选工具列表.</p>
<a class="header" href="print.html#a开发构建和工作流程编排" id="a开发构建和工作流程编排"><h2>开发,构建和工作流程编排</h2></a>
<a class="header" href="print.html#wasm-packa-hrefhttpsgithubcomrustwasmwasm-packgithuba" id="wasm-packa-hrefhttpsgithubcomrustwasmwasm-packgithuba"><h3><code>wasm-pack</code>|<a href="https://github.com/rustwasm/wasm-pack">github</a></h3></a>
<p><code>wasm-pack</code>欲成为构建和使用Rust生成的WebAssembly的一站式商店,这样你可以通过Web或Node.js与JavaScript进行相互操作. <code>wasm-pack</code>帮助您构建和发布Rust生成的WebAssembly到npm注册表,以便与您在工作流中已经使用的其他JavaScript包一起使用.</p>
<a class="header" href="print.html#a优化和操作wasm二进制" id="a优化和操作wasm二进制"><h2>优化和操作<code>.wasm</code>二进制</h2></a>
<a class="header" href="print.html#wasm-opta-hrefhttpsgithubcomwebassemblybinaryengithuba" id="wasm-opta-hrefhttpsgithubcomwebassemblybinaryengithuba"><h3><code>wasm-opt</code>|<a href="https://github.com/WebAssembly/binaryen">github</a></h3></a>
<p>该<code>wasm-opt</code>工具将WebAssembly作为输入读取,在其上运行 转换,优化 和/或 检测,然后将转换后的WebAssembly作为输出发出. <code>rustc</code>会让它,与<code>.wasm</code>LLVM 合作生成二进制文件,通常这使得创造的<code>.wasm</code>二进制文件既小又执行得更快. 这个工具是<code>binaryen</code>项目的其中一部分.</p>
<a class="header" href="print.html#wasm2asma-hrefhttpsgithubcomwebassemblybinaryengithuba" id="wasm2asma-hrefhttpsgithubcomwebassemblybinaryengithuba"><h3><code>wasm2asm</code>|<a href="https://github.com/WebAssembly/binaryen">github</a></h3></a>
<p>该<code>wasm2asm</code>工具将WebAssembly编译为&quot;大多数 asm.js&quot;. 这非常适合支持没有WebAssembly实现的浏览器,例如Internet Explorer 11.此工具是<code>binaryen</code>项目的其中一部分.</p>
<blockquote>
<p>注意: 计划将此工具重命名为<code>wasm2js</code>但是,在撰写本文时,重命名仍未发生.</p>
</blockquote>
<a class="header" href="print.html#wasm-gca-hrefhttpsgithubcomalexcrichtonwasm-gcgithuba" id="wasm-gca-hrefhttpsgithubcomalexcrichtonwasm-gcgithuba"><h3><code>wasm-gc</code>|<a href="https://github.com/alexcrichton/wasm-gc">github</a></h3></a>
<p>垃圾收集WebAssembly模块并删除所有不需要的导出,导入,函数等的小工具. 这实际上是一个WebAssembly的链接器标志<code>--gc-sections</code>.</p>
<p>您通常不需要自己使用此工具,原因有两个:</p>
<ol>
<li><code>rustc</code>现在有一个<code>lld</code>足够新的版本,它支持<code>--gc-sections</code>WebAssembly的标志. LTO构建会自动启用此功能.</li>
<li>该<code>wasm-bindgen</code>CLI工具为你自动运行<code>wasm-gc</code>.</li>
</ol>
<a class="header" href="print.html#wasm-snipa-hrefhttpsgithubcomrustwasmwasm-snipgithuba" id="wasm-snipa-hrefhttpsgithubcomrustwasmwasm-snipgithuba"><h3><code>wasm-snip</code>|<a href="https://github.com/rustwasm/wasm-snip">github</a></h3></a>
<p><code>wasm-snip</code>替换WebAssembly函数的主体,通过用一个<code>unreachable</code>指令.</p>
<p>也许您知道某些函数永远不会在运行时调用,但编译器无法在编译时证明这一点? 剪断它!然后再次运行<code>wasm-gc</code>,它传递调用的所有函数 (也可能永远不会在运行时调用) 也将被删除.</p>
<p>这对于在非调试的生产版本中,强制删除Rust的恐慌基础结构非常有用.</p>
<a class="header" href="print.html#a检查wasm二进制" id="a检查wasm二进制"><h2>检查<code>.wasm</code>二进制</h2></a>
<a class="header" href="print.html#twiggya-hrefhttpsgithubcomrustwasmtwiggygithuba" id="twiggya-hrefhttpsgithubcomrustwasmtwiggygithuba"><h3><code>twiggy</code>|<a href="https://github.com/rustwasm/twiggy">github</a></h3></a>
<p><code>twiggy</code>是一个对<code>.wasm</code>二进制文件代码大小分析器. 它分析二进制的调用图来回答如下问题:</p>
<ul>
<li>为什么这个函数首先包含在二进制文件中? 即哪些导出的函数是可传递的呢?</li>
<li>这个函数的保留大小是多少? 即如果删除它以及删除后成为死代码的所有函数,将节省多少空间.</li>
</ul>
<p>使用<code>twiggy</code>让你的二进制文件变得苗条!</p>
<a class="header" href="print.html#wasm-objdumpa-hrefhttpsgithubcomwebassemblywabtgithuba" id="wasm-objdumpa-hrefhttpsgithubcomwebassemblywabtgithuba"><h3><code>wasm-objdump</code>|<a href="https://github.com/WebAssembly/wabt">github</a></h3></a>
<p>打印关于<code>.wasm</code>二进制及其每个部分的基本详细信息. 还支持反汇编成 WAT文本格式. 就像是<code>objdump</code>,不同的是为WebAssembly服务的. 这是WABT项目的一部分.</p>
<a class="header" href="print.html#wasm-nma-hrefhttpsgithubcomfitzgenwasm-nmgithuba" id="wasm-nma-hrefhttpsgithubcomfitzgenwasm-nmgithuba"><h3><code>wasm-nm</code>|<a href="https://github.com/fitzgen/wasm-nm">github</a></h3></a>
<p>列出<code>.wasm</code>二进制文件中定义的导入,导出和私有函数符号. 就像是<code>nm</code>,不同的是为WebAssembly服务的.</p>
<a class="header" href="print.html#javascript的互操作" id="javascript的互操作"><h1>JavaScript的互操作</h1></a>
<a class="header" href="print.html#a导入和导出js函数" id="a导入和导出js函数"><h3>导入和导出JS函数</h3></a>
<a class="header" href="print.html#a从rust方面来看" id="a从rust方面来看"><h4>从Rust方面来看</h4></a>
<p>在 JS环境 中使用 wasm 时,从 Rust 导入和导出函数很简单: 它的工作方式与C 完全相同</p>
<p>WebAssembly 模块定义了导入的一个系列,每个导入带有一个 <em>模块名</em> 和 一个<em>导入名称</em>. 但我们可以使用一个<code>extern { ... }</code>区块和 <a href="https://github.com/rust-lang/rust/issues/52090"><code>#[link(wasm_import_module)]</code></a>来声明模块名, 目前
它默认为&quot;env&quot;</p>
<p>导出只需要一个名称. 除了其他<code>extern</code>函数之外，WebAssembly实例的线性内存默认导出为&quot;memory&quot;</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// 从 `mod`模块导入一个函数 `foo`
#[link(wasm_import_module = &quot;mod&quot;)]
extern { fn foo(); }

// 导出 a Rust 函数 `bar`
#[no_mangle]
pub extern fn bar() { /* ... */ }
#}</code></pre></pre>
<p>由于 wasm 的有限值类型,这些函数必须仅在 原始数字类型上运行.</p>
<a class="header" href="print.html#a从js方面来看" id="a从js方面来看"><h4>从JS方面来看</h4></a>
<p>在JS中,wasm二进制文件变成了ES6模块.</p>
<p>其中,线性内存的<em>实例化</em>和一组JS函数,一定是预期导入吻合的. 有关实例化的详细信息,请访问<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiate">MDN</a>.</p>
<p>生成的ES6模块将包含从 Rust 导出的所有函数,现在可用作JS函数.</p>
<p><a href="https://www.hellorust.com/demos/add/index.html">这里</a>是整个设置的一个非常简单的例子.</p>
<a class="header" href="print.html#a超越数字" id="a超越数字"><h3>超越数字</h3></a>
<p>在JS中使用<code>wasm</code>时,<code>wasm</code>模块的内存与JS内存之间存在明显的分歧:</p>
<ul>
<li>
<p>每个<code>wasm</code>模块都有一个线性内存 (在本文档的顶部描述) ,它在实例化期间初始化. <strong>JS代码可以自由地读写这个内存</strong>.</p>
</li>
<li>
<p>相比之下,<code>wasm</code>代码没有<em>直接</em>访问JS对象.</p>
</li>
</ul>
<p>因此,复杂的互操作以两种主要方式发生:</p>
<ul>
<li>
<p>将二进制数据复制或输出到<code>wasm</code>内存. 例如,这是一种<code>String</code>提供所有权的到 Rust 的方式.</p>
</li>
<li>
<p>设置JS对象的显式&quot;堆&quot;,然后给出&quot;地址&quot;. 这允许<code>wasm</code>代码间接引用JS对象 (使用整数) ,并通过 调用导入的JS函数 对 这些对象 进行操作.</p>
</li>
</ul>
<p>幸运的是,这个互操作故事非常适合通过通用的&quot;bindgen&quot;式框架进行处理: <a href="https://github.com/alexcrichton/wasm-bindgen">wasm-bindgen</a>. 该框架可以自动编写 惯用Rust函数签名 映射 惯用JS函数 的</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        <script type="text/javascript">
            document.addEventListener('DOMContentLoaded', function() {
                window.print();
            })
        </script>
        

        

        
        <script src="searchindex.js" type="text/javascript" charset="utf-8"></script>
        
        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

    </body>
</html>
