<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust and WebAssembly</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="_FontAwesome/css/font-awesome.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="introduction.zh.html"><strong aria-hidden="true">1.</strong> 介绍</a></li><li><a href="background-and-concepts.zh.html"><strong aria-hidden="true">2.</strong> 背景和概念</a></li><li><a href="setup.zh.html"><strong aria-hidden="true">3.</strong> 安装准备</a></li><li><a href="hello-world.zh.html"><strong aria-hidden="true">4.</strong> 你好,世界</a></li><li><a href="tools.zh.html"><strong aria-hidden="true">5.</strong> 工具</a></li><li><a href="workflows.zh.html"><strong aria-hidden="true">6.</strong> 工作流程</a></li><li><a href="js-ffi.zh.html"><strong aria-hidden="true">7.</strong> JavaScript互操作</a></li><li><a href="tutorials.zh.html"><strong aria-hidden="true">8.</strong> 教程</a></li><li><ol class="section"><li><a href="game-of-life/introduction.zh.html"><strong aria-hidden="true">8.1.</strong> 康威的生命游戏</a></li><li><ol class="section"><li><a href="game-of-life/setup.zh.html"><strong aria-hidden="true">8.1.1.</strong> 安装</a></li><li><a href="game-of-life/rules.zh.html"><strong aria-hidden="true">8.1.2.</strong> 规则</a></li><li><a href="game-of-life/implementing.zh.html"><strong aria-hidden="true">8.1.3.</strong> 实现</a></li><li><a href="game-of-life/debugging.zh.html"><strong aria-hidden="true">8.1.4.</strong> 调试</a></li><li><a href="game-of-life/interactivity.zh.html"><strong aria-hidden="true">8.1.5.</strong> 增加交互性</a></li><li><a href="game-of-life/time-profiling.zh.html"><strong aria-hidden="true">8.1.6.</strong> 时间分析</a></li><li><a href="game-of-life/code-size.zh.html"><strong aria-hidden="true">8.1.7.</strong> 收缩.wasm尺寸</a></li><li><a href="game-of-life/publishing.zh.html"><strong aria-hidden="true">8.1.8.</strong> 发布</a></li></ol></li><li><a href="wasm-pack/introduction.zh.html"><strong aria-hidden="true">8.2.</strong> wasm-pack</a></li><li><ol class="section"><li><a href="wasm-pack/setup.zh.html"><strong aria-hidden="true">8.2.1.</strong> 安装</a></li><li><a href="wasm-pack/initialize.zh.html"><strong aria-hidden="true">8.2.2.</strong> 项目初始化</a></li><li><a href="wasm-pack/rust-code.zh.html"><strong aria-hidden="true">8.2.3.</strong> 锈编码</a></li><li><a href="wasm-pack/package-code.zh.html"><strong aria-hidden="true">8.2.4.</strong> 包裹代码为npm</a></li><li><a href="wasm-pack/run-the-code.zh.html"><strong aria-hidden="true">8.2.5.</strong> 从npm运行代码</a></li><li><a href="wasm-pack/next-steps.zh.html"><strong aria-hidden="true">8.2.6.</strong> 下一步做什么</a></li></ol></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Rust and WebAssembly</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>这本小书描述了如何让 <a href="https://www.rust-lang.org">rust</a> 和 <a href="http://webassembly.org/">WebAssembly</a> 一起.</p>
<p><a href="https://github.com/rustwasm/book">这本书是开源的!找个拼写错误?我们忽略了什么吗?向我们发送拉动请求!</a></p>
<a class="header" href="print.html#a背景和概念" id="a背景和概念"><h1>背景和概念</h1></a>
<a class="header" href="print.html#web-assembly" id="web-assembly"><h2>Web Assembly</h2></a>
<p><code>WebAssembly</code> 是一个简单的机器模型和可执行格式<a href="https://%60WebAssembly%60.github.io/spec/">extensive
specification</a>广泛的定义.</p>
<p>虽然它目前在 JavaScript和Web社区 中受到关注, 但并没有限制它的运行环境. 因此,认为在不久的将来, <em>wasm</em>将成为在各种环境中, 使用的重要&quot;便携式可执行&quot;格式是有可能的 (我们将花一些时间仔细研究一下<em>wasm</em>便携性功能,待本书进一步说明).</p>
<p>来到<em>今天</em>,总得来说,<em>wasm</em>主要与JavaScript有关,它有很多种类 (包括浏览器和 <code>Node.js</code>) . 由于JS广泛且易于访问, 我们将主要关注使用这些平台来运行 Rust生成的<em>wasm</em>,但 其他语言的编译 可能会在不久的将来发布.</p>
<p>作为一种编程语言,<code>WebAssembly</code>由两种格式组成: 二进制格式和文本格式. 两者都代表了一种共同的结构, 尽管方式不同. 文本格式 (通常称为<code>wat</code>) 使用<a href="https://en.wikipedia.org/wiki/S-expression">S表达式-</a>,与 Clojure或Racket 等语言有一些相似之处. 二进制格式<code>wasm</code>是一种较低级别的格式,它本身就是由 解释器运 行的汇编代码.</p>
<p>作为参考,这里是一个<code>wat</code>格式的阶乘函数:</p>
<pre><code>(module
  (func $fac (param f64) (result f64)
    get_local 0
    f64.const 1
    f64.lt
    if (result f64)
      f64.const 1
    else
      get_local 0
      get_local 0
      f64.const 1
      f64.sub
      call $fac
      f64.mul
    end)
  (export &quot;fac&quot; (func $fac)))
</code></pre>
<p>如果你对<code>wasm</code>文件好奇,你可以使用<a href="https://cdn.rawgit.com/%60WebAssembly%60/wabt/aae5a4b7/demo/wat2wasm/">wat2wasm demo</a>看上面的代码.</p>
<p><code>WebAssembly</code>有一个非常简单的<a href="https://%60WebAssembly%60.github.io/spec/core/syntax/modules.html#syntax-mem">内存模型</a>. 目前,一个<code>wasm</code>模块可以访问单个&quot;线性内存&quot;,它本质上是一个固定数字类型的平面数组. 这个<a href="https://%60WebAssembly%60.github.io/spec/core/syntax/instructions.html#syntax-instr-memory">内存成长</a>是页面大小 (64K) 的倍数,并且不能缩小.</p>
<a class="header" href="print.html#a来我们开始吧" id="a来我们开始吧"><h1>来我们开始吧</h1></a>
<p>如果你想使用<code>Rust for wasm</code>,那么你需要一个能够做到这一点的环境! 如果您尚未安装,则需要安装<a href="https://www.rustup.rs/">rustup</a> (官方工具) ,以便安装和管理Rust编译器的不同版本. 按照站点上的说明将其安装到您的计算机上. 目前,在与 wasm合作时,你需要最新「nightly」的Rust:</p>
<pre><code class="language-bash">$ rustup default nightly
</code></pre>
<p>一旦安装完毕,你就需要得到<code>wasm32-unknown-unknown</code>工具链.</p>
<pre><code class="language-bash">$ rustup target add wasm32-unknown-unknown --toolchain nightly
</code></pre>
<p>接下来,如果你有兴趣制作小型的 wasm 二进制文件,你需要安装它<a href="https://github.com/alexcrichton/wasm-gc">wasm-gc</a>用于制作较小的二进制文件, 并在编译器工具链中解决bug的工具:</p>
<pre><code class="language-bash">$ cargo install wasm-gc
</code></pre>
<p>最后,如果你是<em>真</em>有兴趣制作你想要安装的小型 wasm 二进制文件, <code>wasm-opt</code>来自<a href="https://github.com/WebAssembly/binaryen">binaryen工具包</a>符合你.</p>
<a class="header" href="print.html#wasm32-unknown-unknown的hello-world" id="wasm32-unknown-unknown的hello-world"><h1><code>wasm32-unknown-unknown</code>的&quot;Hello World&quot;</h1></a>
<p>生成一个基本的&quot;hello world&quot;:</p>
<pre><code>$ cargo +nightly new --lib hello-world
</code></pre>
<p>接下来改变<code>Cargo.toml</code>具有:</p>
<pre><code class="language-toml">[lib]
crate-type = [&quot;cdylib&quot;]
</code></pre>
<p>并编辑<code>src/lib.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[no_mangle]
pub extern fn add_one(a: u32) -&gt; u32 {
    a + 1
}
#}</code></pre></pre>
<p>现在准备<code>wasm</code>二进制文件:</p>
<pre><code>$ cargo +nightly build --target wasm32-unknown-unknown --release

# make the binary smaller by removing all unneeded exports, imports, and functions 
# (working around bugs in rustc toolchain)
$ wasm-gc target/wasm32-unknown-unknown/release/hello_world.wasm -o hello_world.gc.wasm
</code></pre>
<p>我们可以用以下方法测试它:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;script&gt;
      WebAssembly.instantiateStreaming(fetch('hello_world.gc.wasm'))
        .then(wasmModule =&gt; {
            alert(`2 + 1 = ${wasmModule.instance.exports.add_one(2)}`);
        });
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>注意: 要运行<code>instantiateStreaming</code>和<code>compileStreaming</code>,你需要你的网络服务器来获取<code>.wasm</code>文件带有<code>application/wasm</code>MIME类型. 该<a href="https://github.com/thecoshman/http">https</a> crate 可用于提供文件<code>localhost</code>ip,并包括<code>application/wasm</code>MIME类型开箱即用.</p>
<p>或者,如果您在本地运行而没有任何Web服务器.</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;script&gt;
      fetch('hello_world.gc.wasm')
        .then(r =&gt; r.arrayBuffer())
        .then(r =&gt; WebAssembly.instantiate(r))
        .then(wasmModule =&gt; {
            alert(`2 + 1 = ${wasmModule.instance.exports.add_one(2)}`);
        });
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>如果安装了Python 3,您也可以使用 Python 的内置 Web服务器 来<code>localhost</code>提供此文件. Python的 Web服务器 无法提供服务<code>instantiateStreaming</code>和<code>compileStreaming</code>, 由于缺乏支持<code>application/wasm</code>MIME类型.</p>
<pre><code>$ python3 -m http.server
</code></pre>
<p>确保您的浏览器支持Wasm. 两种选择:</p>
<ul>
<li>
<p>运行这个<a href="https://stackoverflow.com/a/47880734">StackOverflow 代码段</a></p>
</li>
<li>
<p>搜索您的浏览器版本的 Wasm支持<a href="https://caniuse.com/#search=wasm">caniuse.com</a></p>
</li>
</ul>
<p>使用浏览器打开HTML文件,您应该看到:</p>
<p><img src="./images/wasm_hello_world_screenshot.png" alt="Wasm Hello World Screenshot" /></p>
<a class="header" href="print.html#a工具" id="a工具"><h1>工具</h1></a>
<p>现在我们已经学会了如何使用<code>Rust</code>生成我们的第一个<code>WebAssembly</code>&quot;Hello World&quot;,
现在是时候检查该语言中可用的工具了.
已经为 <code>WebAssembly</code> 编写了几个很棒的工具 (大多数都是用C ++编写的) .
<a href="https://github.com/%60WebAssembly%60/wabt">Wabt</a>,是一套工具,可以作为操作<code>WebAssembly</code>文件的起点.</p>
<p>但是,由于<code>Rust</code>也有用于<code>WebAssembly</code>的开发和工具,因此在其中编写了几个工具:</p>
<ul>
<li><a href="https://github.com/alexcrichton/wasm-gc">wasm-gc</a>-  gc wasm模块的小命令,删除所有不需要的导出,导入,函数等.</li>
<li><a href="https://github.com/fitzgen/wasm-nm">wasm-nm</a>- 列出wasm文件中的符号.</li>
<li><a href="https://github.com/fitzgen/wasm-snip">wasm-snip</a>- 替换无法访问的 wasm 函数体</li>
<li><a href="https://github.com/paritytech/parity-wasm">parity-wasm</a>-  <code>rust</code>中的 wasm 序列化</li>
<li><a href="https://github.com/yurydelendik/wasmparser.rs">wasmparser</a>- 一个带有可选验证的wasm二进制解码器,在<code>rust</code>中</li>
<li><a href="https://github.com/yurydelendik/wasmtext">wasmtext</a>- 在<code>rust</code>中以文本格式打印wasm模块</li>
<li><a href="https://github.com/rustwasm/wasm-pack">wasm-pack</a>- 打包你的 wasm 以便在npm上分发</li>
</ul>
<p>下面这些工具中包含一个旨在允许您在浏览器外运行 wasm 的集合:</p>
<ul>
<li><a href="https://github.com/joshuawarner32/rust-wasm">rustwasm</a>-  <code>rust</code>的一名解释器</li>
<li><a href="https://github.com/paritytech/wasmi">wasmi</a>- 另一位来自 parity 的<code>rust</code>的解释器</li>
<li><a href="https://github.com/sunfishcode/wasmstandalone">wasmstandalone</a>- 基于jit 的 wasm runner,使用 cretonne (相同的后端<a href="https://github.com/nebulet/nebulet">nebulet</a>使用). 在早期发展中.</li>
<li><a href="https://github.com/losfair/wasm-core">wasm-core</a>- 一个带有两个 wasm 执行引擎 ( 解释器 和 jit ) 的<code>rust</code>库. 使用<a href="https://github.com/cervus-v/cervus">cervus</a>和<a href="https://github.com/losfair/IceCore">iceCore</a>.</li>
</ul>
<p>还有很多<em>在<code>Rust</code>中构建或重写工具的空间</em>与生态系统更好地协同. 其中一些包括:</p>
<ul>
<li><a href="https://github.com/rustwasm/team/issues/20">一个wasm大小的剖析器</a></li>
<li>一个<a href="https://github.com/%60WebAssembly%60/wabt">Wabt</a>在<code>Rust</code>中重写</li>
<li><a href="https://github.com/ewasm">ewasm项目</a>工具</li>
</ul>
<p>这个页面是一个活文档,所以请随时向我们发送一个拉取请求,添加我们可能错过的新的令人难以置信的<code>WebAssembly</code>工具
或将来发布它们时!</p>
<a class="header" href="print.html#a常见的-rust--wasm-工作流程" id="a常见的-rust--wasm-工作流程"><h1>常见的 Rust + wasm 工作流程</h1></a>
<p>本文档目前旨在收集与 Rust + wasm 相关的许多工作流程. 现在它不一定是最有组织的,但可能很快就会到来!</p>
<a class="header" href="print.html#javascript的互操作" id="javascript的互操作"><h1>JavaScript的互操作</h1></a>
<a class="header" href="print.html#a导入和导出js函数" id="a导入和导出js函数"><h3>导入和导出JS函数</h3></a>
<a class="header" href="print.html#a从rust方面来看" id="a从rust方面来看"><h4>从Rust方面来看</h4></a>
<blockquote>
<p><strong>注意</strong>: 这很可能<a href="https://github.com/rustwasm/team/issues/29">在不久的将来改变</a></p>
</blockquote>
<p>在 JS环境 中使用 wasm 时,从 Rust 导入和导出函数很简单: 它的工作方式与C 完全相同. 特别是:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// 导入 import a JS function called `foo`
extern { fn foo(); }

// 导出 export a Rust function called `bar`
#[no_mangle]
pub extern fn bar() { /* ... */ }
#}</code></pre></pre>
<p>由于 wasm 的有限值类型,这些函数必须仅在 原始数字类型上运行.</p>
<a class="header" href="print.html#a从js方面来看" id="a从js方面来看"><h4>从JS方面来看</h4></a>
<p>在JS中,wasm二进制文件变成了ES6模块.</p>
<p>一定是具有线性内存和一组与预期导入匹配的JS函数<em>实例化</em>. 有关实例化的详细信息,请访问<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiate">MDN</a>.</p>
<p>生成的ES6模块将包含从 Rust 导出的所有函数,现在可用作JS函数.</p>
<p><a href="https://www.hellorust.com/demos/add/index.html">这里</a>是整个设置的一个非常简单的例子.</p>
<a class="header" href="print.html#a超越数字" id="a超越数字"><h3>超越数字</h3></a>
<p>在JS中使用<code>wasm</code>时,<code>wasm</code>模块的内存与JS内存之间存在明显的分歧:</p>
<ul>
<li>
<p>每个<code>wasm</code>模块都有一个线性内存 (在本文档的顶部描述) ,它在实例化期间初始化. <strong>JS代码可以自由地读写这个内存</strong>.</p>
</li>
<li>
<p>相比之下,<code>wasm</code>代码没有<em>直接</em>访问JS对象.</p>
</li>
</ul>
<p>因此,复杂的互操作以两种主要方式发生:</p>
<ul>
<li>
<p>将二进制数据复制或输出到<code>wasm</code>内存. 例如,这是一种<code>String</code>提供所有权的到 Rust 的方式.</p>
</li>
<li>
<p>设置JS对象的显式&quot;堆&quot;,然后给出&quot;地址&quot;. 这允许<code>wasm</code>代码间接引用JS对象 (使用整数) ,并通过 调用导入的JS函数 对 这些对象 进行操作.</p>
</li>
</ul>
<p>幸运的是,这个互操作故事非常适合通过通用的&quot;bindgen&quot;式框架进行处理: <a href="https://github.com/alexcrichton/wasm-bindgen">wasm-bindgen</a>. 该框架可以自动编写 惯用Rust函数签名 映射 惯用JS函数 的</p>
<a class="header" href="print.html#a教程" id="a教程"><h1>教程</h1></a>
<p>生态系统中有各种各样的工具,我们希望提供一种集中的方式来向您, 展示如何更深入地使用它们, 而不是基本的自述文件.</p>
<a class="header" href="print.html#a康威的生命游戏" id="a康威的生命游戏"><h1>康威的生命游戏</h1></a>
<p>这是一个在Rust和WebAssembly中增量实现的长篇教程<a href="https://zh.wikipedia.org/wiki/%E5%BA%B7%E5%A8%81%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F">康威的生命游戏</a>.</p>
<blockquote>
<p>谁是 康威-ConWay 我怎么知道 ❓</p>
</blockquote>
<a class="header" href="print.html#a本教程适合谁" id="a本教程适合谁"><h2>本教程适合谁?</h2></a>
<p>本教程适用于具有基 本Rust和JavaScript经验 的任何人,并希望学习如何一起使用 Rust,WebAssembly和JavaScript.</p>
<p>阅读和编写基本的 Rust,JavaScript和HTML 应该会很舒服. 你绝对不需要成为专家.</p>
<a class="header" href="print.html#a安装" id="a安装"><h1>安装</h1></a>
<a class="header" href="print.html#a必备工具" id="a必备工具"><h2>必备工具</h2></a>
<p>您需要安装以下工具才能学习本教程.</p>
<a class="header" href="print.html#rust工具链" id="rust工具链"><h3>Rust工具链</h3></a>
<p>本教程,您将需要标准的 Rust工具链,包括<code>rustup</code>,<code>rustc</code>,和<code>cargo</code></p>
<p><a href="https://www.rust-lang.org/en-US/install.html">按照以下说明安装Rust工具链. </a></p>
<a class="header" href="print.html#a该wasm32-unknown-unknown目标" id="a该wasm32-unknown-unknown目标"><h3>该<code>wasm32-unknown-unknown</code>目标</h3></a>
<p>一旦安装了 Rust工具链 ,您就可以将 Rust程序 编译为 WebAssembly,而不是机器的本机代码. 您可以通过添加<code>wasm32-unknown-unknown</code>来启用此功能,使用以下命令进行目标:</p>
<pre><code>rustup update
rustup install nightly
rustup target add wasm32-unknown-unknown --toolchain nightly
</code></pre>
<a class="header" href="print.html#npm" id="npm"><h3><code>npm</code></h3></a>
<p><code>npm</code>是 JavaScript的包管理器. 我们将使用它来安装和运行 JavaScript捆绑器 和 开发服务器. 在本教程结束时,我们将发布我们编译的<code>.wasm</code>到了<code>npm</code>注册表中.</p>
<p><a href="https://www.npmjs.com/get-npm">请按照以下说明进行安装<code>npm</code>. </a></p>
<a class="header" href="print.html#wasm-bindgen" id="wasm-bindgen"><h3><code>wasm-bindgen</code></h3></a>
<p><a href="https://github.com/rustwasm/wasm-bindgen"><code>wasm-bindgen</code></a>为 Rust和WebAssembly 生成与 JavaScript 的双向绑定.</p>
<p>安装<code>wasm-bindgen</code>使用此命令:</p>
<pre><code>cargo +nightly install wasm-bindgen-cli
</code></pre>
<a class="header" href="print.html#a克隆项目模板" id="a克隆项目模板"><h2>克隆项目模板</h2></a>
<p>项目模板包含一个&quot;hello world&quot;程序. 它预先配置了默认的默认设置,因此您可以快速构建,集成和打包Web代码.</p>
<p>克隆此教程代码存储库,输入其目录,然后 checkout <code>chapter-zero</code> branch:</p>
<pre><code class="language-text">git clone https://github.com/rustwasm/wasm_game_of_life.git
cd ./wasm_game_of_life
git checkout -b chapter-zero origin/chapter-zero
</code></pre>
<a class="header" href="print.html#a里面有什么" id="a里面有什么"><h2>里面有什么</h2></a>
<p>让我们来看看我们项目的内容:</p>
<pre><code class="language-text">.
├── bootstrap.js
├── Cargo.lock
├── Cargo.toml
├── index.html
├── index.js
├── package.json
├── package-lock.json
├── src
│   └── lib.rs
├── wasm_game_of_life_bg.wasm
├── wasm_game_of_life.js
└── webpack.config.js
</code></pre>
<p>其中大多数是配置文件,但我们应该突出显示一些文件.</p>
<a class="header" href="print.html#indexhtml" id="indexhtml"><h3><code>index.html</code></h3></a>
<p>这是网页的根HTML文件. 它除了加载<code>bootstrap.js</code>之外没有其他作用,这是一个非常薄的包装<code>index.js</code>.</p>
<pre><code class="language-html">&lt;html&gt;
    &lt;head&gt;
        &lt;meta content=&quot;text/html;charset=utf-8&quot; http-equiv=&quot;Content-Type&quot;/&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;script src='./bootstrap.js'&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<a class="header" href="print.html#indexjs" id="indexjs"><h3><code>index.js</code></h3></a>
<p>该<code>index.js</code>是我们网页的 JavaScript 的主要入口点. 它导入项目的WebAssembly模块,并调用模块<code>greet</code>功能.</p>
<pre><code class="language-js">import { greet } from &quot;./wasm_game_of_life&quot;;

greet(&quot;Rust and WebAssembly&quot;);
</code></pre>
<a class="header" href="print.html#srclibrs" id="srclibrs"><h3><code>src/lib.rs</code></h3></a>
<p>该<code>src/lib.rs</code>file是我们正在编译到 WebAssembly的Rust包 的根. 它用<code>wasm_bindgen</code>与 JavaScript交互. 它导入了<code>window.alert</code> - JavaScript函数,并导出<code>greet</code>rust函数,需要一个<code>name</code>参数就可以 <code>alert greeting</code> 消息.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![feature(proc_macro, wasm_custom_section, wasm_import_module)]

#fn main() {
extern crate wasm_bindgen;

use wasm_bindgen::prelude::*;

#[wasm_bindgen]
extern {
    fn alert(s: &amp;str);
}

#[wasm_bindgen]
pub fn greet(name: &amp;str) {
    alert(&amp;format!(&quot;Hello, {}!&quot;, name));
}
#}</code></pre></pre>
<a class="header" href="print.html#a建设和服务" id="a建设和服务"><h2>建设和服务</h2></a>
<p>首先,确保为此项目安装了JavaScript构建依赖项:</p>
<pre><code class="language-text">npm install
</code></pre>
<p>此命令只需运行一次,并将安装<code>webpack</code> - JavaScript bundler及其开发服务器. 注意:使用<code>webpack</code>对 Rust和WebAssembly 来说不是必需的,它只是我们为方便起见而选择的捆绑器和开发服务器.</p>
<p>构建 Rust crate{📦} 为 WebAssembly 并生成<code>wasm_bindgen</code>胶水,运行此命令:</p>
<pre><code class="language-text">npm run build-debug
</code></pre>
<p>第一个构建可能需要一些时间,因为需要编译依赖项. 但不要担心: 后续构建,当依赖关系不需要重新编译时,将会快得多.</p>
<p>命令会创建 Rust crates的&quot;debug&quot;版本: 未优化应用的构建,并包含符号以便在浏览器的开发人员工具中进行更好的调试. 您还可以创建一个&quot;发布-release&quot;版本,该版本具有使用此命令应用的优化过程:</p>
<pre><code>npm run build-release
</code></pre>
<p>这是我们想要用来创建, 用于分析和部署到生产的<code>.wasm</code>二进制文件的命令.</p>
<p>接下来,为开发服务器打开一个新终端. 在新终端中运行服务器让我们让它在后台运行,并且不会阻止我们在此期间运行其他命令. 在新终端中,运行以下命令:</p>
<pre><code>npm run serve
</code></pre>
<p>浏览Web浏览器<a href="http://localhost:8080/">http://localhost:8080/)</a>你应该收到一条 alert 信息:</p>
<p><a href="./images/game-of-life/setup.png"><img src="./images/game-of-life/setup.png" alt="Screenshot of the &quot;Hello, Rust and WebAssembly!&quot; Web page alert" /></a></p>
<p>任何时候你做出改变并希望它们反映出来<a href="http://localhost:8080/">http://localhost:8080/)</a>,只是重新运行<code>npm run build-debug</code>命令.</p>
<a class="header" href="print.html#a练习" id="a练习"><h2>练习</h2></a>
<ul>
<li>
<p>修改<code>index.js</code>用你的名字而不是&quot;Rust和WebAssembly&quot;来 问候-greet 你.</p>
</li>
<li>
<p>修改<code>greet</code>函数参数要两个<code>&amp;str</code>参数. 如果你没有传递第二个参数会发生什么<code>index.js</code>? <em>提示: 打开Web浏览器的开发人员工具.</em></p>
</li>
</ul>
<a class="header" href="print.html#a康威生命游戏规则" id="a康威生命游戏规则"><h1>康威生命游戏规则</h1></a>
<p><em>注意: 如果您已熟悉康威的生命游戏及其规则,请跳到下一部分!</em></p>
<p><a href="https://zh.wikipedia.org/wiki/%E5%BA%B7%E5%A8%81%E7%94%9F%E5%91%BD%E6%B8%B8%E6%88%8F">维基百科对 康威的生命游戏规则 进行了很好的描述: </a></p>
<blockquote>
<p>生命游戏的宇宙是方形单元的无限二维正交网格,每个方格单元处于两种可能状态之一,活着或死亡,或&quot;填充&quot;或&quot;未填充&quot;. 每个细胞与其八个邻居相互作用 - 这八个邻居是水平,垂直或对角相邻的细胞. 在每个步骤中,发生以下转换:</p>
<ol>
<li>当前细胞为存活状态时，当周围低于2个（不包含2个）存活细胞时， 该细胞变成死亡状态。（模拟生命数量稀少）</li>
<li>当前细胞为存活状态时，当周围有2个或3个存活细胞时， 该细胞保持原样。</li>
<li>当前细胞为存活状态时，当周围有3个以上的存活细胞时，该细胞变成死亡状态。（模拟生命数量过多）</li>
<li>当前细胞为死亡状态时，当周围有3个存活细胞时，该细胞变成存活状态。 （模拟繁殖）</li>
</ol>
</blockquote>
<blockquote>
<p>可以把最初的细胞结构定义为种子，当所有在种子中的细胞同时被以上规则处理后, 可以得到第一代细胞图。按规则继续处理当前的细胞图，可以得到下一代的细胞图，周而复始。</p>
</blockquote>
<p>考虑以下初始 Universe:</p>
<p><img src='./images/game-of-life/initial-universe.png' alt='Initial Universe' width="80" /></p>
<p>我们可以通过考虑每个单元来计算下一代. 左上角的单元格已经死了. 规则 (4) 是适用于死细胞的唯一转换规则. 但是,因为左上角的单元格没有正好三个活动邻居,所以转换规则不适用,并且它在下一代中仍然不存在. 对于 第一行 中的每个其他单元也是如此.</p>
<p>当我们考虑第二列,第三列中的活细胞时,事情变得有趣. 对于活细胞,前三个规则中的任何一个都可能适用. 在这个黑单元的情况下,它只有下面一个活的邻居,因此规则 (1) 适用: 这个单元将在下一代中死亡. 同样的命运也对应着最下面的活黑细胞.</p>
<p>中间活细胞有两个活的邻居: 顶部和底部活细胞. 这意味着规则 (2) 适用,并且它仍然存在于下一代.</p>
<p>最后有趣的案例是中间活细胞左侧和右侧的死细胞. 这三个活细胞都是这些细胞的邻居,这意味着规则 (4) 适用,并且这些细胞将在下一代中存活.</p>
<p>把它们放在一起,我们在下一个滴答之后得到这个宇宙:</p>
<p><img src='./images/game-of-life/next-universe.png' alt='Next Universe' width=80 /></p>
<p>从这些简单的,确定性的规则出现,奇怪和令人兴奋的行为出现了:</p>
<table><thead><tr><th> Gosper的滑翔机枪                                                                                        </th><th> 脉冲星                                                                                    </th><th> 太空飞船                                                                                                         </th></tr></thead><tbody>
<tr><td> <img src="https://upload.wikimedia.org/wikipedia/commons/e/e5/Gospers_glider_gun.gif" alt="Gosper's glider gun" /> </td><td> <img src="https://upload.wikimedia.org/wikipedia/commons/0/07/Game_of_life_pulsar.gif" alt="Pulsar" /> </td><td> <img src="https://upload.wikimedia.org/wikipedia/commons/3/37/Game_of_life_animated_LWSS.gif" alt="Lighweight space ship" /> </td></tr>
</tbody></table>
<p><center></p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/C2vgICfQawE?rel=0&amp;start=65" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>
</center>
<a class="header" href="print.html#a练习-1" id="a练习-1"><h2>练习</h2></a>
<ul>
<li>
<p>手动计算我们的示例 Universe的下一个滴答. 注意像什么?</p>
</li>
<li>
<p>你能找到一个稳定的初始宇宙吗? 也就是说,每一代人都是一样的宇宙.</p>
</li>
</ul>
<a class="header" href="print.html#a实施康威的生命游戏" id="a实施康威的生命游戏"><h1>实施康威的生命游戏</h1></a>
<a class="header" href="print.html#a设计" id="a设计"><h2>设计</h2></a>
<p>在我们深入之前,我们有一些设计选择需要考虑.</p>
<a class="header" href="print.html#a无限的宇宙" id="a无限的宇宙"><h3>无限的宇宙</h3></a>
<p>生命游戏是在无限的宇宙中进行的,但我们没有无限的记忆和计算能力. 解决这个相当恼人的限制通常有以下三种风格之一:</p>
<ol>
<li>
<p>跟踪宇宙的哪个子集发生了有趣的事情,并根据需要,扩展此区域. 在最坏的情况下,这种扩展是无限制的,实现将变得越来越慢,最终耗尽内存.</p>
</li>
<li>
<p>创建固定大小的 Universe，边缘上的单元格具有较少的邻居
比中间的细胞。 这种方法的缺点是无限
像滑翔机一样到达宇宙尽头的模式被扼杀了。</p>
</li>
<li>
<p>创建一个固定大小的周期性 Universe <code>移动</code>,其中边缘上的单元格具有环绕到 Universe 另一侧的邻居. 因为邻居环绕宇宙的边缘,滑翔机可以永远运行.</p>
</li>
</ol>
<p>我们将实施<code>第三种</code>选择.</p>
<a class="header" href="print.html#a连接-rust和javascript" id="a连接-rust和javascript"><h3>连接 Rust和JavaScript</h3></a>
<blockquote>
<p>⚡这是理解和从本教程中你获取的最重要的概念之一!</p>
</blockquote>
<p>JavaScript 的垃圾收集堆 - <code>Object</code>,<code>Array</code>和 DOM节点 被分配 - 不同于 WebAssembly 的线性内存空间,我们的 Rust值 存在于其中. WebAssembly 目前无法直接访问垃圾收集堆 (截至2018年4月,预计会随之改变<a href="https://github.com/WebAssembly/host-bindings/blob/master/proposals/host-bindings/Overview.md">&quot;主机绑定 host-bindings&quot;提案</a>) . 另一方面,JavaScript 可以读取和写入 WebAssembly 线性存储空间,但仅作为一个<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffer</code></a>标量值 (<code>u8</code>,<code>i32</code>,<code>f64</code>等等......) WebAssembly 函数也接受,并返回标量值. 这些是构成 WebAssembly和JavaScript通信 的所有构建块.</p>
<p><code>wasm_bindgen</code>定义了如何在这个边界上,使用复合结构的共同理解. 它涉及装箱 Rust 结构,将指针包装在 JavaScript类 中以实现可用性,或者 索引到Rust中的JavaScript对象表. <code>wasm_bindgen</code>非常方便,但它不需要考虑我们的数据表示,以及跨越这个边界传递什么值和结构. 相反,将其视为实现您选择的接口设计的工具.</p>
<p>在设计 WebAssembly和JavaScript 之间的接口时,我们希望针对以下属性进行优化:</p>
<ol>
<li>
<p>**最小化复制WebAssembly线性存储器的 进/出 .**不必要的副本会产生不必要的开销.</p>
</li>
<li>
<p>**最小化序列化和反序列化.**与副本类似,序列化和反序列化也会产生开销,并且通常也会进行复制. 如果我们可以将不透明控制传递给数据结构 - 而不是一侧序列化后,将其复制到 WebAssembly 线性存储器中的某个已知位置,并在另一侧进行反序列化 - 我们通常可以减少大量开销. <code>wasm_bindgen</code>帮助我们 定义和使用 JavaScript 的不透明控制<code>Object</code>或 盒装 Rust 结构.</p>
</li>
</ol>
<p>作为一般的经验法则,一个好的 JavaScript↔WebAssembly 接口设计通常是将大型,长寿命的数据结构实现为 生活在 WebAssembly线性内存 中的 Rust 类型,并作为不透明控制暴露给 JavaScript. JavaScript 调用导出的WebAssembly 函数,这些函数接受这些不透明的控制,转换数据,执行繁重的计算,查询数据,最终返回一个小的可复制结果. 通过仅返回计算的小结果,我们避免在JavaScript 垃圾收集堆和 WebAssembly 线性存储器 之间,来回复制和序列化所有内容.</p>
<a class="header" href="print.html#a在我们的生命游戏中连接-rust和javascript" id="a在我们的生命游戏中连接-rust和javascript"><h3>在我们的生命游戏中连接 Rust和JavaScript</h3></a>
<p>让我们首先列举一些要避免的危险. 我们不希望在每个<code>tick</code>上将整个 Universe 复制到 WebAssembly线性内存 中. 我们不希望为宇宙中的每个单元分配对象,也不想强加函数调用来读写每个单元.</p>
<p>这给我们留下了什么? 我们可以将 Universe 表示为位于 WebAssembly线性内存中的平面数组,并且每个单元格都有一个字节. <code>0</code>是一个死细胞,<code>1</code>是一个活细胞.</p>
<p>以下是 4 x 4 宇宙在内存中的样子:</p>
<p><img src="./images/game-of-life/universe.png" alt="Screenshot of a 4 by 4 universe" /></p>
<p>要在 Universe 中的给定行和列中查找单元格的数组索引,我们可以使用以下公式:</p>
<pre><code class="language-text">index(row, column, universe) = row * width(universe) + column
</code></pre>
<p>我们有几种方法可以将 Universe 的单元格暴露给 JavaScript. 首先,我们添加实施<a href="https://doc.rust-lang.org/1.25.0/std/fmt/trait.Display.html"><code>std::fmt::Display</code></a>到<code>Universe</code>,我们可以用来展示 一个 Rust<code>String</code> 呈现为文本字符的单元格. 然后将此 Rust String 从 WebAssembly线性内存 复制到 JavaScript的垃圾回收堆中 的JavaScript String 中,然后通过设置<code>HTML</code>显示<code>textContent</code>. 在本章的后面,我们将推演这个实现,以避免在堆之间复制 Universe 的单元格,再渲染<code>&lt;canvas&gt;</code>.</p>
<p><em>另一个可行的设计替代方案是 Rust 返回每个滴答后,更改状态的每个单元格的列表,而不是将整个 Universe 暴露给 JavaScript. 这样,JavaScript 在渲染时不需要遍历整个 Universe ,只需要相关的子集. 权衡的问题是这种 基于delta 的设计实施起来稍微困难一些.</em></p>
<a class="header" href="print.html#rust实现" id="rust实现"><h2>Rust实现</h2></a>
<p>在上一章中,我们克隆了一个初始项目模板. 我们现在将修改该项目模板.</p>
<p>让我们开始删除 <code>alert</code> import 和<code>greet</code> 函数 - <code>src/lib.rs</code>, 并用单元格的类型定义替换它们:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[repr(u8)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Cell {
    Dead = 0,
    Alive = 1,
}
#}</code></pre></pre>
<p>重要的是我们拥有<code>#[repr(u8)]</code>,以便每个单元格表示为单个字节. 同样重要的是<code>Dead</code>代表<code>0</code>,那个<code>Alive</code>是<code>1</code>,这样我们就可以轻松地计算一个细胞的活体邻居.</p>
<p>接下来,让我们定义宇宙. 宇宙具有宽度和高度,以及长度为单元格的向量<code>width * height</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
pub struct Universe {
    width: u32,
    height: u32,
    cells: Vec&lt;Cell&gt;,
}
#}</code></pre></pre>
<p>要访问给定行和列的单元格,我们将 行和列 转换为 单元格向量 的索引,如前所述:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Universe {
    fn get_index(&amp;self, row: u32, column: u32) -&gt; usize {
        (row * self.width + column) as usize
    }

    // ...
}
#}</code></pre></pre>
<p>为了计算单元格的下一个状态,我们需要计算 其邻居有多少 是活着的. 我们来写一个<code>live_neighbor_count</code>做到这一点的方法!</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Universe {
    // ...

    fn live_neighbor_count(&amp;self, row: u32, column: u32) -&gt; u8 {
        let mut count = 0;
        for delta_row in [self.height - 1, 0, 1].iter().cloned() {
            for delta_col in [self.width - 1, 0, 1].iter().cloned() {
                if delta_row == 0 &amp;&amp; delta_col == 0 {
                    continue;
                }

                let neighbor_row = (row + delta_row) % self.height;
                let neighbor_col = (column + delta_col) % self.width;
                let idx = self.get_index(neighbor_row, neighbor_col);
                count += self.cells[idx] as u8;
            }
        }
        count
    }
}
#}</code></pre></pre>
<p>该<code>live_neighbor_count</code>方法使用 增量和模数来 避免 宇宙的边缘情况. 当 delta 应用 <code>-1</code>,我们<em>添加</em>
<code>self.height - 1</code>让 模数 做它的事,而不是试图减去<code>1</code>. <code>row</code>和<code>column</code>可以为<code>0</code>,如果我们试图减去<code>1</code>, 从他们来看,会有一个 无符号整数 下溢.</p>
<p>现在我们拥有了从当前计算下一代所需的一切! 每个游戏的规则遵循 直接转换条件用<code>match</code>表达. 另外,因为我们希望 JavaScript 控制滴答时间,我们将把这个方法放在一个<code>#[wasm_bindgen]</code>注释下,以便它暴露给JavaScript.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// Public methods, exported to JavaScript.
#[wasm_bindgen]
impl Universe {
    pub fn tick(&amp;mut self) {
        let mut next = self.cells.clone();

        for row in 0..self.height {
            for col in 0..self.width {
                let idx = self.get_index(row, col);
                let cell = self.cells[idx];
                let live_neighbors = self.live_neighbor_count(row, col);

                let next_cell = match (cell, live_neighbors) {
                    // Rule 1: Any live cell with fewer than two live neighbours
                    // dies, as if caused by underpopulation.
                    (Cell::Alive, x) if x &lt; 2 =&gt; Cell::Dead,
                    // Rule 2: Any live cell with two or three live neighbours
                    // lives on to the next generation.
                    (Cell::Alive, 2) | (Cell::Alive, 3) =&gt; Cell::Alive,
                    // Rule 3: Any live cell with more than three live
                    // neighbours dies, as if by overpopulation.
                    (Cell::Alive, x) if x &gt; 3 =&gt; Cell::Dead,
                    // Rule 4: Any dead cell with exactly three live neighbours
                    // becomes a live cell, as if by reproduction.
                    (Cell::Dead, 3) =&gt; Cell::Alive,
                    // All other cells remain in the same state.
                    (otherwise, _) =&gt; otherwise,
                };

                next[idx] = next_cell;
            }
        }

        self.cells = next;
    }

    // ...
}
#}</code></pre></pre>
<p>到目前为止,宇宙的状态被表示为 细胞 的载体. 为了使这个可读,让我们实现一个基本的文本渲染器. 我们的想法是逐行将 Universe 写成文本,对于每个活着的单元格,打印 unicode 字符<code>◼️</code> (&quot;黑色方格&quot;) . 对于死细胞,我们将打印<code>◻️</code> (&quot;白色方格&quot;) .</p>
<p>通过实施<a href="https://doc.rust-lang.org/1.25.0/std/fmt/trait.Display.html"><code>Display</code></a>是来自 Rust标准库 的特性,我们可以添加一种以 面向用户的方式 格式化结构的方法. 这也会自动给我们一个<a href="https://doc.rust-lang.org/1.25.0/std/string/trait.ToString.html"><code>to_string</code></a>方法.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fmt;

impl fmt::Display for Universe {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        for line in self.cells.as_slice().chunks(self.width as usize) {
            for &amp;cell in line {
                let symbol = if cell == Cell::Dead { &quot;◻️&quot; } else { &quot;◼️&quot; };
                write!(f, &quot;{}&quot;, symbol)?;
            }
            write!(f, &quot;\n&quot;)?;
        }

        Ok(())
    }
}
#}</code></pre></pre>
<p>最后,我们定义一个构造函数,用一个有趣的 活细胞和死细胞 模式来初始化宇宙,以及<code>render</code>方法:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// Public methods, exported to JavaScript.
#[wasm_bindgen]
impl Universe {
    // ...

    pub fn new() -&gt; Universe {
        let width = 64;
        let height = 64;

        let cells = (0..width * height)
            .map(|i| {
                if i % 2 == 0 || i % 7 == 0 {
                    Cell::Alive
                } else {
                    Cell::Dead
                }
            })
            .collect();

        Universe {
            width,
            height,
            cells,
        }
    }

    pub fn render(&amp;self) -&gt; String {
        self.to_string()
    }
}
#}</code></pre></pre>
<p>有了这个,我们的生命游戏 Rust 实现的一半就完成了!</p>
<a class="header" href="print.html#a使用-javascript-渲染" id="a使用-javascript-渲染"><h2>使用 JavaScript 渲染</h2></a>
<p>首先,让我们添加一个<code>&lt;pre&gt;</code>HTML用于渲染:</p>
<pre><code class="language-html">&lt;body&gt;
    &lt;pre id=&quot;game-of-life-canvas&quot;&gt;&lt;/pre&gt;
    &lt;script src='./bootstrap.js'&gt;&lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>另外,我们想要的<code>&lt;pre&gt;</code>以网页中间为中心. 我们可以使用 CSS flex 来完成这项任务. 添加以下内容<code>&lt;style&gt;</code>在<code>index.html</code>的<code>&lt;head&gt;</code>里面:</p>
<pre><code class="language-html">&lt;style&gt;
    body {
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
    }
&lt;/style&gt;
</code></pre>
<p>在顶端<code>index.js</code>,让我们修复我们的导入来引入<code>Universe</code>而不是旧的<code>greet</code>功能:</p>
<pre><code class="language-js">import { Universe } from &quot;./wasm_game_of_life&quot;;
</code></pre>
<p>另外,让我们获取<code>&lt;pre&gt;</code>并实例化新 Universe 的元素:</p>
<pre><code class="language-js">const pre = document.getElementById(&quot;game-of-life-canvas&quot;);
const universe = Universe.new();
</code></pre>
<p>JavaScript 运行于<code>requestAnimationFrame</code>循环. 在每次迭代中,它将当前的 Universe 绘制到<code>&lt;pre&gt;</code>,然后运行<code>Universe::tick</code>.</p>
<pre><code class="language-js">const renderLoop = () =&gt; {
  pre.textContent = universe.render();
  universe.tick();

  requestAnimationFrame(renderLoop);
};
</code></pre>
<p>要开始渲染过程,我们所要做的就是为渲染循环的第一次迭代进行初始调用:</p>
<pre><code class="language-js">requestAnimationFrame(renderLoop);
</code></pre>
<p>这就是它现在的样子:</p>
<p><a href="./images/game-of-life/initial-game-of-life-pre.png"><img src="./images/game-of-life/initial-game-of-life-pre.png" alt="Screenshot of the Game of Life implementation with text rendering" /></a></p>
<a class="header" href="print.html#a直接从内存渲染到画布" id="a直接从内存渲染到画布"><h2>直接从内存渲染到画布</h2></a>
<p>在 Rust 中生成 (和分配) 一个<code>String</code>, 然后有<code>wasm-bindgen</code>将其转换为有效的 JavaScript字符串 ,来会生成 Universe单元格 的不必要副本. 而不是我们现在的<code>render</code>方法,我们可以返回一个指向 单元格数组开头 的指针. JavaScript代码 知道 Universe 的宽度和高度,并且可以直接读取构成单元格的字节. 此设计不会 复制 Universe的单元格 或 JavaScript垃圾收集器 的运转,但我们必须直接从 JavaScript 中读取 WebAssembly线性内存 中的单元格字节. 我们将切换到使用<a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API">Canvas API</a>. 而不是渲染 unicode文本. 我们将在本教程的其余部分中使用此设计.</p>
<p>首先,让我们替换<code>pre</code>,换成了一个<code>&lt;canvas&gt;</code> (它也应该在<code>&lt;body&gt;</code>, <code>&lt;script&gt;</code>加载我们的 JavaScript 之前) :</p>
<pre><code class="language-html">&lt;body&gt;
    &lt;canvas id=&quot;game-of-life-canvas&quot;&gt;&lt;/canvas&gt;
    &lt;script src='./bootstrap.js'&gt;&lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>为了从 Rust实现 中获取必要的信息,我们需要为 Universe 的宽度,高度和指向 其单元数组 的指针 添加一些更多的 <code>getter</code>函数. 所有这些都暴露在JavaScript 中.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// Public methods, exported to JavaScript.
#[wasm_bindgen]
impl Universe {
    // ...

    pub fn width(&amp;self) -&gt; u32 {
        self.width
    }

    pub fn height(&amp;self) -&gt; u32 {
        self.height
    }

    pub fn cells(&amp;self) -&gt; *const Cell {
        self.cells.as_ptr()
    }
}
#}</code></pre></pre>
<p>接下来,让我们定义 JavaScript 在渲染画布时将使用的一些常量:</p>
<pre><code class="language-js">const CELL_SIZE = 5; // px
const GRID_COLOR = &quot;#CCCCCC&quot;;
const DEAD_COLOR = &quot;#FFFFFF&quot;;
const ALIVE_COLOR = &quot;#000000&quot;;

// These must match `Cell::Alive` and `Cell::Dead` in `src/lib.rs`.
const DEAD = 0;
const ALIVE = 1;
</code></pre>
<p>现在,让我们重写当前的 JS代码 (导入除外) ,不再写入<code>&lt;pre&gt;</code>而是专注在<code>&lt;canvas&gt;</code>:</p>
<pre><code class="language-js">// Construct the universe, and get its width and height.
const universe = Universe.new();
const width = universe.width();
const height = universe.height();

// Give the canvas room for all of our cells and a 1px border
// around each of them.
const canvas = document.getElementById(&quot;game-of-life-canvas&quot;);
canvas.height = (CELL_SIZE + 1) * height + 1;
canvas.width = (CELL_SIZE + 1) * width + 1;

const ctx = canvas.getContext('2d');

const renderLoop = () =&gt; {
  universe.tick();

  drawGrid();
  drawCells();

  requestAnimationFrame(renderLoop);
};
</code></pre>
<p>为了在单元格之间绘制网格,我们绘制 一组等间隔 的 水平线 和 一组等间距 的 垂直线. 这些线 纵横交错 形成网格.</p>
<pre><code class="language-js">const drawGrid = () =&gt; {
  ctx.beginPath();
  ctx.lineWidth = 1 / window.devicePixelRatio;
  ctx.strokeStyle = GRID_COLOR;

  // Vertical lines.
  for (let i = 0; i &lt;= width; i++) {
    ctx.moveTo(i * (CELL_SIZE + 1) + 1, 0);
    ctx.lineTo(i * (CELL_SIZE + 1) + 1, (CELL_SIZE + 1) * height + 1);
  }

  // Horizontal lines.
  for (let j = 0; j &lt;= height; j++) {
    ctx.moveTo(0,                           j * (CELL_SIZE + 1) + 1);
    ctx.lineTo((CELL_SIZE + 1) * width + 1, j * (CELL_SIZE + 1) + 1);
  }

  ctx.stroke();
};
</code></pre>
<p>为了绘制 细胞,我们将 细胞数 从 WebAssembly memory 拿出 ,构造一个<code>Uint8Array</code>覆盖细胞缓冲区,迭代每个细胞,并分别根据 细胞是死还是活,绘制白色或黑色矩形. 通过使用 <code>idx</code> 和 覆盖,我们避免在每个<code>tick</code>上跨越边界复制单元格.</p>
<pre><code class="language-js">// Import the WebAssembly memory at the top of the file.
import { memory } from &quot;./wasm_game_of_life_bg&quot;;

// ...

const getIndex = (row, column) =&gt; {
  return row * width + column;
};

const drawCells = () =&gt; {
  const cellsPtr = universe.cells();
  const cells = new Uint8Array(memory.buffer, cellsPtr, width * height);

  ctx.beginPath();

  for (let row = 0; row &lt; height; row++) {
    for (let col = 0; col &lt; width; col++) {
      const idx = getIndex(row, col);

      ctx.fillStyle = cells[idx] === DEAD
        ? DEAD_COLOR
        : ALIVE_COLOR;

      ctx.fillRect(
        col * (CELL_SIZE + 1) + 1,
        row * (CELL_SIZE + 1) + 1,
        CELL_SIZE,
        CELL_SIZE
      );
    }
  }

  ctx.stroke();
};
</code></pre>
<p>要开始渲染过程,我们将使用与 上部分相同的代码 来开始渲染循环的第一次迭代:</p>
<pre><code class="language-js">requestAnimationFrame(renderLoop);
</code></pre>
<a class="header" href="print.html#a它工作了" id="a它工作了"><h2>它工作了!</h2></a>
<p>重建 WebAssembly 和 绑定 :</p>
<pre><code>npm run build-debug
</code></pre>
<p>确保您的开发服务器仍在运行. 如果不是,请再次启动:</p>
<pre><code>npm run serve
</code></pre>
<p>如果你刷新<a href="http://localhost:8080/">http://localhost:8080/</a>,你应该受到令人兴奋的展示!</p>
<p><a href="./images/game-of-life/initial-game-of-life.png"><img src="./images/game-of-life/initial-game-of-life.png" alt="Screenshot of the Game of Life implementation" /></a></p>
<p>您可以 checkout <code>chapter-one</code> branch 找到完整代码.</p>
<p>还有一个非常巧妙的算法,来实现生命游戏<a href="https://en.wikipedia.org/wiki/Hashlife">hashlife</a>. 它使用积极的记忆,实际上可以获得<em>指数级更快</em>计算后代的时间越长! 鉴于此,您可能想知道为什么我们在本教程中没有实现<code>hashlife</code>. 因为它超出了本文的范围,我们专注于 Rust和WebAssembly 集成,但我们强烈建议您自己去了解<code>hashlife</code>!</p>
<a class="header" href="print.html#a练习-2" id="a练习-2"><h2>练习</h2></a>
<ul>
<li>
<p>使用单个太空飞船,初始化宇宙.</p>
</li>
<li>
<p>不是硬编码最初的宇宙,而是生成一个随机的,有五十五个细胞活着或死亡的机会.</p>
<p><em>提示: 使用<code>wasm_bindgen</code> import <code>Math.random</code> JavaScript函数:</em></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
extern {
    #[wasm_bindgen(js_namespace = Math)]
    fn random() -&gt; f64;
}
#}</code></pre></pre>
</li>
<li>
<p>用 一个字节 表示 每个单元格 可以很容易地迭代单元格,但这是以浪费内存为代价的. 每个字节是8位,但我们只需要 一个位 来表示每个单元 是活还是死. 重构数据表示,以便每个单元,仅使用一个空格位.</p>
</li>
</ul>
<a class="header" href="print.html#a调试" id="a调试"><h1>调试</h1></a>
<p>在我们编写更多代码之前,我们需要在出现问题时使用一些调试工具.</p>
<a class="header" href="print.html#a使用调试符号构建" id="a使用调试符号构建"><h2>使用调试符号构建</h2></a>
<blockquote>
<p>⚡调试时,请务必确保使用调试符号构建!</p>
</blockquote>
<p>如果您没有启用调试符号,那么<code>&quot;name&quot;</code>部分将不会出现在<code>.wasm</code>二进制编译中和堆栈跟踪将具有类似的函数名称<code>wasm[42]</code>而不是<code>wasm_game_of_life::Universe::live_neighbor_count</code>.</p>
<p>使用&quot;debug&quot;版本时 (又称<code>npm run build-debug</code>) 默认情况下启用调试符号.</p>
<p>使用&quot;release&quot;构建时,默认情况下不启用调试符号. 要启用调试符号,请确保您<code>debug = true</code>在<code>Cargo.toml</code>的<code>[profile.release]</code>:</p>
<pre><code class="language-toml">[profile.release]
debug = true
</code></pre>
<p>默认情况下我们一直在使用的项目模板添加了这个<code>Cargo.toml</code>,为方便起见.</p>
<a class="header" href="print.html#a记录" id="a记录"><h2>记录</h2></a>
<p>记录是我们用来证明和反驳我们的程序错误原因的最有效工具之一. 在 web 上,<code>console.log</code> 是将消息记录到浏览器的开发人员工具控制台的方法. 我们可以用<code>wasm_bindgen</code>导入对它的引用,如下所示:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
extern {
    #[wasm_bindgen(js_namespace = console)]
    fn log(msg: &amp;str);
}

// A macro to 提供 `println!(..)`-style syntax 给 `console.log` logging.
macro_rules! log {
    ($($t:tt)*) =&gt; (log(&amp;format!($($t)*)))
}
#}</code></pre></pre>
<p>然后,我们可以通过在Rust代码中,插入<code>log</code>调用将消息记录到控制台. 例如,要记录每个单元的状态,活动邻居数和下一个状态,我们可以像这样修改我们的代码:</p>
<pre><code class="language-diff">diff --git a/src/lib.rs b/src/lib.rs
index f757641..a30e107 100755
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -63,6 +63,11 @@ impl Universe {
                 let cell = self.cells[idx];
                 let live_neighbors = self.live_neighbor_count(row, col);

+                log!(
+                    &quot;cell[{}, {}] is initially {:?} and has {} live neighbors&quot;,
+                    row, col, cell, live_neighbors
+                );
+
                 let next_cell = match (cell, live_neighbors) {
                     // Rule 1: Any live cell with fewer than two live neighbours
                     // dies, as if caused by underpopulation.
@@ -80,6 +85,8 @@ impl Universe {
                     (otherwise, _) =&gt; otherwise,
                 };

+                log!(&quot;    it becomes {:?}&quot;, next_cell);
+
                 next[idx] = next_cell;
             }
         }
</code></pre>
<p><code>console.log</code>或者<code>console.error</code>函数具有相同的接口<code>,但是,</code>console.error`在开发人员工具也倾向于在记录消息时捕获并显示堆栈跟踪用来.</p>
<a class="header" href="print.html#a参考" id="a参考"><h3>参考</h3></a>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Console">该<code>console</code>对象</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Tools/Web_Console">Firefox开发人员工具 -  Web控制台</a></li>
<li><a href="https://docs.microsoft.com/en-us/microsoft-edge/devtools-guide/console">Microsoft Edge开发人员工具 - 控制台</a></li>
<li><a href="https://developers.google.com/web/tools/chrome-devtools/console/get-started">开始使用Chrome DevTools控制台</a></li>
</ul>
<a class="header" href="print.html#a使用调试器" id="a使用调试器"><h2>使用调试器</h2></a>
<p>不幸的是,WebAssembly 的调试仍然不成熟. 在大多数 Unix系统上,<a href="http://dwarfstd.org/">DWARF</a>用于编码调试器提供正在运行的程序的源级检查的信息. 在Windows 上有一种替代格式可以编码类似的信息. 目前, WebAssembly 没有等价物. 因此,调试器目前提供有限的实用程序,我们最终逐步执行编译器发出的原始 WebAssembly 指令,而不是我们编写的Rust源文本.</p>
<p>尽管如此,调试器仍然可用于检查 与WebAssembly交互的JavaScript. 例如,我们可以使用调试器在我们的<code>renderLoop</code>函数每次迭代中暂停. 这为我们提供了一个方便的检查点,用于检查记录的消息,并将当前呈现的帧与前一帧进行比较.</p>
<p><a href="./images/game-of-life/debugging.png"><img src="./images/game-of-life/debugging.png" alt="Screenshot of debugging the Game of Life" /></a></p>
<a class="header" href="print.html#a参考-1" id="a参考-1"><h3>参考</h3></a>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Tools/Debugger">Firefox开发者工具 - 调试器</a></li>
<li><a href="https://docs.microsoft.com/en-us/microsoft-edge/devtools-guide/debugger">Microsoft Edge开发人员工具 - 调试器</a></li>
<li><a href="https://developers.google.com/web/tools/chrome-devtools/javascript/">开始在Chrome DevTools中调试JavaScript</a></li>
</ul>
<a class="header" href="print.html#a首先避免调试webassembly" id="a首先避免调试webassembly"><h2>首先避免调试WebAssembly</h2></a>
<p>虽然一些错误特定于 JavaScript和WebAssembly 的接口,但经验表明大多数错误都没有. 尝试将 bug重现 通过正常的Rust<code>#[test]</code>函数,您可以在调试时利用操作系统的成熟工具. 使用测试箱子<a href="https://crates.io/crates/quickcheck"><code>quickcheck</code></a>练习您向JavaScript公开的接口. 最终,如果您可以在不需要与 JavaScript交互 的小测试用例中隔离它们,您将更容易找到并修复错误.</p>
<p>注意,为了运行<code>#[test]</code>没有编译器和链接器错误,你需要添加<code>#![wasm_bindgen]</code>注释和<code>crate-type = &quot;cdylib&quot;</code>.</p>
<a class="header" href="print.html#a练习-3" id="a练习-3"><h2>练习</h2></a>
<ul>
<li>
<p>添加日志记录到<code>tick</code>函数,记录每个单元格的行和列 - 状态从活动转换为死亡,反之亦然.</p>
</li>
<li>
<p>介绍一个<code>panic!()</code>在<code>Universe::new</code>方法里面. 在 Web浏览器的JavaScript调试器 中检查恐慌的回溯. 禁用调试符号,重建并再次检查堆栈跟踪. 不是很有用,是吗?</p>
</li>
<li>
<p>checkout <code>chapter-one-with-bug</code> branch. 重建并重新加载网页. 现在很明显, 这个分支的实现包含一个<code>bug</code>, 每个单元格显然都是活着的. 这是您的作者在最初创建示例代码时, 所犯的真实世界 (tm) 错误. 找到错误并修复它. *不要看提交历史! 那是作弊 ;-) *</p>
</li>
</ul>
<a class="header" href="print.html#a增加交互性" id="a增加交互性"><h1>增加交互性</h1></a>
<p>我们将通过在 Game of Life 实现中, 添加一些交互功能来继续探索 JavaScript和WebAssembly接口. 我们将允许用户通过单击,来切换单元格是活着还是死亡,并允许暂停游戏,这使得绘制单元格模式更加容易.</p>
<a class="header" href="print.html#a暂停和恢复游戏" id="a暂停和恢复游戏"><h2>暂停和恢复游戏</h2></a>
<p>让我们添加一个按钮来切换游戏是正在播放还是暂停. 到<code>index.html</code>,在<code>&lt;canvas&gt;</code>上方添加按钮:</p>
<pre><code class="language-html">&lt;button id=&quot;play-pause&quot;&gt;&lt;/button&gt;
</code></pre>
<p>在 JavaScript 中,我们将进行以下更改:</p>
<ul>
<li>
<p>跟踪最新返回的标识符<code>requestAnimationFrame</code>,
以便我们可以通过调用<code>cancelAnimationFrame</code>取消那个标识符动画.</p>
</li>
<li>
<p>单击播放/暂停按钮时,检查我们是否具有排队动画帧的标识符.
1.点击时,游戏当前正在播放,取消动画帧<code>renderLoop</code>,有效地暂停游戏.
2.点击时,当前暂停,没有排队动画帧的标识符,我们想运行<code>requestAnimationFrame</code>恢复比赛.</p>
</li>
</ul>
<p>因为 JavaScript 正在驱动 Rust和WebAssembly,所以我们需要这样做,而且我们不需要更改 Rust源代码.</p>
<p>我们介绍一下<code>animationId</code>变量来跟踪返回的标识符<code>requestAnimationFrame</code>. 当没有排队的动画帧时,我们将此变量设置为<code>null</code>.</p>
<pre><code class="language-js">let animationId = null;

// This function is the same as before, except the
// result of `requestAnimationFrame` is assigned to
// `animationId`.
const renderLoop = () =&gt; {
  universe.tick();

  drawCells();
  drawGrid();

  animationId = requestAnimationFrame(renderLoop);
};
</code></pre>
<p>在任何时刻,我们都可以通过<code>animationId</code>检查游戏,来判断游戏是否暂停:</p>
<pre><code class="language-js">const isPaused = () =&gt; {
  return animationId === null;
};
</code></pre>
<p>现在,当点击 播放/暂停 按钮时,我们会检查游戏当前是暂停还是正在播放,要么继续播放<code>renderLoop</code>动画要么取消下一个动画帧.
此外,我们更新按钮的文本图标,以反映按钮在下次单击时将执行的操作.</p>
<pre><code class="language-js">const playPauseButton = document.getElementById(&quot;play-pause&quot;);

const play = () =&gt; {
  playPauseButton.textContent = &quot;⏸&quot;;
  renderLoop();
};

const pause = () =&gt; {
  playPauseButton.textContent = &quot;▶&quot;;
  cancelAnimationFrame(animationId);
  animationId = null;
};

playPauseButton.addEventListener(&quot;click&quot;, event =&gt; {
  if (isPaused()) {
    play();
  } else {
    pause();
  }
});
</code></pre>
<p>最后,我们直接调用<code>requestAnimationFrame(renderLoop)</code>用来启动之前的游戏及其动画,
但我们想用<code>play</code>替换它,以便按钮获得正确的初始文本图标.</p>
<pre><code class="language-diff">// This used to be `requestAnimationFrame(renderLoop)`.
play();
</code></pre>
<p>刷新<a href="http://localhost:8080/">http://localhost:8080/</a>现在你应该可以通过点击按钮来暂停和恢复游戏!</p>
<a class="header" href="print.html#a切换一个cell的状态click活动" id="a切换一个cell的状态click活动"><h2>切换一个Cell的状态<code>&quot;click&quot;</code>活动</h2></a>
<p>现在我们可以暂停游戏了,现在是时候添加通过点击它们来改变细胞的能力了.</p>
<p>切换单元格是将其状态从活动状态转换为死亡状态,或从死亡状态转换为活动状态:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Cell {
    fn toggle(&amp;mut self) {
        *self = match *self {
            Cell::Dead =&gt; Cell::Alive,
            Cell::Alive =&gt; Cell::Dead,
        };
    }
}
#}</code></pre></pre>
<p>要切换给定行和列的单元格状态,我们将行和列对转换为单元格向量的索引,并在该索引处的单元格上调用<code>toggle</code>方法:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// Public methods, exported to JavaScript.
#[wasm_bindgen]
impl Universe {
    // ...

    pub fn toggle_cell(&amp;mut self, row: u32, column: u32) {
        let idx = self.get_index(row, column);
        self.cells[idx].toggle();
    }
}
#}</code></pre></pre>
<p>这个方法是在<code>impl</code>带有注释的块<code>#[wasm_bindgen]</code>这样它就可以被 JavaScript 调用.</p>
<p>在 JavaScript 中,我们会监听 点击事件<code>&lt;canvas&gt;</code>元素,将 <code>click事件</code>的页面 相对坐标转换为画布相对坐标,
然后转换为行和列,调用<code>toggle_cell</code>方法,最后重绘场景.</p>
<pre><code class="language-js">canvas.addEventListener(&quot;click&quot;, event =&gt; {
  const boundingRect = canvas.getBoundingClientRect();

  const scaleX = canvas.width / boundingRect.width;
  const scaleY = canvas.height / boundingRect.height;

  const canvasLeft = (event.clientX - boundingRect.left) * scaleX;
  const canvasTop = (event.clientY - boundingRect.top) * scaleY;

  const row = Math.min(Math.floor(canvasTop / (CELL_SIZE + 1)), height - 1);
  const col = Math.min(Math.floor(canvasLeft / (CELL_SIZE + 1)), width - 1);

  universe.toggle_cell(row, col);

  drawCells();
  drawGrid();
});
</code></pre>
<p>刷新<a href="http://localhost:8080/">http://localhost:8080/</a>再次,您现在可以通过单击单元格并切换其状态来绘制自己的模式.</p>
<p>您可以在 checkout <code>chapter-two</code> branch , 找到此实现的完整源代码.</p>
<a class="header" href="print.html#a练习-4" id="a练习-4"><h2>练习</h2></a>
<ul>
<li>
<p>添加一个<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/range"><code>&lt;input type=&quot;range&quot;&gt;</code></a>用于控制每个动画帧出现多少<code>tick</code>的小部件.</p>
</li>
<li>
<p>添加一个将<code>Universe</code>重置为随机初始状态的按钮. 另一个按钮将宇宙重置为所有死细胞.</p>
</li>
<li>
<p><code>Ctrl + Click</code>,插入一个<a href="https://en.wikipedia.org/wiki/Glider_(Conway%27s_Life)">滑翔机</a>以目标细胞为中心. 上<code>Shift + Click</code>,插入一个脉冲星.</p>
</li>
</ul>
<a class="header" href="print.html#a时间分析" id="a时间分析"><h1>时间分析</h1></a>
<p>本章介绍如何使用 Rust和WebAssembly 来分析Web页面,其目标是提高吞吐量或降低延迟.</p>
<blockquote>
<p>⚡始终确保使用的是<code>--release</code>分析! 使用我们的项目模板,这意味着使用<code>npm run build-release</code>代替<code>npm run build-debug</code>.</p>
</blockquote>
<a class="header" href="print.html#a可用工具" id="a可用工具"><h2>可用工具</h2></a>
<a class="header" href="print.html#a该performancenow计时器" id="a该performancenow计时器"><h3>该<code>performance.now()</code>计时器</h3></a>
<p>该<a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/now"><code>performance.now()</code></a>函数返回,自加载网页以来以毫秒为单位测量的单调时间戳. 我们可以使用它来计算各种操作的时间,我们可以通过以下方式 从Rust 访问它,通过<code>wasm_bindgen</code>导入申报:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
extern {
    #[wasm_bindgen(js_namespace = performance)]
    fn now() -&gt; f64;
}
#}</code></pre></pre>
<p>调用<code>performance.now</code>开销很小,因此我们可以从中创建简单的测量,而不会扭曲系统其他部分的性能.</p>
<p>例如,我们可以创建一个简单的 <code>FPS-帧数</code> 计数器,我们在每次迭代时更新<code>renderLoop</code>:</p>
<pre><code class="language-js">const fps = new class {
  constructor() {
    this.fps = document.getElementById(&quot;fps&quot;);
    this.frames = [];
    this.lastFrameTimeStamp = performance.now();
  }

  render() {
    // 时间计算.
    const now = performance.now();
    const delta = now - this.lastFrameTimeStamp;
    this.lastFrameTimeStamp = now;
    const fps = 1 / delta * 1000;

    // Save only the latest 100 timings.
    this.frames.push(fps);
    if (this.frames.length &gt; 100) {
      this.frames.shift();
    }

    // 找出我们100个最新时间的最大值，最小值和平均值.
    let min = Infinity;
    let max = -Infinity;
    let sum = 0;
    for (let i = 0; i &lt; this.frames.length; i++) {
      sum += this.frames[i];
      min = Math.min(this.frames[i], min);
      max = Math.max(this.frames[i], max);
    }
    let mean = sum / this.frames.length;

    // Render the statistics.
    this.fps.textContent = `
Frames per Second:
         latest = ${Math.round(fps)}
avg of last 100 = ${Math.round(mean)}
min of last 100 = ${Math.round(min)}
max of last 100 = ${Math.round(max)}
`.trim();
  }
};
</code></pre>
<a class="header" href="print.html#a开发人员工具profilers" id="a开发人员工具profilers"><h3>开发人员工具Profilers</h3></a>
<p>所有 Web浏览器 的内置开发人员工具都包含一个分析器. 这些分析器显示哪些函数花费最多时间的可视化,如调用树和火焰图. 如果你<a href="/game-of-life/debugging.html#building-with-debug-symbols">用调试符号构建</a>,然后这些分析器应该显示 Rust函数名称 而不是像<code>wasm-function[123]</code>. 请注意这些分析器<em>惯于</em>显示内联函数,由于 Rust和LLVM 依赖于如此大量的内联,结果可能会有点令人困惑.</p>
<p><a href="./images/game-of-life/profiler-with-rust-names.png"><img src="./images/game-of-life/profiler-with-rust-names.png" alt="Screenshot of profiler with Rust symbols" /></a></p>
<a class="header" href="print.html#a资源" id="a资源"><h4>资源</h4></a>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Tools/Performance">Firefox开发者工具 - 性能</a></li>
<li><a href="https://docs.microsoft.com/en-us/microsoft-edge/devtools-guide/performance">Microsoft Edge开发人员工具 - 性能</a></li>
<li><a href="https://developers.google.com/web/tools/chrome-devtools/rendering-tools/js-execution">Chrome DevTools JavaScript Profiler</a></li>
</ul>
<a class="header" href="print.html#consoletime和consoletimeend功能" id="consoletime和consoletimeend功能"><h3><code>console.time</code>和<code>console.timeEnd</code>功能</h3></a>
<p><code>console.time</code>和<code>console.timeEnd</code>函数允许您将命名操作的时间记录到浏览器的开发人员工具控制台.</p>
<p>你可以用它将它们导入 Rust<code>wasm-bindgen</code> 声明中:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
extern {
    #[wasm_bindgen(js_namespace = console)]
    fn time(name: &amp;str);

    #[wasm_bindgen(js_namespace = console)]
    fn timeEnd(name: &amp;str);
}
#}</code></pre></pre>
<p>因为<code>console.timeEnd</code>有对应的<code>console.time</code>调用,将它们包装在 RAII 类型中很方便:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Timer&lt;'a&gt; {
    name: &amp;'a str,
}

impl&lt;'a&gt; Timer&lt;'a&gt; {
    pub fn new(name: &amp;'a str) -&gt; Timer&lt;'a&gt; {
        time(name);
        Timer { name }
    }
}

impl&lt;'a&gt; Drop for Timer&lt;'a&gt; {
    fn drop(&amp;mut self) {
        timeEnd(self.name);
    }
}
#}</code></pre></pre>
<p>然后,我们可以计算每个时间<code>Universe::tick</code>,将此代码段添加到方法的顶部:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let _timer = Timer::new(&quot;Universe::tick&quot;);
#}</code></pre></pre>
<p>现在每次运行的时间<code>Universe::tick</code>都会记录了:</p>
<p><a href="./images/game-of-life/console-time.png"><img src="./images/game-of-life/console-time.png" alt="Screenshot of console.time logs" /></a></p>
<p>另外,<code>console.time</code>和<code>console.timeEnd</code>对将显示在,浏览器的分析器的&quot;timeline&quot;或&quot;waterfall&quot;视图中:</p>
<p><a href="./images/game-of-life/console-time-in-profiler.png"><img src="./images/game-of-life/console-time-in-profiler.png" alt="Screenshot of console.time logs" /></a></p>
<a class="header" href="print.html#a运用bench与本地代码" id="a运用bench与本地代码"><h3>运用<code>#[bench]</code>与本地代码</h3></a>
<p>我们通常也可以通过编写,来利用我们操作系统的本机代码调试工具<code>#[test]</code>而不是在Web上调试,我们也可以通过编写<code>#[bench]</code>功能.</p>
<p>然而!在为本机代码分析投入大量精力之前,请确保您知道瓶颈在 WebAssembly 中! 使用浏览器的分析器确认这一点,否则您可能会浪费时间来优化不热的代码.</p>
<a class="header" href="print.html#a发展我们的生命博弈宇宙" id="a发展我们的生命博弈宇宙"><h2>发展我们的生命博弈宇宙</h2></a>
<p>如果我们让我们的生命游戏世界更大,会发生什么? 使用 128 x 128 宇宙替换 64 x 64 宇宙导致FPS从 平滑的60 下降到 40-ish.</p>
<p>如果我们记录一个配置文件并查看瀑布视图,我们会看到每个动画帧花费超过20毫秒. 回想一下,每秒60帧,每帧大概16毫秒. 16毫秒内不仅仅是有我们的 JavaScript和WebAssembly ,还有浏览器正在做的其他事情,比如绘制页面.</p>
<p><a href="./images/game-of-life/drawCells-before-waterfall.png"><img src="./images/game-of-life/drawCells-before-waterfall.png" alt="Screenshot of a waterfall view of rendering a frame" /></a></p>
<p>如果我们看一下单个动画帧中发生的事情,我们就会看到<code>CanvasRenderingContext2D.fillStyle</code> 很长!</p>
<p><a href="./images/game-of-life/drawCells-before-flamegraph.png"><img src="./images/game-of-life/drawCells-before-flamegraph.png" alt="Screenshot of a flamegraph view of rendering a frame" /></a></p>
<p>我们可以通过查看调用树的多个帧的聚合来确认这不是异常:</p>
<p><a href="./images/game-of-life/drawCells-before-calltree.png"><img src="./images/game-of-life/drawCells-before-calltree.png" alt="Screenshot of a flamegraph view of rendering a frame" /></a></p>
<p>我们将近40%的时间都花在了这个函数身上!</p>
<blockquote>
<p>⚡我们可能对此有所期待<code>tick</code>方法是性能瓶颈,但事实并非如此. 让分析引导您的注意力,而不是把时间花在您想当然的地方.</p>
</blockquote>
<p>在<code>drawCells</code>函数,在每个动画帧上,<code>fillStyle</code>为宇宙中的每个单元格设置一次:</p>
<pre><code class="language-js">for (let row = 0; row &lt; height; row++) {
  for (let col = 0; col &lt; width; col++) {
    const idx = getIndex(row, col);

    ctx.fillStyle = cells[idx] === DEAD
      ? DEAD_COLOR
      : ALIVE_COLOR;

    ctx.fillRect(
      col * (CELL_SIZE + 1) + 1,
      row * (CELL_SIZE + 1) + 1,
      CELL_SIZE,
      CELL_SIZE
    );
  }
}
</code></pre>
<p>现在我们已经发现了这个<code>fillStyle</code>是如此昂贵,我们可以做些什么来避免经常设置它? 改变<code>fillStyle</code>取决于细胞是活着还是死亡. 如果我们设定<code>fillStyle = ALIVE_COLOR</code>, 然后在一次总绘制每个活细胞,然后设置<code>fillStyle = DEAD_COLOR</code>,并在另一次总绘制每个死细胞,那么我们只设置<code>fillStyle</code>两次,而不是每个细胞一次.</p>
<pre><code class="language-js">// Alive cells.
ctx.fillStyle = ALIVE_COLOR;
for (let row = 0; row &lt; height; row++) {
  for (let col = 0; col &lt; width; col++) {
    const idx = getIndex(row, col);
    if (cells[idx] !== ALIVE) {
      continue;
    }

    ctx.fillRect(
      col * (CELL_SIZE + 1) + 1,
      row * (CELL_SIZE + 1) + 1,
      CELL_SIZE,
      CELL_SIZE
    );
  }
}

// Dead cells.
ctx.fillStyle = DEAD_COLOR;
for (let row = 0; row &lt; height; row++) {
  for (let col = 0; col &lt; width; col++) {
    const idx = getIndex(row, col);
    if (cells[idx] !== DEAD) {
      continue;
    }

    ctx.fillRect(
      col * (CELL_SIZE + 1) + 1,
      row * (CELL_SIZE + 1) + 1,
      CELL_SIZE,
      CELL_SIZE
    );
  }
}
</code></pre>
<p>保存这些更改并刷新后<a href="http://localhost:8080/">http://localhost:8080/</a>,渲染回到平滑每秒60帧.</p>
<p>如果我们采用另一个配置文件,我们可以看到现在每个动画帧只花费大约10毫秒.</p>
<p><a href="./images/game-of-life/drawCells-after-waterfall.png"><img src="./images/game-of-life/drawCells-after-waterfall.png" alt="Screenshot of a waterfall view of rendering a frame after the drawCells changes" /></a></p>
<p>打破了超时帧,我们看到了<code>fillStyle</code>昂贵的成本消失了,我们的大部分时间花在了内部<code>fillRect</code>,绘制每个单元格的矩形.</p>
<p><a href="./images/game-of-life/drawCells-after-flamegraph.png"><img src="./images/game-of-life/drawCells-after-flamegraph.png" alt="Screenshot of a flamegraph view of rendering a frame after the drawCells changes" /></a></p>
<a class="header" href="print.html#a让时间更快" id="a让时间更快"><h2>让时间更快</h2></a>
<p>有些人不喜欢等待,认为每个动画帧是 9个 <code>tick</code>. 我们可以修改<code>renderLoop</code>函数,这很容易做到这一点:</p>
<pre><code class="language-js">for (let i = 0; i &lt; 9; i++) {
  universe.tick();
}
</code></pre>
<p>在我的机器上,这使我们恢复到每秒35帧. 不好. 我们想要那个美丽的 <code>60!</code></p>
<p>现在我们知道时间花在了<code>Universe::tick</code>,让我们添加一些<code>Timer</code>,用它来包装,给予<code>console.time</code>和<code>console.timeEnd</code>运行,引导我们. 我的假设是,分配一个新的细胞载体,并在每个滴答上释放旧的是昂贵的成本,占用了我们时间预算的很大一部分.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub fn tick(&amp;mut self) {
    let _timer = Timer::new(&quot;Universe::tick&quot;);

    let mut next = {
        let _timer = Timer::new(&quot;allocate next cells&quot;);
        self.cells.clone()
    };

    {
        let _timer = Timer::new(&quot;new generation&quot;);
        for row in 0..self.height {
            for col in 0..self.width {
                let idx = self.get_index(row, col);
                let cell = self.cells[idx];
                let live_neighbors = self.live_neighbor_count(row, col);

                let next_cell = match (cell, live_neighbors) {
                    // Rule 1: Any live cell with fewer than two live neighbours
                    // dies, as if caused by underpopulation.
                    (Cell::Alive, x) if x &lt; 2 =&gt; Cell::Dead,
                    // Rule 2: Any live cell with two or three live neighbours
                    // lives on to the next generation.
                    (Cell::Alive, 2) | (Cell::Alive, 3) =&gt; Cell::Alive,
                    // Rule 3: Any live cell with more than three live
                    // neighbours dies, as if by overpopulation.
                    (Cell::Alive, x) if x &gt; 3 =&gt; Cell::Dead,
                    // Rule 4: Any dead cell with exactly three live neighbours
                    // becomes a live cell, as if by reproduction.
                    (Cell::Dead, 3) =&gt; Cell::Alive,
                    // All other cells remain in the same state.
                    (otherwise, _) =&gt; otherwise,
                };

                next[idx] = next_cell;
            }
        }
    }

    let _timer = Timer::new(&quot;free old cells&quot;);
    self.cells = next;
}
#}</code></pre></pre>
<p>看看时间,很明显我的假设是不正确的: 实际上绝大部分时间花在,计算下一代细胞上. 令人惊讶的是,在每个单元上分配和释放载体似乎具有可忽略的成本. 再一次告诉指导我们的分析工作!</p>
<p><a href="./images/game-of-life/console-time-in-universe-tick.png"><img src="./images/game-of-life/console-time-in-universe-tick.png" alt="Screenshot of a Universe::tick timer results" /></a></p>
<p>我们可以写一个本机代码<code>#[bench]</code>来做同样的事情 - 我们的 WebAssembly 正在做的, 但我们可以使用更成熟的分析工具. 这就是新的<code>benches/bench.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![feature(test)]

#fn main() {
extern crate test;
extern crate wasm_game_of_life;

#[bench]
fn universe_ticks(b: &amp;mut test::Bencher) {
    let mut universe = wasm_game_of_life::Universe::new();

    b.iter(|| {
        universe.tick();
    });
}
#}</code></pre></pre>
<p>我们还要给上所有的<code>#[wasm_bindgen]</code>注释和<code>&quot;cdylib&quot;</code> - 来自<code>Cargo.toml</code>, 否则构建本机代码将失败并出现链接错误.</p>
<p>有了这一切,我们就可以运行了<code>cargo bench</code>编译并运行我们的基准测试!</p>
<pre><code>$ cargo bench
    Finished release [optimized + debuginfo] target(s) in 0.0 secs
     Running target/release/deps/wasm_game_of_life-91574dfbe2b5a124

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/release/deps/bench-8474091a05cfa2d9

running 1 test
test universe_ticks ... bench:     664,421 ns/iter (+/- 51,926)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured; 0 filtered out
</code></pre>
<p>这也告诉我们二进制文件的位置,我们可以再次运行基准测试,但这次是在我们的操作系统的分析器下. 就我而言,我运行在Linux,所以<code>perf</code>是我将使用的探查器:</p>
<pre><code>$ perf record -g target/release/deps/bench-8474091a05cfa2d9 --bench
running 1 test
test universe_ticks ... bench:     635,061 ns/iter (+/- 38,764)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured; 0 filtered out

[ perf record: Woken up 1 times to write data ]
[ perf record: Captured and wrote 0.178 MB perf.data (2349 samples) ]
</code></pre>
<p>使用<code>perf report</code>加载配置文件后,表明我们所有的时间都花在了<code>Universe::tick</code>,如预期的那样:</p>
<p><a href="./images/game-of-life/bench-perf-report.png"><img src="./images/game-of-life/bench-perf-report.png" alt="Screenshot of perf report" /></a></p>
<p><code>perf</code>注释说明函数的时间,通过指令<code>a</code>:</p>
<p><a href="./images/game-of-life/bench-perf-annotate.png"><img src="./images/game-of-life/bench-perf-annotate.png" alt="Screenshot of perf's instruction annotation" /></a></p>
<p>这告诉我们 <code>26.67%</code> 的时间用于求和相邻单元格的值,<code>23.41%</code> 的时间用于获取邻居的列索引,另外 <code>15.42%</code> 的时间用于获取邻居的行索引. 在这三个最昂贵的指令中,第二个和第三个指令都很昂贵之于<code>div 说明</code>. <code>div</code>实现模数索引逻辑在<code>Universe::live_neighbor_count</code>.</p>
<p>回想一下<code>live_neighbor_count</code>定义:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn live_neighbor_count(&amp;self, row: u32, column: u32) -&gt; u8 {
    let mut count = 0;
    for delta_row in [self.height - 1, 0, 1].iter().cloned() {
        for delta_col in [self.width - 1, 0, 1].iter().cloned() {
            if delta_row == 0 &amp;&amp; delta_col == 0 {
                continue;
            }

            let neighbor_row = (row + delta_row) % self.height;
            let neighbor_col = (column + delta_col) % self.width;
            let idx = self.get_index(neighbor_row, neighbor_col);
            count += self.cells[idx] as u8;
        }
    }
    count
}
#}</code></pre></pre>
<p>我们使用 多条件 的原因是为了避免使代码混乱, 通过使用<code>if</code>,第一行或最后一行或列边缘情况的条件. 但我们付出的代价是<code>div</code>, 也就是最常见的情况,既不是<code>row</code>也不是<code>column</code>,而是在宇宙的边缘,他们不需要模数包裹处理. 相反,如果我们使用多个<code>if</code>为边缘情况,并展开此循环,CPU的分支预测器<em>应该</em>可以很好地预测它.</p>
<p>我们改写<code>live_neighbor_count</code>,像这样这个:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn live_neighbor_count(&amp;self, row: u32, column: u32) -&gt; u8 {
    let mut count = 0;

    let north = if row == 0 {
        self.height - 1
    } else {
        row - 1
    };

    let south = if row == self.height - 1 {
        0
    } else {
        row + 1
    };

    let west = if column == 0 {
        self.width - 1
    } else {
        column - 1
    };

    let east = if column == self.width - 1 {
        0
    } else {
        column + 1
    };

    let nw = self.get_index(north, west);
    count += self.cells[nw] as u8;

    let n = self.get_index(north, column);
    count += self.cells[n] as u8;

    let ne = self.get_index(north, east);
    count += self.cells[ne] as u8;

    let w = self.get_index(row, west);
    count += self.cells[w] as u8;

    let e = self.get_index(row, east);
    count += self.cells[e] as u8;

    let sw = self.get_index(south, west);
    count += self.cells[sw] as u8;

    let s = self.get_index(south, column);
    count += self.cells[s] as u8;

    let se = self.get_index(south, east);
    count += self.cells[se] as u8;

    count
}
#}</code></pre></pre>
<p>现在让我们再次运行基准测试!</p>
<pre><code>$ cargo bench
   Compiling wasm_game_of_life v0.1.0 (file:///home/fitzgen/wasm_game_of_life)
    Finished release [optimized + debuginfo] target(s) in 0.82 secs
     Running target/release/deps/wasm_game_of_life-91574dfbe2b5a124

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/release/deps/bench-8474091a05cfa2d9

running 1 test
test universe_ticks ... bench:      87,258 ns/iter (+/- 14,632)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured; 0 filtered out
</code></pre>
<p>看起来好多了! 我们可以看到它有多好,通过<a href="https://github.com/BurntSushi/cargo-benchcmp"><code>cargo benchcmp</code></a>工具:</p>
<pre><code>$ cargo benchcmp before.txt after.txt
 name            before.txt ns/iter  after.txt ns/iter  diff ns/iter   diff %  speedup
 universe_ticks  664,421             87,258                 -577,163  -86.87%   x 7.61
</code></pre>
<p>哇! 7.61倍加速!</p>
<p>WebAssembly 映射到常见的硬件架构,但我们确实需要为这个本机代码加速.</p>
<p>让我们恢复所有<code>#[wasm_bindgen]</code>注释,重建<code>.wasm</code>同<code>npm run build-release</code>,并刷新<a href="http://localhost:8080/">http://localhost:8080/</a>. 在我的机器上,页面再次以每秒60帧的速度运行,并且使用浏览器的分析器记录,另一个配置文件显示每个动画帧大约需要10毫秒.</p>
<p>成功!</p>
<p><a href="./images/game-of-life/waterfall-after-branches-and-unrolling.png"><img src="./images/game-of-life/waterfall-after-branches-and-unrolling.png" alt="Screenshot of a waterfall view of rendering a frame after replacing modulos with branches" /></a></p>
<a class="header" href="print.html#a练习-5" id="a练习-5"><h2>练习</h2></a>
<ul>
<li>
<p>在这一点上,下一个加速<code>Universe::tick</code>是删除分配和免费. 实现细胞的双缓冲,其中<code>Universe</code>维护两个向量,并且不释放它们中的任何一个,那么就永远不会分配新的缓冲区<code>tick</code>.</p>
</li>
<li>
<p>从&quot;实现生命&quot;一章的实现是 基于delta 的设计,其中 Rust代码 返回 将状态更改为JavaScript 的单元格列表. 这会使渲染<code>&lt;canvas&gt;</code>更快? 你可以实现这个设计, 而不必在每个滴答上分配一个新的增量列表吗 ?</p>
</li>
<li>
<p>正如我们的分析向我们展示的那样,2D<code>&lt;canvas&gt;</code>渲染速度不是特别快. 用WebGL 渲染器替换 2 canvas 渲染器. WebGL版本的速度有多快 ? 在WebGL渲染成为瓶颈之前,你能创造多大的宇宙 ?</p>
</li>
</ul>
<a class="header" href="print.html#a收缩wasm尺寸" id="a收缩wasm尺寸"><h1>收缩<code>.wasm</code>尺寸</h1></a>
<p>本章将教你如何优化你的<code>.wasm</code>大小,以及如何改变Rust源代码以缩小<code>.wasm</code>代码.</p>
<a class="header" href="print.html#a优化代码大小的构建" id="a优化代码大小的构建"><h2>优化代码大小的构建</h2></a>
<p>我们可以使用<code>rustc</code>很多配置选项变小<code>.wasm</code>二进制文件. 在某些情况下,我们的编译时间较长,<code>.wasm</code>更小. 在其他情况下,我们以较小的代码大小交换WebAssembly 的运行时速度. 我们应该认识到每个选项的权衡,并且在我们交换代码大小,概况和度量的运行时速度, 以便做出关于交易是否值得的明智决策.</p>
<a class="header" href="print.html#a禁用调试符号" id="a禁用调试符号"><h3>禁用调试符号</h3></a>
<p>包含用于调试的函数名字符串的部分, 占用的空间比您想象的要多. 如果您没有调试或分析, 并希望生成一个小的<code>.wasm</code>二进制,需要禁用这些名称.</p>
<p>在<code>Cargo.toml</code>设置:</p>
<pre><code class="language-toml">[profile.release]
debug = false
</code></pre>
<a class="header" href="print.html#a使用链接时间优化-lto-进行编译" id="a使用链接时间优化-lto-进行编译"><h3>使用链接时间优化 (LTO) 进行编译</h3></a>
<p>在<code>Cargo.toml</code>,添加<code>lto = true</code>在<code>[profile.release]</code>部分:</p>
<pre><code class="language-toml">[profile.release]
lto = true
</code></pre>
<p>这为 LLVM 提供了更多内联和修剪功能的机会. 它不仅会成功<code>.wasm</code>更小,但它也会在运行时更快! 缺点是编译需要更长时间.</p>
<a class="header" href="print.html#a告诉-llvm-优化大小而不是速度" id="a告诉-llvm-优化大小而不是速度"><h3>告诉 LLVM 优化大小而不是速度</h3></a>
<p>默认情况下,调整LLVM的优化过程是提高速度,而不是大小. 我们可以通过修改目标, 来将目标更改为代码大小</p>
<p><code>[profile.release]</code>部分:</p>
<pre><code class="language-toml">[profile.release]
opt-level = 's'
</code></pre>
<p>或者,更进一步优化尺寸,以更大的速度成本:</p>
<pre><code class="language-toml">[profile.release]
opt-level = 'z'
</code></pre>
<p>请注意,令人惊讶的是,<code>opt-level = &quot;s&quot;</code>,有时会导致 比 <code>opt-level = &quot;z&quot;</code> 更小. 总是要对比看看!</p>
<a class="header" href="print.html#a使用wasm-opt工具" id="a使用wasm-opt工具"><h3>使用<code>wasm-opt</code>工具</h3></a>
<p>该<a href="https://github.com/WebAssembly/binaryen">Binaryen</a>toolkit 是特定于 WebAssembly的编译器工具的集合. 它比LLVM 的WebAssembly后端 更进一步.</p>
<p>使用<code>wasm-opt</code>后,处理 LLVM 生成的<code>.wasm</code>二进制文件通常可以节省15-20%的代码大小. 它通常还能帮运行时加速!</p>
<pre><code class="language-bash"># Optimize for size.
wasm-opt -Os -o output.wasm input.wasm

# Optimize aggressively for size.
wasm-opt -Oz -o output.wasm input.wasm

# Optimize for speed.
wasm-opt -O -o output.wasm input.wasm

# Optimize aggressively for speed.
wasm-opt -O3 -o output.wasm input.wasm
</code></pre>
<a class="header" href="print.html#a这些构建配置让我们的生命游戏wasm二进制有多小" id="a这些构建配置让我们的生命游戏wasm二进制有多小"><h3>这些构建配置让我们的生命游戏<code>.wasm</code>二进制有多小?</h3></a>
<p>使用默认版本构建配置 (没有调试符号) ,我们的WebAssembly二进制文件为240,605字节:</p>
<pre><code>$ wc -c wasm_game_of_life_bg.wasm
240605 wasm_game_of_life_bg.wasm
</code></pre>
<p>启用 LTO 后,进行设置<code>opt-level = &quot;z&quot;</code>,并运行<code>wasm-opt -Oz</code>, 所结果的<code>.wasm</code>二进制缩小到只有37,424字节!</p>
<pre><code>$ wc -c wasm_game_of_life_bg.wasm
37424 wasm_game_of_life_bg.wasm
</code></pre>
<a class="header" href="print.html#a大小分析" id="a大小分析"><h2>大小分析</h2></a>
<p>如果调整构建配置以优化代码大小后,不会导致足够小<code>.wasm</code>二进制,是时候进行一些分析,以查看剩余代码大小的来源.</p>
<blockquote>
<p>⚡就像我们如何让时间分析指导我们的加速工作一样,我们希望让大小分析指导我们的代码大小缩小工作量. 不这样做,你可能会浪费自己的时间!</p>
</blockquote>
<a class="header" href="print.html#a该twiggy代码大小分析器" id="a该twiggy代码大小分析器"><h3>该<code>twiggy</code>代码大小分析器</h3></a>
<p><a href="https://github.com/rustwasm/twiggy"><code>twiggy</code>是一个代码大小分析器</a>支持 WebAssembly 作为输入. 它分析二进制的调用图来回答如下问题:</p>
<ul>
<li>
<p>为什么这个函数首先包含在二进制文件中?</p>
</li>
<li>
<p>这个函数<em>保留大小</em>多少? 即如果删除它, 以及删除后所有死代码的函数,将节省多少空间?</p>
</li>
</ul>
<style>
/* For whatever reason, the defautl mdbook fonts fonts break with the
   following box-drawing characters, hence the manual style. */
pre, code {
  font-family: "SFMono-Regular",Consolas,"Liberation Mono",Menlo,Courier,monospace;
}
</style>
<pre><code class="language-text">$ twiggy top -n 20 wasm_game_of_life_bg.wasm
 Shallow Bytes │ Shallow % │ Item
───────────────┼───────────┼────────────────────────────────────────────────────────────────────────────────────────
          9158 ┊    19.65% ┊ &quot;function names&quot; subsection
          3251 ┊     6.98% ┊ dlmalloc::dlmalloc::Dlmalloc::malloc::h632d10c184fef6e8
          2510 ┊     5.39% ┊ &lt;str as core::fmt::Debug&gt;::fmt::he0d87479d1c208ea
          1737 ┊     3.73% ┊ data[0]
          1574 ┊     3.38% ┊ data[3]
          1524 ┊     3.27% ┊ core::fmt::Formatter::pad::h6825605b326ea2c5
          1413 ┊     3.03% ┊ std::panicking::rust_panic_with_hook::h1d3660f2e339513d
          1200 ┊     2.57% ┊ core::fmt::Formatter::pad_integral::h06996c5859a57ced
          1131 ┊     2.43% ┊ core::str::slice_error_fail::h6da90c14857ae01b
          1051 ┊     2.26% ┊ core::fmt::write::h03ff8c7a2f3a9605
           931 ┊     2.00% ┊ data[4]
           864 ┊     1.85% ┊ dlmalloc::dlmalloc::Dlmalloc::free::h27b781e3b06bdb05
           841 ┊     1.80% ┊ &lt;char as core::fmt::Debug&gt;::fmt::h07742d9f4a8c56f2
           813 ┊     1.74% ┊ __rust_realloc
           708 ┊     1.52% ┊ core::slice::memchr::memchr::h6243a1b2885fdb85
           678 ┊     1.45% ┊ &lt;core::fmt::builders::PadAdapter&lt;'a&gt; as core::fmt::Write&gt;::write_str::h96b72fb7457d3062
           631 ┊     1.35% ┊ universe_tick
           631 ┊     1.35% ┊ dlmalloc::dlmalloc::Dlmalloc::dispose_chunk::hae6c5c8634e575b8
           514 ┊     1.10% ┊ std::panicking::default_hook::{{closure}}::hfae0c204085471d5
           503 ┊     1.08% ┊ &lt;&amp;'a T as core::fmt::Debug&gt;::fmt::hba207e4f7abaece6
</code></pre>
<a class="header" href="print.html#a手动检查-llvm-ir" id="a手动检查-llvm-ir"><h3>手动检查 LLVM-IR</h3></a>
<p>LLVM-IR 是 LLVM 生成 WebAssembly之前编译器工具链中的最终中间表示. 因此,它与最终发出的 WebAssembly 非常相似. 更多LLVM-IR 通常意味着更多<code>.wasm</code>大小,如果一个函数占 LLVM-IR的25%,那么它通常会占25%<code>.wasm</code>. 虽然这些数字一般只保留. LLVM-IR 具有关键信息,而这些信息并不存在<code>.wasm</code>中 (因为 WebAssembly 缺少像 DWAR F这样的调试格式) : 哪些子程序被内联到 给定的函数中.</p>
<p>您可以使用此方法生成 LLVM-IR:</p>
<pre><code>cargo rustc --release -- --emit llvm-ir
</code></pre>
<p>然后,你可以使用<code>find</code>找到<code>.ll</code>包含 LLVM-IR 的文件:</p>
<pre><code>find target/release -type f -name '*.ll'
</code></pre>
<a class="header" href="print.html#a参考-2" id="a参考-2"><h4>参考</h4></a>
<ul>
<li><a href="https://llvm.org/docs/LangRef.html">LLVM语言参考手册</a></li>
</ul>
<a class="header" href="print.html#a更具侵入性的工具和技术" id="a更具侵入性的工具和技术"><h2>更具侵入性的工具和技术</h2></a>
<p>调整构建配置,以缩小<code>.wasm</code>二进制文件非常适合. 但是,当您需要加倍努力时,您准备使用更具侵入性的技术,例如重写源代码以避免膨胀. 接下来是一系列可以应用于获取较小代码的自适应技巧.</p>
<a class="header" href="print.html#a避免使用字符串格式" id="a避免使用字符串格式"><h3>避免使用字符串格式</h3></a>
<p><code>format!</code>,<code>to_string</code>等等...可以带来很多代码臃肿. 如果可能,仅在调试模式下进行字符串格式化,在发布模式下使用静态字符串.</p>
<a class="header" href="print.html#a避免恐慌" id="a避免恐慌"><h3>避免恐慌</h3></a>
<p>这说起来容易做起来难,但工具就像<code>twiggy</code>并手动检查LLVM-IR可以帮助您找出哪些功能令人恐慌.</p>
<p>恐慌并不总是表现为<code>panic!()</code>宏调用. 它们隐含地来自许多结构,例如:</p>
<ul>
<li>
<p>对超出范围索引的切片进行索引: <code>my_slice[i]</code></p>
</li>
<li>
<p>如果除数为零,则 分得数 会惊慌失措: <code>dividend / divisor</code></p>
</li>
<li>
<p>打开一个<code>Option</code>或者<code>Result</code>: <code>opt.unwrap()</code>或者<code>res.unwrap()</code></p>
</li>
</ul>
<p>前两个可以体现为第三个. 索引可以用<code>my_slice.get(i)</code>操作. 分得数 可以<code>checked_div</code>调用. 现在我们只有一个案例可以应对.</p>
<p>打开一个<code>Option</code>或者<code>Result</code>没有恐慌有两种风格: 安全和不安全.</p>
<p>安全的方法是<code>abort</code>代替恐慌,当得出一个<code>None</code>或一个<code>Error</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[inline]
pub fn unwrap_abort&lt;T&gt;(o: Option&lt;T&gt;) -&gt; T {
    use std::process;
    match o {
        Some(t) =&gt; t,
        None =&gt; process::abort(),
    }
}
#}</code></pre></pre>
<p>最终,无论如何在<code>wasm32-unknown-unknown</code>恐慌都会转化为 aborts ,所以这给你相同的行为,但没有代码膨胀.</p>
<p>或者,<a href="https://crates.io/crates/unreachable"><code>unreachable</code>箱</a>提供不安全的<a href="https://docs.rs/unreachable/1.0.0/unreachable/trait.UncheckedOptionExt.html#tymethod.unchecked_unwrap"><code>unchecked_unwrap</code>扩展方法</a>对于<code>Option</code>和<code>Result</code>, 它告诉Rust编译器<em>承担</em>那个<code>Option</code>是<code>Some</code>或者<code>Result</code>是<code>Ok</code>. 它是未定义如果该假设不成立,会发生什么. 你真的只能当你110%确定时,使用这种不安全的方法,而且编译器只是不够聪明看到它. 即使你沿着这条路走下去,你也应该有一个仍然进行检查的调试构建配置,并且只在发布版本中使用未经检查的操作.</p>
<a class="header" href="print.html#a避免分配或切换到wee_alloc" id="a避免分配或切换到wee_alloc"><h3>避免分配或切换到<code>wee_alloc</code></h3></a>
<p>Rust对WebAssembly的默认分配器,是<code>dlmalloc</code>的一部分. 它的重量大约在10千字节左右. 如果你可以完全避免动态分配,那么你应该能够减少这十个千字节.</p>
<p>完全避免动态分配可能非常困难. 但是从热代码路径中删除分配通常要容易得多 (并且通常也有助于使这些热代码路径更快) . 在这些情况下,<a href="https://github.com/rustwasm/wee_alloc">用,替换默认的全局分配器<code>wee_alloc</code></a>应该节省你最多 (但不是全部) 的十千字节. <code>wee_alloc</code>是一个为您需要<em>一些</em>类型情况时设计,但不需要特别快的分配器,并将愉快地交换分配速度较小的代码大小的分配器.</p>
<a class="header" href="print.html#a使用特征对象而不是通用类型参数" id="a使用特征对象而不是通用类型参数"><h3>使用特征对象而不是通用类型参数</h3></a>
<p>当您创建使用类型参数的泛型函数时,如下所示:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn whatever&lt;T: MyTrait&gt;(t: T) { ... }
#}</code></pre></pre>
<p>然后<code>rustc</code>和 LLVM 将为每个创建一个新的函数副本 - <code>T</code>类型函数. 这为基于特定的<code>T</code>每个副本都在使用的编译器的优化提供了许多机会,但这些副本在代码大小方面快速增加.</p>
<p>如果您使用特征对象而不是类型参数,如下所示:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn whatever(t: Box&lt;MyTrait&gt;) { ... }
// or
fn whatever(t: &amp;MyTrait) { ... }
// etc...
#}</code></pre></pre>
<p>然后使用通过虚拟调用的动态调度,并且仅在该函数中发出单个版本的函数<code>.wasm</code>. 缺点是失去了编译器优化机会,以及间接动态调度函数调用的额外成本.</p>
<a class="header" href="print.html#a使用wasm-snip工具" id="a使用wasm-snip工具"><h3>使用<code>wasm-snip</code>工具</h3></a>
<p><a href="https://github.com/fitzgen/wasm-snip"><code>wasm-snip</code>用一个替换WebAssembly函数的主体的<code>unreachable</code>指令. </a>这是一个相当沉重,钝的锤子,如果你足够眯眼,那些看起来像指甲的函数.</p>
<p>也许您知道某些函数永远不会在运行时调用,但编译器无法在编译时证明这一点? 剪断它! 然后,跑<code>wasm-opt</code>带着<code>--dce</code>,以及<code>snipping 函数</code>传递调用的所有函数 (也可能永远不会在运行时调用) 也将被删除.</p>
<p>这个工具对于消除恐慌特别有用,因为恐慌最终会转化为陷阱.</p>
<a class="header" href="print.html#a练习-6" id="a练习-6"><h2>练习</h2></a>
<ul>
<li>
<p>使用<code>wasm-snip</code>从我们的生命游戏中删除恐慌基础函数,<code>.wasm</code>二进制文件节省了多少字节?</p>
</li>
<li>
<p>将我们的生命游戏箱改为使用<code>wee_alloc</code>作为分配者. 剃掉了<code>.wasm</code>二进制多少尺寸?</p>
</li>
<li>
<p>我们只实例化一个单一的<code>Universe</code>,因此我们可以导出<code>static mut</code>全局实例的操作,而不是提供构造函数. 如果这个全局实例也使用前面章节中讨论的双缓冲技术,我们也可以使这些缓冲区成为全局<code>static mut</code>. 这将从我们的生命游戏实现中删除所有动态分配,我们可以将其作为一个不包含分配器的<code>#![no_std]</code>箱子. 从中移除了多少尺寸<code>.wasm</code>通过完全删除分配器依赖?</p>
</li>
</ul>
<a class="header" href="print.html#a用wasm-pack发布" id="a用wasm-pack发布"><h1>用<code>wasm-pack</code>发布</h1></a>
<p>Go</p>
<a class="header" href="print.html#a介绍" id="a介绍"><h1>介绍</h1></a>
<p><code>wasm-pack</code>是一个全新的工具,旨在打包wasm的二进制文件 (可能包含或不包含JS) ,并且可以轻松地在npm上发布它们.</p>
<p>我们不需要能直接向开发人员分发Rust代码,并期望他们从头开始构建它. npm 用于安装前端工作的包,但它不知道如何编译Rust! 虽然这不是一个问题. 一旦它编译完毕,一切都很好. 然而,准备好分发,正确打包, 然后将其发送到 npm 可能有点麻烦. <code>wasm-pack</code>是为了让这更容易.</p>
<p>我们将逐步创建一个简单的Rust库后, 使用<code>wasm-pack</code>准备分发,发送到npm,然后从 npm 使用它来验证它的工作原理!</p>
<p>与早期的所有软件一样,这是最前沿的! 期待一些刻痕和瘀伤!如果您遇到问题或错误,请提出问题<a href="https://github.com/rustwasm/wasm-pack/issues">repo</a>.</p>
<a class="header" href="print.html#a工具安装" id="a工具安装"><h1>工具安装</h1></a>
<a class="header" href="print.html#rust" id="rust"><h2>Rust</h2></a>
<p>如果您还没有,那么您需要安装Rust! 看到<a href="setup.html">安装章节</a>更多细节. 完成后,您需要安装<code>wasm-pack</code>.</p>
<pre><code class="language-bash">$ cargo install wasm-pack
</code></pre>
<p>并确保二进制文件在你的<code>$PATH</code>所以你可以运行它.</p>
<a class="header" href="print.html#npm-1" id="npm-1"><h2>npm</h2></a>
<p>如果你还没有安装npm,你需要这样做!按照可用的文档<a href="https://www.npmjs.com/get-npm">npm</a>或者通过包管理器安装它!</p>
<p>确认您已成功运行:</p>
<pre><code class="language-bash">$ npm --version
</code></pre>
<p>如果成功安装,您应该会看到终端中弹出的版本号!</p>
<a class="header" href="print.html#npm-帐户" id="npm-帐户"><h2>npm 帐户</h2></a>
<p>安装npm之后,如果你还没有账号,你需要在npm注册一个帐户才能完成教程,这样你就可以上传你的软件包了. 可以找到注册页面<a href="https://www.npmjs.com/signup">这里</a>.</p>
<a class="header" href="print.html#a项目初始化" id="a项目初始化"><h1>项目初始化</h1></a>
<p>现在我们已经安装了所有工具,并设置了我们的npm帐户,我们实际上可以开始编码! 我们将编写一个小箱子,两个数字相加并输出数字. 虽然这只是一个简单的例子,但我们仅关注如何使用 wasm-pack. 您将获得其他资源的链接,以便您可以制作更复杂的代码来打包并将它们发送到npm!</p>
<p>让我们开始吧!首先运行此命令来创建我们的项目:</p>
<pre><code class="language-bash">$ cargo new --lib wasm-add
</code></pre>
<p><code>wasm-add</code>新的Rust项目. 我们还指定我们正在构建一个<code>库lib</code>,因为我们将从JS调用此代码.</p>
<p>现在只是:</p>
<pre><code class="language-bash">cd wasm-add
</code></pre>
<p>你会发现这里的一切都准备好开始了. 首先,我们需要为代码添加依赖项并进行一些小的更改. 打开你的<code>Cargo.toml</code>文件. 你应该在里面看到这样的东西:</p>
<pre><code class="language-toml">[package]
name = &quot;wasm-add&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Michael Gattozzi &lt;mgattozzi@gmail.com&gt;&quot;]

[dependencies]
</code></pre>
<p>这个配置文件设置了我们开始所需的一切,但是我们需要一些额外的字段和设置才能让它适用于 wasm ,并为npm做好准备</p>
<pre><code class="language-toml">[package]
name = &quot;wasm-add&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Michael Gattozzi &lt;mgattozzi@gmail.com&gt;&quot;]
description = &quot;Code used to demonstrate how to use wasm-pack&quot;
license = &quot;MIT/Apache-2.0&quot;
repository = &quot;https://github.com/mgattozzi/wasm-add&quot;

[lib]
crate-type = [&quot;cdylib&quot;]

[dependencies]
wasm-bindgen = &quot;0.2&quot;
</code></pre>
<p>首先,让我们看看添加到包部分的最后三个字段<code>description</code>,<code>license</code>,和<code>repository</code>. npm 需要这个元数据等等<code>wasm-pack</code>在您设置代码之前,我们不会打包您的代码. 您可以添加更多特定的字段,你可以找到<a href="https://doc.rust-lang.org/cargo/reference/manifest.html">这里</a><code>crates.io</code>, 但是就本教程,这部分就是你所需要的.</p>
<p>您还会注意到我们添加了一个标题为的新部分<code>[lib]</code>. 在这里我们添加了这一行:</p>
<pre><code class="language-toml">crate-type = [&quot;cdylib&quot;]
</code></pre>
<p>通常 Rust 会,编译适用于其他Rust包格式的代码. 我们希望我们的代码能够与 wasm 一起使用! 我们指定它是一个兼容 C 的动态库. 这听起来有点奇怪,但是<code>wasm32</code>目标将知道解释此选项,而是正确生成一个 wasm 二进制文件. 这是为了让<code>cargo</code>能将正确的参数传递给编译器!</p>
<p>好吧,我们添加的最后一件事就是这个<code>[dependencies]</code>部分:</p>
<pre><code class="language-toml">wasm-bindgen = &quot;0.2&quot;
</code></pre>
<p>这是<code>wasm-bindgen</code>箱. 我们将很快使用它来使我们的函数与 wasm 很好地工作,而不必担心很多细节.</p>
<p>我们已经设置了包的元数据,所以让我们实际编写一些代码!</p>
<a class="header" href="print.html#rust编码" id="rust编码"><h1>rust编码</h1></a>
<p>如果你打开<code>src/lib.rs</code>你应该看到一个如下所示的文件:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
#}</code></pre></pre>
<p>让我们快速修改测试,以适应我们将要做的事情. 它应该如下所示:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn it_works() {
    assert_eq!(add(2, 2), 4);
}
#}</code></pre></pre>
<p>我们稍后会用它来确保我们的<code>add</code>功能有效!</p>
<p>现在我们需要将它添加到文件的顶部:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![feature(proc_macro, wasm_import_module, wasm_custom_section)]
#fn main() {
extern crate wasm_bindgen;
use wasm_bindgen::prelude::*;
#}</code></pre></pre>
<p>让我们逐行逐步完成. 首先是最新的<code>功能-feature</code>列表. 我们为整个箱子启用了这个功能. 这意味着我们稍后将使用属性标记代码,这将允许 Rust 生成我们不必手动编写的代码. 在我们的例子中,它将使用<code>wasm-bindgen</code>. 应当指出的是<code>#![feature(...)]</code>暗示使用最新的编译器. 这个目标功能有望很快稳定下来,之后你不需要它!</p>
<p><code>wasm-bindgen</code>知道如何让代码与 wasm 一起运行良好,所以我们不必过多担心,只需编写 Rust 代码. 如果您想知道其功能的全部范围,请查看<a href="https://github.com/alexcrichton/wasm-bindgen">这里</a>repo上的README. 出于我们的目的,我们需要知道,如果我们希望函数能够轻松地使用wasm,我们将需要它.</p>
<p>下一行说我们正在 import <code>wasm-bindgen</code>箱子和 use <code>wasm-bindgen</code> prelude. 该<code>extern crate</code>让编译器知道要链接的crate, 还有<code>prelude</code>包含所有类型和功能, 这样<code>wasm-bindgen</code>才能正常工作!</p>
<p>酷,让我们 import <code>alert</code> - 来自JS的函数,以便我们可以在 Rust代码 中调用它!</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
extern {
    fn alert(s: &amp;str);
}
#}</code></pre></pre>
<p>首先我们使用<code>#[wasm_bindgen]</code>属性. 该属性将处理所有代码,并导入我们在其下面声明的函数. 接下来是一个<code>外部区块{}</code>. 这让我们可以声明我们想要导入的JS函数. 我们只需要为它声明函数的类型或者名称之类. 在这种情况中,我们正在导入该功能<code>alert</code>需要一个<code>&amp;str</code>作为输入!</p>
<p>好吧,所以我们有我们的外部代码,我们已经导入了所有东西,所以让我们写下实际的<code>add</code>功能,以及<code>add_alert</code>将使用的函数<code>add</code>本身但也可以使用<code>alert</code>在返回值之前打印出结果.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[wasm_bindgen]
pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[wasm_bindgen]
pub fn alert_add(a: i32, b: i32) -&gt; i32 {
    let c = add(a, b);
    alert(&amp;format!(&quot;Hello from Rust! {} + {} = {}&quot;, a, b, c));
    c
}
#}</code></pre></pre>
<p>如果你熟悉Rust,这些函数是相当简单的,但是如果你不熟悉的话,我们帮你完成它. 这两个函数都有变量<code>a</code>和一个变量<code>b</code>. 我们说两者都是32位整数 (<code>i32</code>) . 然后我们说两者都将返回<code>i32</code>. 如果没有分号,函数的最后一行返回值. 所以在<code>add</code>函数的变量<code>a + b</code>得到计算,它的值被返回!</p>
<p>在<code>alert_add</code>,<code>add</code>函数变成了变量<code>c</code>,用来存储. 然后我们调用<code>alert</code>说添加操作看起来像什么,变量等于多少的字符串格式! 然后我们返回里面的东西<code>c</code>. 整齐!</p>
<p>这是我们需要编写的所有Rust代码. 你的<code>lib.rs</code>文件现在看起来应该是这样的:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![feature(proc_macro, wasm_import_module, wasm_custom_section)]
#fn main() {
extern crate wasm_bindgen;
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
extern {
    fn alert(s: &amp;str);
}

#[wasm_bindgen]
pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[wasm_bindgen]
pub fn alert_add(a: i32, b: i32) -&gt; i32 {
    let c = add(a, b);
    alert(&amp;format!(&quot;Hello from Rust! {} + {} = {}&quot;, a, b, c));
    c
}

#[test]
fn it_works() {
    assert_eq!(add(2, 2), 4);
}
#}</code></pre></pre>
<p>只是为了确保<code>add</code>正确,我们将运行我们之前写的测试:</p>
<pre><code class="language-bash">$ cargo test
</code></pre>
<p>您应该获得看起来像这样的输出:</p>
<pre><code class="language-bash">   Compiling wasm-add v0.1.1 (file:///home/michael/Code/wasm-add)
    Finished dev [unoptimized + debuginfo] target(s) in 0.54 secs
     Running target/debug/deps/wasm_add-5d5676e23e39dbea
running 1 test
test it_works ... ok
test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>这一切都有效! 请注意,我们没有添加测试<code>alert_add</code>. 这是因为 Rust 不会知道什么<code>alert</code>,除非 wasm代码 在浏览器中运行! 不过不要担心. 一旦我们打包这段代码并将其上传到 npm ,我们就会测试该函数,以确保一切正常,就像我们期望的那样!</p>
<p>您可以找到以上所有代码<a href="https://github.com/mgattozzi/wasm-add">这里</a>.</p>
<a class="header" href="print.html#npm的包装代码" id="npm的包装代码"><h1>npm的包装代码</h1></a>
<p>我们已经制作了我们的代码所以现在我们需要将它们打包. 在项目目录中运行以下命令:</p>
<pre><code class="language-bash">$ wasm-pack init --scope MYSCOPE
</code></pre>
<p><code>MYSCOPE</code>是你的npm用户名. 通常你可以输入<code>wasm-pack init</code></p>
<p>但是由于其他人也在做这个教程,我们不希望与<code>wasm-add</code>名字发生冲突!</p>
<p>运行命令会执行以下操作:</p>
<ol>
<li>如果你还没有,它会将你的代码编译成 wasm</li>
<li>它将生成一个带有 wasm文件 的pkg文件夹,一个围绕着 wasm的JS包装文件,你的自述文件和一个<code>package.json</code>文件.</li>
</ol>
<p>这就是将代码上传到npm所需的一切!让我们做到这一点!</p>
<p>首先,如果您还没有帐户,则需要使用之前创建的帐户登录npm:</p>
<pre><code class="language-bash">$ npm login
</code></pre>
<p>接下来你需要进入<code>pkg</code>目录并实际上传包:</p>
<pre><code class="language-bash">$ cd pkg
$ npm publish --access=public
</code></pre>
<p>现在通常情况下,如果没有<code>--scope MYSCOPE</code>,你可以<code>npm publish</code>,但如果你给它一个用户名,你需要告诉 npm 这实际上是公开的,才可以发布它.</p>
<p>我们需要在这里这样做,因为我们给了我们的包一个用户名,以避免彼此冲突! 接下来实际上是运行代码, 并验证我们从 npm 获得它, 以及我们如何使用该代码.</p>
<a class="header" href="print.html#a从npm运行代码" id="a从npm运行代码"><h1>从npm运行代码</h1></a>
<p>好吧,让我们创建一个新的小目录,来测试我们现在可以运行此代码 - 从npm中提取它.</p>
<pre><code class="language-bash">$ mkdir test
$ cd test
</code></pre>
<p>现在我们需要创建一个<code>package.json</code>看起来像这样的文件:</p>
<pre><code class="language-json">{
  &quot;scripts&quot;: {
    &quot;serve&quot;: &quot;webpack-dev-server&quot;
  },
  &quot;dependencies&quot;: {
    &quot;@MYSCOPE/wasm-add&quot;: &quot;^0.1.0&quot;
  },
  &quot;devDependencies&quot;: {
    &quot;webpack&quot;: &quot;^4.0.1&quot;,
    &quot;webpack-cli&quot;: &quot;^2.0.10&quot;,
    &quot;webpack-dev-server&quot;: &quot;^3.1.0&quot;
  }
}
</code></pre>
<p>哪里<code>MYSCOPE</code>是你的 npm 用户名. 您可以将其扩展为更完整的文件,但我们仅仅想验证这是否有效!</p>
<p>接下来我们需要创建一个小的 webpack 配置,以便我们可以使用<code>webpack-dev-server</code>正确地提供wasm文件.</p>
<p>应该注意的是,webpack不是必需的. 这只是本教程所选择的内容.</p>
<p>你只需要一些东西来打开服务器! <code>webpack.config.js</code>是这样的:</p>
<pre><code class="language-javascript">const path = require('path');
module.exports = {
  entry: &quot;./index.js&quot;,
  output: {
    path: path.resolve(__dirname, &quot;dist&quot;),
    filename: &quot;index.js&quot;,
  },
  mode: &quot;development&quot;
};
</code></pre>
<p>这告诉 webpack 它是否会开始使用<code>index.js</code>. 在我们这样做之前,我们需要设置一个小的 html 文件.</p>
<p>创建一个名为的新文件<code>index.html</code>把它放好:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;wasm-pack example&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>我们差不多了. 现在我们需要设置我们的JS文件,以便我们可以运行一些 wasm 代码! 制作一个名为<code>index.js</code>把它放在里面:</p>
<pre><code class="language-javascript">const js = import(&quot;@MYSCOPE/wasm-add/wasm_add.js&quot;);
js.then(js =&gt; {
  js.alert_add(3,2);
});
</code></pre>
<p>自从网络包<a href="https://github.com/webpack/webpack/issues/6615">无法同步加载wasm</a>,我们使用上面的<code>import</code>语句后跟<code>promise</code>,以便正确加载它.</p>
<p>这就是让我们<code>then</code>再调用<code>alert_add</code>的原因. 我们还没有得到<code>node_module</code>文件夹,所以让我们最后<code>npm i</code>,并运行示例!</p>
<pre><code class="language-bash">$ npm install
$ npm run serve
</code></pre>
<p>然后在Web浏览器中导航到<code>http://localhost:8080</code>你应该看到这样的东西:</p>
<p><img src="./wasm-pack/wasm-pack.png" alt="An alert box saying &quot;Hello from Rust! 3 + 2 = 5&quot;" /></p>
<p>如果您确实恭喜您已成功将您的第一段 wasm 代码上传到npm并正确使用它!</p>
<a class="header" href="print.html#a下一步" id="a下一步"><h1>下一步</h1></a>
<p>这是对<code>wasm-pack</code>的介绍,但也使用了来自<code>npm的wasm</code>代码. 其实你可以改进项目设置,扩展你的代码 - 实际可以做的事情,</p>
<p>或者扩展你如何使用你创建的包.</p>
<p>整个主题空间是完全开放的,所以你可以做什么,不能做什么都没有限制!</p>
<p>去那里尝试一些很酷的新事物. 快乐的黑客!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        <script type="text/javascript">
            document.addEventListener('DOMContentLoaded', function() {
                window.print();
            })
        </script>
        

        

        
        <script src="searchindex.js" type="text/javascript" charset="utf-8"></script>
        
        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

    </body>
</html>
